/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/images/leagues sync recursive ^\\.\\/.*\\.png$":
/*!************************************************!*\
  !*** ./src/images/leagues/ sync ^\.\/.*\.png$ ***!
  \************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var map = {
	"./Elite_Series.png": "(app-pages-browser)/./src/images/leagues/Elite_Series.png",
	"./Esports_Balkan_League.png": "(app-pages-browser)/./src/images/leagues/Esports_Balkan_League.png",
	"./Hitpoint_Masters.png": "(app-pages-browser)/./src/images/leagues/Hitpoint_Masters.png",
	"./LCK_CL.png": "(app-pages-browser)/./src/images/leagues/LCK_CL.png",
	"./LPLOL.png": "(app-pages-browser)/./src/images/leagues/LPLOL.png",
	"./NLC.png": "(app-pages-browser)/./src/images/leagues/NLC.png",
	"./Prime_League_1st_Division.png": "(app-pages-browser)/./src/images/leagues/Prime_League_1st_Division.png",
	"./Turkey_Academy_League.png": "(app-pages-browser)/./src/images/leagues/Turkey_Academy_League.png",
	"./cblol.png": "(app-pages-browser)/./src/images/leagues/cblol.png",
	"./lck.png": "(app-pages-browser)/./src/images/leagues/lck.png",
	"./lcknav.png": "(app-pages-browser)/./src/images/leagues/lcknav.png",
	"./lco.png": "(app-pages-browser)/./src/images/leagues/lco.png",
	"./lcs.png": "(app-pages-browser)/./src/images/leagues/lcs.png",
	"./lec.png": "(app-pages-browser)/./src/images/leagues/lec.png",
	"./lecnav.png": "(app-pages-browser)/./src/images/leagues/lecnav.png",
	"./lfl.png": "(app-pages-browser)/./src/images/leagues/lfl.png",
	"./ljl.png": "(app-pages-browser)/./src/images/leagues/ljl.png",
	"./lla.png": "(app-pages-browser)/./src/images/leagues/lla.png",
	"./llanav.png": "(app-pages-browser)/./src/images/leagues/llanav.png",
	"./lpl.png": "(app-pages-browser)/./src/images/leagues/lpl.png",
	"./lvp_superliga.png": "(app-pages-browser)/./src/images/leagues/lvp_superliga.png",
	"./na_academy_league.png": "(app-pages-browser)/./src/images/leagues/na_academy_league.png",
	"./pcs.png": "(app-pages-browser)/./src/images/leagues/pcs.png",
	"./tcl.png": "(app-pages-browser)/./src/images/leagues/tcl.png",
	"./ultraliga.png": "(app-pages-browser)/./src/images/leagues/ultraliga.png",
	"./vcs.png": "(app-pages-browser)/./src/images/leagues/vcs.png"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "(app-pages-browser)/./src/images/leagues sync recursive ^\\.\\/.*\\.png$";

/***/ }),

/***/ "(app-pages-browser)/./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js":
/*!*********************************************************************!*\
  !*** ./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addDisposer: function() { return /* binding */ addDisposer; },\n/* harmony export */   addMiddleware: function() { return /* binding */ addMiddleware; },\n/* harmony export */   applyAction: function() { return /* binding */ applyAction; },\n/* harmony export */   applyPatch: function() { return /* binding */ applyPatch; },\n/* harmony export */   applySnapshot: function() { return /* binding */ applySnapshot; },\n/* harmony export */   cast: function() { return /* binding */ cast; },\n/* harmony export */   castFlowReturn: function() { return /* binding */ castFlowReturn; },\n/* harmony export */   castToReferenceSnapshot: function() { return /* binding */ castToReferenceSnapshot; },\n/* harmony export */   castToSnapshot: function() { return /* binding */ castToSnapshot; },\n/* harmony export */   clone: function() { return /* binding */ clone; },\n/* harmony export */   createActionTrackingMiddleware: function() { return /* binding */ createActionTrackingMiddleware; },\n/* harmony export */   createActionTrackingMiddleware2: function() { return /* binding */ createActionTrackingMiddleware2; },\n/* harmony export */   decorate: function() { return /* binding */ decorate; },\n/* harmony export */   destroy: function() { return /* binding */ destroy; },\n/* harmony export */   detach: function() { return /* binding */ detach; },\n/* harmony export */   escapeJsonPath: function() { return /* binding */ escapeJsonPath; },\n/* harmony export */   flow: function() { return /* binding */ flow; },\n/* harmony export */   getChildType: function() { return /* binding */ getChildType; },\n/* harmony export */   getEnv: function() { return /* binding */ getEnv; },\n/* harmony export */   getIdentifier: function() { return /* binding */ getIdentifier; },\n/* harmony export */   getLivelinessChecking: function() { return /* binding */ getLivelinessChecking; },\n/* harmony export */   getMembers: function() { return /* binding */ getMembers; },\n/* harmony export */   getNodeId: function() { return /* binding */ getNodeId; },\n/* harmony export */   getParent: function() { return /* binding */ getParent; },\n/* harmony export */   getParentOfType: function() { return /* binding */ getParentOfType; },\n/* harmony export */   getPath: function() { return /* binding */ getPath; },\n/* harmony export */   getPathParts: function() { return /* binding */ getPathParts; },\n/* harmony export */   getPropertyMembers: function() { return /* binding */ getPropertyMembers; },\n/* harmony export */   getRelativePath: function() { return /* binding */ getRelativePath; },\n/* harmony export */   getRoot: function() { return /* binding */ getRoot; },\n/* harmony export */   getRunningActionContext: function() { return /* binding */ getRunningActionContext; },\n/* harmony export */   getSnapshot: function() { return /* binding */ getSnapshot; },\n/* harmony export */   getType: function() { return /* binding */ getType; },\n/* harmony export */   hasParent: function() { return /* binding */ hasParent; },\n/* harmony export */   hasParentOfType: function() { return /* binding */ hasParentOfType; },\n/* harmony export */   isActionContextChildOf: function() { return /* binding */ isActionContextChildOf; },\n/* harmony export */   isActionContextThisOrChildOf: function() { return /* binding */ isActionContextThisOrChildOf; },\n/* harmony export */   isAlive: function() { return /* binding */ isAlive; },\n/* harmony export */   isArrayType: function() { return /* binding */ isArrayType; },\n/* harmony export */   isFrozenType: function() { return /* binding */ isFrozenType; },\n/* harmony export */   isIdentifierType: function() { return /* binding */ isIdentifierType; },\n/* harmony export */   isLateType: function() { return /* binding */ isLateType; },\n/* harmony export */   isLiteralType: function() { return /* binding */ isLiteralType; },\n/* harmony export */   isMapType: function() { return /* binding */ isMapType; },\n/* harmony export */   isModelType: function() { return /* binding */ isModelType; },\n/* harmony export */   isOptionalType: function() { return /* binding */ isOptionalType; },\n/* harmony export */   isPrimitiveType: function() { return /* binding */ isPrimitiveType; },\n/* harmony export */   isProtected: function() { return /* binding */ isProtected; },\n/* harmony export */   isReferenceType: function() { return /* binding */ isReferenceType; },\n/* harmony export */   isRefinementType: function() { return /* binding */ isRefinementType; },\n/* harmony export */   isRoot: function() { return /* binding */ isRoot; },\n/* harmony export */   isStateTreeNode: function() { return /* binding */ isStateTreeNode; },\n/* harmony export */   isType: function() { return /* binding */ isType; },\n/* harmony export */   isUnionType: function() { return /* binding */ isUnionType; },\n/* harmony export */   isValidReference: function() { return /* binding */ isValidReference; },\n/* harmony export */   joinJsonPath: function() { return /* binding */ joinJsonPath; },\n/* harmony export */   onAction: function() { return /* binding */ onAction; },\n/* harmony export */   onPatch: function() { return /* binding */ onPatch; },\n/* harmony export */   onSnapshot: function() { return /* binding */ onSnapshot; },\n/* harmony export */   process: function() { return /* binding */ process$1; },\n/* harmony export */   protect: function() { return /* binding */ protect; },\n/* harmony export */   recordActions: function() { return /* binding */ recordActions; },\n/* harmony export */   recordPatches: function() { return /* binding */ recordPatches; },\n/* harmony export */   resolveIdentifier: function() { return /* binding */ resolveIdentifier; },\n/* harmony export */   resolvePath: function() { return /* binding */ resolvePath; },\n/* harmony export */   setLivelinessChecking: function() { return /* binding */ setLivelinessChecking; },\n/* harmony export */   setLivelynessChecking: function() { return /* binding */ setLivelynessChecking; },\n/* harmony export */   splitJsonPath: function() { return /* binding */ splitJsonPath; },\n/* harmony export */   toGenerator: function() { return /* binding */ toGenerator; },\n/* harmony export */   toGeneratorFunction: function() { return /* binding */ toGeneratorFunction; },\n/* harmony export */   tryReference: function() { return /* binding */ tryReference; },\n/* harmony export */   tryResolve: function() { return /* binding */ tryResolve; },\n/* harmony export */   typecheck: function() { return /* binding */ typecheck; },\n/* harmony export */   types: function() { return /* binding */ types; },\n/* harmony export */   unescapeJsonPath: function() { return /* binding */ unescapeJsonPath; },\n/* harmony export */   unprotect: function() { return /* binding */ unprotect; },\n/* harmony export */   walk: function() { return /* binding */ walk; }\n/* harmony export */ });\n/* harmony import */ var mobx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mobx */ \"(app-pages-browser)/./node_modules/mobx/dist/mobx.esm.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n\n\nvar livelinessChecking = \"warn\";\n/**\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction setLivelinessChecking(mode) {\n    livelinessChecking = mode;\n}\n/**\n * Returns the current liveliness checking mode.\n *\n * @returns `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction getLivelinessChecking() {\n    return livelinessChecking;\n}\n/**\n * @deprecated use setLivelinessChecking instead\n * @hidden\n *\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction setLivelynessChecking(mode) {\n    setLivelinessChecking(mode);\n}\n\n/**\n * @hidden\n */\nvar Hook;\n(function (Hook) {\n    Hook[\"afterCreate\"] = \"afterCreate\";\n    Hook[\"afterAttach\"] = \"afterAttach\";\n    Hook[\"afterCreationFinalization\"] = \"afterCreationFinalization\";\n    Hook[\"beforeDetach\"] = \"beforeDetach\";\n    Hook[\"beforeDestroy\"] = \"beforeDestroy\";\n})(Hook || (Hook = {}));\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\n\n/**\n * Returns the _actual_ type of the given tree node. (Or throws)\n *\n * @param object\n * @returns\n */\nfunction getType(object) {\n    assertIsStateTreeNode(object, 1);\n    return getStateTreeNode(object).type;\n}\n/**\n * Returns the _declared_ type of the given sub property of an object, array or map.\n * In the case of arrays and maps the property name is optional and will be ignored.\n *\n * Example:\n * ```ts\n * const Box = types.model({ x: 0, y: 0 })\n * const box = Box.create()\n *\n * console.log(getChildType(box, \"x\").name) // 'number'\n * ```\n *\n * @param object\n * @param propertyName\n * @returns\n */\nfunction getChildType(object, propertyName) {\n    assertIsStateTreeNode(object, 1);\n    return getStateTreeNode(object).getChildType(propertyName);\n}\n/**\n * Registers a function that will be invoked for each mutation that is applied to the provided model instance, or to any of its children.\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details. onPatch events are emitted immediately and will not await the end of a transaction.\n * Patches can be used to deep observe a model tree.\n *\n * @param target the model instance from which to receive patches\n * @param callback the callback that is invoked for each patch. The reversePatch is a patch that would actually undo the emitted patch\n * @returns function to remove the listener\n */\nfunction onPatch(target, callback) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(callback, 2);\n    return getStateTreeNode(target).onPatch(callback);\n}\n/**\n * Registers a function that is invoked whenever a new snapshot for the given model instance is available.\n * The listener will only be fire at the end of the current MobX (trans)action.\n * See [snapshots](https://github.com/mobxjs/mobx-state-tree#snapshots) for more details.\n *\n * @param target\n * @param callback\n * @returns\n */\nfunction onSnapshot(target, callback) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(callback, 2);\n    return getStateTreeNode(target).onSnapshot(callback);\n}\n/**\n * Applies a JSON-patch to the given model instance or bails out if the patch couldn't be applied\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details.\n *\n * Can apply a single past, or an array of patches.\n *\n * @param target\n * @param patch\n * @returns\n */\nfunction applyPatch(target, patch) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertArg(patch, function (p) { return typeof p === \"object\"; }, \"object or array\", 2);\n    getStateTreeNode(target).applyPatches(asArray(patch));\n}\n/**\n * Small abstraction around `onPatch` and `applyPatch`, attaches a patch listener to a tree and records all the patches.\n * Returns an recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IPatchRecorder {\n *      // the recorded patches\n *      patches: IJsonPatch[]\n *      // the inverse of the recorded patches\n *      inversePatches: IJsonPatch[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording patches\n *      stop(): void\n *      // resume recording patches\n *      resume(): void\n *      // apply all the recorded patches on the given target (the original subject if omitted)\n *      replay(target?: IAnyStateTreeNode): void\n *      // reverse apply the recorded patches on the given target  (the original subject if omitted)\n *      // stops the recorder if not already stopped\n *      undo(): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain patches.\n *\n * @param subject\n * @param filter\n * @returns\n */\nfunction recordPatches(subject, filter) {\n    // check all arguments\n    assertIsStateTreeNode(subject, 1);\n    var data = {\n        patches: [],\n        reversedInversePatches: []\n    };\n    // we will generate the immutable copy of patches on demand for public consumption\n    var publicData = {};\n    var disposer;\n    var recorder = {\n        get recording() {\n            return !!disposer;\n        },\n        get patches() {\n            if (!publicData.patches) {\n                publicData.patches = data.patches.slice();\n            }\n            return publicData.patches;\n        },\n        get reversedInversePatches() {\n            if (!publicData.reversedInversePatches) {\n                publicData.reversedInversePatches = data.reversedInversePatches.slice();\n            }\n            return publicData.reversedInversePatches;\n        },\n        get inversePatches() {\n            if (!publicData.inversePatches) {\n                publicData.inversePatches = data.reversedInversePatches.slice().reverse();\n            }\n            return publicData.inversePatches;\n        },\n        stop: function () {\n            if (disposer) {\n                disposer();\n                disposer = undefined;\n            }\n        },\n        resume: function () {\n            if (disposer)\n                return;\n            disposer = onPatch(subject, function (patch, inversePatch) {\n                // skip patches that are asked to be filtered if there's a filter in place\n                if (filter && !filter(patch, inversePatch, getRunningActionContext())) {\n                    return;\n                }\n                data.patches.push(patch);\n                data.reversedInversePatches.unshift(inversePatch);\n                // mark immutable public patches as dirty\n                publicData.patches = undefined;\n                publicData.inversePatches = undefined;\n                publicData.reversedInversePatches = undefined;\n            });\n        },\n        replay: function (target) {\n            applyPatch(target || subject, data.patches);\n        },\n        undo: function (target) {\n            applyPatch(target || subject, data.reversedInversePatches);\n        }\n    };\n    recorder.resume();\n    return recorder;\n}\n/**\n * The inverse of `unprotect`.\n *\n * @param target\n */\nfunction protect(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    var node = getStateTreeNode(target);\n    if (!node.isRoot)\n        throw fail$1(\"`protect` can only be invoked on root nodes\");\n    node.isProtectionEnabled = true;\n}\n/**\n * By default it is not allowed to directly modify a model. Models can only be modified through actions.\n * However, in some cases you don't care about the advantages (like replayability, traceability, etc) this yields.\n * For example because you are building a PoC or don't have any middleware attached to your tree.\n *\n * In that case you can disable this protection by calling `unprotect` on the root of your tree.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *     done: false\n * }).actions(self => ({\n *     toggle() {\n *         self.done = !self.done\n *     }\n * }))\n *\n * const todo = Todo.create()\n * todo.done = true // throws!\n * todo.toggle() // OK\n * unprotect(todo)\n * todo.done = false // OK\n * ```\n */\nfunction unprotect(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    var node = getStateTreeNode(target);\n    if (!node.isRoot)\n        throw fail$1(\"`unprotect` can only be invoked on root nodes\");\n    node.isProtectionEnabled = false;\n}\n/**\n * Returns true if the object is in protected mode, @see protect\n */\nfunction isProtected(target) {\n    return getStateTreeNode(target).isProtected;\n}\n/**\n * Applies a snapshot to a given model instances. Patch and snapshot listeners will be invoked as usual.\n *\n * @param target\n * @param snapshot\n * @returns\n */\nfunction applySnapshot(target, snapshot) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).applySnapshot(snapshot);\n}\n/**\n * Calculates a snapshot from the given model instance. The snapshot will always reflect the latest state but use\n * structural sharing where possible. Doesn't require MobX transactions to be completed.\n *\n * @param target\n * @param applyPostProcess If true (the default) then postProcessSnapshot gets applied.\n * @returns\n */\nfunction getSnapshot(target, applyPostProcess) {\n    if (applyPostProcess === void 0) { applyPostProcess = true; }\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    var node = getStateTreeNode(target);\n    if (applyPostProcess)\n        return node.snapshot;\n    return freeze(node.type.getSnapshot(node, false));\n}\n/**\n * Given a model instance, returns `true` if the object has a parent, that is, is part of another object, map or array.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\nfunction hasParent(target, depth) {\n    if (depth === void 0) { depth = 1; }\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsNumber(depth, 2, 0);\n    var parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (--depth === 0)\n            return true;\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns the immediate parent of this object, or throws.\n *\n * Note that the immediate parent can be either an object, map or array, and\n * doesn't necessarily refer to the parent model.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\nfunction getParent(target, depth) {\n    if (depth === void 0) { depth = 1; }\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsNumber(depth, 2, 0);\n    var d = depth;\n    var parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (--d === 0)\n            return parent.storedValue;\n        parent = parent.parent;\n    }\n    throw fail$1(\"Failed to find the parent of \" + getStateTreeNode(target) + \" at depth \" + depth);\n}\n/**\n * Given a model instance, returns `true` if the object has a parent of given type, that is, is part of another object, map or array\n *\n * @param target\n * @param type\n * @returns\n */\nfunction hasParentOfType(target, type) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsType(type, 2);\n    var parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (type.is(parent.storedValue))\n            return true;\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns the target's parent of a given type, or throws.\n *\n * @param target\n * @param type\n * @returns\n */\nfunction getParentOfType(target, type) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsType(type, 2);\n    var parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (type.is(parent.storedValue))\n            return parent.storedValue;\n        parent = parent.parent;\n    }\n    throw fail$1(\"Failed to find the parent of \" + getStateTreeNode(target) + \" of a given type\");\n}\n/**\n * Given an object in a model tree, returns the root object of that tree.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @returns\n */\nfunction getRoot(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).root.storedValue;\n}\n/**\n * Returns the path of the given object in the model tree\n *\n * @param target\n * @returns\n */\nfunction getPath(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).path;\n}\n/**\n * Returns the path of the given object as unescaped string array.\n *\n * @param target\n * @returns\n */\nfunction getPathParts(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return splitJsonPath(getStateTreeNode(target).path);\n}\n/**\n * Returns true if the given object is the root of a model tree.\n *\n * @param target\n * @returns\n */\nfunction isRoot(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).isRoot;\n}\n/**\n * Resolves a path relatively to a given object.\n * Returns undefined if no value can be found.\n *\n * @param target\n * @param path escaped json path\n * @returns\n */\nfunction resolvePath(target, path) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsString(path, 2);\n    var node = resolveNodeByPath(getStateTreeNode(target), path);\n    return node ? node.value : undefined;\n}\n/**\n * Resolves a model instance given a root target, the type and the identifier you are searching for.\n * Returns undefined if no value can be found.\n *\n * @param type\n * @param target\n * @param identifier\n * @returns\n */\nfunction resolveIdentifier(type, target, identifier) {\n    // check all arguments\n    assertIsType(type, 1);\n    assertIsStateTreeNode(target, 2);\n    assertIsValidIdentifier(identifier, 3);\n    var node = getStateTreeNode(target).root.identifierCache.resolve(type, normalizeIdentifier(identifier));\n    return node === null || node === void 0 ? void 0 : node.value;\n}\n/**\n * Returns the identifier of the target node.\n * This is the *string normalized* identifier, which might not match the type of the identifier attribute\n *\n * @param target\n * @returns\n */\nfunction getIdentifier(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).identifier;\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns such reference if it the check passes,\n * else it returns undefined.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\nfunction tryReference(getter, checkIfAlive) {\n    if (checkIfAlive === void 0) { checkIfAlive = true; }\n    try {\n        var node = getter();\n        if (node === undefined || node === null) {\n            return undefined;\n        }\n        else if (isStateTreeNode(node)) {\n            if (!checkIfAlive) {\n                return node;\n            }\n            else {\n                return isAlive(node) ? node : undefined;\n            }\n        }\n        else {\n            throw fail$1(\"The reference to be checked is not one of node, null or undefined\");\n        }\n    }\n    catch (e) {\n        if (e instanceof InvalidReferenceError) {\n            return undefined;\n        }\n        throw e;\n    }\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns if the check passes or not.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\nfunction isValidReference(getter, checkIfAlive) {\n    if (checkIfAlive === void 0) { checkIfAlive = true; }\n    try {\n        var node = getter();\n        if (node === undefined || node === null) {\n            return false;\n        }\n        else if (isStateTreeNode(node)) {\n            return checkIfAlive ? isAlive(node) : true;\n        }\n        else {\n            throw fail$1(\"The reference to be checked is not one of node, null or undefined\");\n        }\n    }\n    catch (e) {\n        if (e instanceof InvalidReferenceError) {\n            return false;\n        }\n        throw e;\n    }\n}\n/**\n * Try to resolve a given path relative to a given node.\n *\n * @param target\n * @param path\n * @returns\n */\nfunction tryResolve(target, path) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsString(path, 2);\n    var node = resolveNodeByPath(getStateTreeNode(target), path, false);\n    if (node === undefined)\n        return undefined;\n    try {\n        return node.value;\n    }\n    catch (e) {\n        // For what ever reason not resolvable (e.g. totally not existing path, or value that cannot be fetched)\n        // see test / issue: 'try resolve doesn't work #686'\n        return undefined;\n    }\n}\n/**\n * Given two state tree nodes that are part of the same tree,\n * returns the shortest jsonpath needed to navigate from the one to the other\n *\n * @param base\n * @param target\n * @returns\n */\nfunction getRelativePath(base, target) {\n    // check all arguments\n    assertIsStateTreeNode(base, 1);\n    assertIsStateTreeNode(target, 2);\n    return getRelativePathBetweenNodes(getStateTreeNode(base), getStateTreeNode(target));\n}\n/**\n * Returns a deep copy of the given state tree node as new tree.\n * Short hand for `snapshot(x) = getType(x).create(getSnapshot(x))`\n *\n * _Tip: clone will create a literal copy, including the same identifiers. To modify identifiers etc during cloning, don't use clone but take a snapshot of the tree, modify it, and create new instance_\n *\n * @param source\n * @param keepEnvironment indicates whether the clone should inherit the same environment (`true`, the default), or not have an environment (`false`). If an object is passed in as second argument, that will act as the environment for the cloned tree.\n * @returns\n */\nfunction clone(source, keepEnvironment) {\n    if (keepEnvironment === void 0) { keepEnvironment = true; }\n    // check all arguments\n    assertIsStateTreeNode(source, 1);\n    var node = getStateTreeNode(source);\n    return node.type.create(node.snapshot, keepEnvironment === true\n        ? node.root.environment\n        : keepEnvironment === false\n            ? undefined\n            : keepEnvironment); // it's an object or something else\n}\n/**\n * Removes a model element from the state tree, and let it live on as a new state tree\n */\nfunction detach(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    getStateTreeNode(target).detach();\n    return target;\n}\n/**\n * Removes a model element from the state tree, and mark it as end-of-life; the element should not be used anymore\n */\nfunction destroy(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    var node = getStateTreeNode(target);\n    if (node.isRoot)\n        node.die();\n    else\n        node.parent.removeChild(node.subpath);\n}\n/**\n * Returns true if the given state tree node is not killed yet.\n * This means that the node is still a part of a tree, and that `destroy`\n * has not been called. If a node is not alive anymore, the only thing one can do with it\n * is requesting it's last path and snapshot\n *\n * @param target\n * @returns\n */\nfunction isAlive(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).observableIsAlive;\n}\n/**\n * Use this utility to register a function that should be called whenever the\n * targeted state tree node is destroyed. This is a useful alternative to managing\n * cleanup methods yourself using the `beforeDestroy` hook.\n *\n * This methods returns the same disposer that was passed as argument.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string\n * }).actions(self => ({\n *   afterCreate() {\n *     const autoSaveDisposer = reaction(\n *       () => getSnapshot(self),\n *       snapshot => sendSnapshotToServerSomehow(snapshot)\n *     )\n *     // stop sending updates to server if this\n *     // instance is destroyed\n *     addDisposer(self, autoSaveDisposer)\n *   }\n * }))\n * ```\n *\n * @param target\n * @param disposer\n * @returns The same disposer that was passed as argument\n */\nfunction addDisposer(target, disposer) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(disposer, 2);\n    var node = getStateTreeNode(target);\n    node.addDisposer(disposer);\n    return disposer;\n}\n/**\n * Returns the environment of the current state tree. For more info on environments,\n * see [Dependency injection](https://github.com/mobxjs/mobx-state-tree#dependency-injection)\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired\n *\n * Returns an empty environment if the tree wasn't initialized with an environment\n *\n * @param target\n * @returns\n */\nfunction getEnv(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    var node = getStateTreeNode(target);\n    var env = node.root.environment;\n    if (!env)\n        return EMPTY_OBJECT;\n    return env;\n}\n/**\n * Performs a depth first walk through a tree.\n */\nfunction walk(target, processor) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(processor, 2);\n    var node = getStateTreeNode(target);\n    // tslint:disable-next-line:no_unused-variable\n    node.getChildren().forEach(function (child) {\n        if (isStateTreeNode(child.storedValue))\n            walk(child.storedValue, processor);\n    });\n    processor(node.storedValue);\n}\n/**\n * Returns a reflection of the model type properties and name for either a model type or model node.\n *\n * @param typeOrNode\n * @returns\n */\nfunction getPropertyMembers(typeOrNode) {\n    var type;\n    if (isStateTreeNode(typeOrNode)) {\n        type = getType(typeOrNode);\n    }\n    else {\n        type = typeOrNode;\n    }\n    assertArg(type, function (t) { return isModelType(t); }, \"model type or model instance\", 1);\n    return {\n        name: type.name,\n        properties: __assign({}, type.properties)\n    };\n}\n/**\n * Returns a reflection of the model node, including name, properties, views, volatile and actions.\n *\n * @param target\n * @returns\n */\nfunction getMembers(target) {\n    var type = getStateTreeNode(target).type;\n    var reflected = __assign(__assign({}, getPropertyMembers(type)), { actions: [], volatile: [], views: [] });\n    var props = Object.getOwnPropertyNames(target);\n    props.forEach(function (key) {\n        if (key in reflected.properties)\n            return;\n        var descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (descriptor.get) {\n            if ((0,mobx__WEBPACK_IMPORTED_MODULE_0__.isComputedProp)(target, key))\n                reflected.views.push(key);\n            else\n                reflected.volatile.push(key);\n            return;\n        }\n        if (descriptor.value._isMSTAction === true)\n            reflected.actions.push(key);\n        else if ((0,mobx__WEBPACK_IMPORTED_MODULE_0__.isObservableProp)(target, key))\n            reflected.volatile.push(key);\n        else\n            reflected.views.push(key);\n    });\n    return reflected;\n}\n/**\n * Casts a node snapshot or instance type to an instance type so it can be assigned to a type instance.\n * Note that this is just a cast for the type system, this is, it won't actually convert a snapshot to an instance,\n * but just fool typescript into thinking so.\n * Either way, casting when outside an assignation operation won't compile.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * }).actions(self => ({\n *   someAction() {\n *     // this will allow the compiler to assign a snapshot to the property\n *     self.innerModel = cast({ a: 5 })\n *   }\n * }))\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object casted as an instance\n */\nfunction cast(snapshotOrInstance) {\n    return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to an snapshot type so it can be assigned to a type snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * })\n *\n * const a = ModelA.create({ n: 5 });\n * // this will allow the compiler to use a model as if it were a snapshot\n * const b = ModelB.create({ innerModel: castToSnapshot(a)})\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object casted as an input (creation) snapshot\n */\nfunction castToSnapshot(snapshotOrInstance) {\n    return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to a reference snapshot type so it can be assigned to a refernence snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a refererence snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   id: types.identifier,\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   refA: types.reference(ModelA)\n * })\n *\n * const a = ModelA.create({ id: 'someId', n: 5 });\n * // this will allow the compiler to use a model as if it were a reference snapshot\n * const b = ModelB.create({ refA: castToReferenceSnapshot(a)})\n * ```\n *\n * @param instance Instance\n * @returns The same object casted as an reference snapshot (string or number)\n */\nfunction castToReferenceSnapshot(instance) {\n    return instance;\n}\n/**\n * Returns the unique node id (not to be confused with the instance identifier) for a\n * given instance.\n * This id is a number that is unique for each instance.\n *\n * @export\n * @param target\n * @returns\n */\nfunction getNodeId(target) {\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).nodeId;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar BaseNode = /** @class */ (function () {\n    function BaseNode(type, parent, subpath, environment) {\n        Object.defineProperty(this, \"type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: type\n        });\n        Object.defineProperty(this, \"environment\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: environment\n        });\n        Object.defineProperty(this, \"_escapedSubpath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_subpath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_subpathUponDeath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pathUponDeath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"storedValue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        }); // usually the same type as the value, but not always (such as with references)\n        Object.defineProperty(this, \"aliveAtom\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_state\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: NodeLifeCycle.INITIALIZING\n        });\n        Object.defineProperty(this, \"_hookSubscribers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_parent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"pathAtom\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.environment = environment;\n        this.baseSetParent(parent, subpath);\n    }\n    Object.defineProperty(BaseNode.prototype, \"subpath\", {\n        get: function () {\n            return this._subpath;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"subpathUponDeath\", {\n        get: function () {\n            return this._subpathUponDeath;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"pathUponDeath\", {\n        get: function () {\n            return this._pathUponDeath;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"value\", {\n        get: function () {\n            return this.type.getValue(this);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"state\", {\n        get: function () {\n            return this._state;\n        },\n        set: function (val) {\n            var wasAlive = this.isAlive;\n            this._state = val;\n            var isAlive = this.isAlive;\n            if (this.aliveAtom && wasAlive !== isAlive) {\n                this.aliveAtom.reportChanged();\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"fireInternalHook\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (name) {\n            if (this._hookSubscribers) {\n                this._hookSubscribers.emit(name, this, name);\n            }\n        }\n    });\n    Object.defineProperty(BaseNode.prototype, \"registerHook\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (hook, hookHandler) {\n            if (!this._hookSubscribers) {\n                this._hookSubscribers = new EventHandlers();\n            }\n            return this._hookSubscribers.register(hook, hookHandler);\n        }\n    });\n    Object.defineProperty(BaseNode.prototype, \"parent\", {\n        get: function () {\n            return this._parent;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"getReconciliationType\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this.type;\n        }\n    });\n    Object.defineProperty(BaseNode.prototype, \"baseSetParent\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath) {\n            this._parent = parent;\n            this._subpath = subpath;\n            this._escapedSubpath = undefined; // regenerate when needed\n            if (this.pathAtom) {\n                this.pathAtom.reportChanged();\n            }\n        }\n    });\n    Object.defineProperty(BaseNode.prototype, \"path\", {\n        /*\n         * Returns (escaped) path representation as string\n         */\n        get: function () {\n            return this.getEscapedPath(true);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"getEscapedPath\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (reportObserved) {\n            if (reportObserved) {\n                if (!this.pathAtom) {\n                    this.pathAtom = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.createAtom)(\"path\");\n                }\n                this.pathAtom.reportObserved();\n            }\n            if (!this.parent)\n                return \"\";\n            // regenerate escaped subpath if needed\n            if (this._escapedSubpath === undefined) {\n                this._escapedSubpath = !this._subpath ? \"\" : escapeJsonPath(this._subpath);\n            }\n            return this.parent.getEscapedPath(reportObserved) + \"/\" + this._escapedSubpath;\n        }\n    });\n    Object.defineProperty(BaseNode.prototype, \"isRoot\", {\n        get: function () {\n            return this.parent === null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"isAlive\", {\n        get: function () {\n            return this.state !== NodeLifeCycle.DEAD;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"isDetaching\", {\n        get: function () {\n            return this.state === NodeLifeCycle.DETACHING;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"observableIsAlive\", {\n        get: function () {\n            if (!this.aliveAtom) {\n                this.aliveAtom = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.createAtom)(\"alive\");\n            }\n            this.aliveAtom.reportObserved();\n            return this.isAlive;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseNode.prototype, \"baseFinalizeCreation\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (whenFinalized) {\n            if (devMode()) {\n                if (!this.isAlive) {\n                    // istanbul ignore next\n                    throw fail(\"assertion failed: cannot finalize the creation of a node that is already dead\");\n                }\n            }\n            // goal: afterCreate hooks runs depth-first. After attach runs parent first, so on afterAttach the parent has completed already\n            if (this.state === NodeLifeCycle.CREATED) {\n                if (this.parent) {\n                    if (this.parent.state !== NodeLifeCycle.FINALIZED) {\n                        // parent not ready yet, postpone\n                        return;\n                    }\n                    this.fireHook(Hook.afterAttach);\n                }\n                this.state = NodeLifeCycle.FINALIZED;\n                if (whenFinalized) {\n                    whenFinalized();\n                }\n            }\n        }\n    });\n    Object.defineProperty(BaseNode.prototype, \"baseFinalizeDeath\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (this._hookSubscribers) {\n                this._hookSubscribers.clearAll();\n            }\n            this._subpathUponDeath = this._subpath;\n            this._pathUponDeath = this.getEscapedPath(false);\n            this.baseSetParent(null, \"\");\n            this.state = NodeLifeCycle.DEAD;\n        }\n    });\n    Object.defineProperty(BaseNode.prototype, \"baseAboutToDie\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.fireHook(Hook.beforeDestroy);\n        }\n    });\n    return BaseNode;\n}());\n\n/**\n * @internal\n * @hidden\n */\nvar ScalarNode = /** @class */ (function (_super) {\n    __extends(ScalarNode, _super);\n    function ScalarNode(simpleType, parent, subpath, environment, initialSnapshot) {\n        var _this = _super.call(this, simpleType, parent, subpath, environment) || this;\n        try {\n            _this.storedValue = simpleType.createNewInstance(initialSnapshot);\n        }\n        catch (e) {\n            // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n            _this.state = NodeLifeCycle.DEAD;\n            throw e;\n        }\n        _this.state = NodeLifeCycle.CREATED;\n        // for scalar nodes there's no point in firing this event since it would fire on the constructor, before\n        // anybody can actually register for/listen to it\n        // this.fireHook(Hook.AfterCreate)\n        _this.finalizeCreation();\n        return _this;\n    }\n    Object.defineProperty(ScalarNode.prototype, \"root\", {\n        get: function () {\n            // future optimization: store root ref in the node and maintain it\n            if (!this.parent)\n                throw fail$1(\"This scalar node is not part of a tree\");\n            return this.parent.root;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ScalarNode.prototype, \"setParent\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (newParent, subpath) {\n            var parentChanged = this.parent !== newParent;\n            var subpathChanged = this.subpath !== subpath;\n            if (!parentChanged && !subpathChanged) {\n                return;\n            }\n            if (devMode()) {\n                if (!subpath) {\n                    // istanbul ignore next\n                    throw fail$1(\"assertion failed: subpath expected\");\n                }\n                if (!newParent) {\n                    // istanbul ignore next\n                    throw fail$1(\"assertion failed: parent expected\");\n                }\n                if (parentChanged) {\n                    // istanbul ignore next\n                    throw fail$1(\"assertion failed: scalar nodes cannot change their parent\");\n                }\n            }\n            this.environment = undefined; // use parent's\n            this.baseSetParent(this.parent, subpath);\n        }\n    });\n    Object.defineProperty(ScalarNode.prototype, \"snapshot\", {\n        get: function () {\n            return freeze(this.getSnapshot());\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ScalarNode.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this.type.getSnapshot(this);\n        }\n    });\n    Object.defineProperty(ScalarNode.prototype, \"toString\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n            return this.type.name + \"@\" + path + (this.isAlive ? \"\" : \" [dead]\");\n        }\n    });\n    Object.defineProperty(ScalarNode.prototype, \"die\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (!this.isAlive || this.state === NodeLifeCycle.DETACHING)\n                return;\n            this.aboutToDie();\n            this.finalizeDeath();\n        }\n    });\n    Object.defineProperty(ScalarNode.prototype, \"finalizeCreation\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.baseFinalizeCreation();\n        }\n    });\n    Object.defineProperty(ScalarNode.prototype, \"aboutToDie\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.baseAboutToDie();\n        }\n    });\n    Object.defineProperty(ScalarNode.prototype, \"finalizeDeath\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.baseFinalizeDeath();\n        }\n    });\n    Object.defineProperty(ScalarNode.prototype, \"fireHook\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (name) {\n            this.fireInternalHook(name);\n        }\n    });\n    return ScalarNode;\n}(BaseNode));\nScalarNode.prototype.die = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.action)(ScalarNode.prototype.die);\n\nvar nextNodeId = 1;\nvar snapshotReactionOptions = {\n    onError: function (e) {\n        throw e;\n    }\n};\n/**\n * @internal\n * @hidden\n */\nvar ObjectNode = /** @class */ (function (_super) {\n    __extends(ObjectNode, _super);\n    function ObjectNode(complexType, parent, subpath, environment, initialValue) {\n        var _this = _super.call(this, complexType, parent, subpath, environment) || this;\n        Object.defineProperty(_this, \"nodeId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: ++nextNodeId\n        });\n        Object.defineProperty(_this, \"identifierAttribute\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"identifier\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        }); // Identifier is always normalized to string, even if the identifier property isn't\n        Object.defineProperty(_this, \"unnormalizedIdentifier\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"identifierCache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"isProtectionEnabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(_this, \"middlewares\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"_applyPatches\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"_applySnapshot\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"_autoUnbox\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        }); // unboxing is disabled when reading child nodes\n        Object.defineProperty(_this, \"_isRunningAction\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        }); // only relevant for root\n        Object.defineProperty(_this, \"_hasSnapshotReaction\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(_this, \"_observableInstanceState\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0 /* UNINITIALIZED */\n        });\n        Object.defineProperty(_this, \"_childNodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"_initialSnapshot\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"_cachedInitialSnapshot\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"_cachedInitialSnapshotCreated\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(_this, \"_snapshotComputed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"_snapshotUponDeath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // #region internal event handling\n        Object.defineProperty(_this, \"_internalEvents\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        _this._snapshotComputed = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.computed)(function () { return freeze(_this.getSnapshot()); });\n        _this.unbox = _this.unbox.bind(_this);\n        _this._initialSnapshot = freeze(initialValue);\n        _this.identifierAttribute = complexType.identifierAttribute;\n        if (!parent) {\n            _this.identifierCache = new IdentifierCache();\n        }\n        _this._childNodes = complexType.initializeChildNodes(_this, _this._initialSnapshot);\n        // identifier can not be changed during lifecycle of a node\n        // so we safely can read it from initial snapshot\n        _this.identifier = null;\n        _this.unnormalizedIdentifier = null;\n        if (_this.identifierAttribute && _this._initialSnapshot) {\n            var id = _this._initialSnapshot[_this.identifierAttribute];\n            if (id === undefined) {\n                // try with the actual node if not (for optional identifiers)\n                var childNode = _this._childNodes[_this.identifierAttribute];\n                if (childNode) {\n                    id = childNode.value;\n                }\n            }\n            if (typeof id !== \"string\" && typeof id !== \"number\") {\n                throw fail$1(\"Instance identifier '\" + _this.identifierAttribute + \"' for type '\" + _this.type.name + \"' must be a string or a number\");\n            }\n            // normalize internal identifier to string\n            _this.identifier = normalizeIdentifier(id);\n            _this.unnormalizedIdentifier = id;\n        }\n        if (!parent) {\n            _this.identifierCache.addNodeToCache(_this);\n        }\n        else {\n            parent.root.identifierCache.addNodeToCache(_this);\n        }\n        return _this;\n    }\n    Object.defineProperty(ObjectNode.prototype, \"applyPatches\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (patches) {\n            this.createObservableInstanceIfNeeded();\n            this._applyPatches(patches);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"applySnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (snapshot) {\n            this.createObservableInstanceIfNeeded();\n            this._applySnapshot(snapshot);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"createObservableInstanceIfNeeded\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (this._observableInstanceState === 0 /* UNINITIALIZED */) {\n                this.createObservableInstance();\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"createObservableInstance\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var e_1, _a;\n            if (devMode()) {\n                if (this.state !== NodeLifeCycle.INITIALIZING) {\n                    // istanbul ignore next\n                    throw fail$1(\"assertion failed: the creation of the observable instance must be done on the initializing phase\");\n                }\n            }\n            this._observableInstanceState = 1 /* CREATING */;\n            // make sure the parent chain is created as well\n            // array with parent chain from parent to child\n            var parentChain = [];\n            var parent = this.parent;\n            // for performance reasons we never go back further than the most direct\n            // uninitialized parent\n            // this is done to avoid traversing the whole tree to the root when using\n            // the same reference again\n            while (parent &&\n                parent._observableInstanceState === 0 /* UNINITIALIZED */) {\n                parentChain.unshift(parent);\n                parent = parent.parent;\n            }\n            try {\n                // initialize the uninitialized parent chain from parent to child\n                for (var parentChain_1 = __values(parentChain), parentChain_1_1 = parentChain_1.next(); !parentChain_1_1.done; parentChain_1_1 = parentChain_1.next()) {\n                    var p = parentChain_1_1.value;\n                    p.createObservableInstanceIfNeeded();\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (parentChain_1_1 && !parentChain_1_1.done && (_a = parentChain_1.return)) _a.call(parentChain_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            var type = this.type;\n            try {\n                this.storedValue = type.createNewInstance(this._childNodes);\n                this.preboot();\n                this._isRunningAction = true;\n                type.finalizeNewInstance(this, this.storedValue);\n            }\n            catch (e) {\n                // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n                this.state = NodeLifeCycle.DEAD;\n                throw e;\n            }\n            finally {\n                this._isRunningAction = false;\n            }\n            this._observableInstanceState = 2 /* CREATED */;\n            this._snapshotComputed.trackAndCompute();\n            if (this.isRoot)\n                this._addSnapshotReaction();\n            this._childNodes = EMPTY_OBJECT;\n            this.state = NodeLifeCycle.CREATED;\n            this.fireHook(Hook.afterCreate);\n            this.finalizeCreation();\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"root\", {\n        get: function () {\n            var parent = this.parent;\n            return parent ? parent.root : this;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ObjectNode.prototype, \"clearParent\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (!this.parent)\n                return;\n            // detach if attached\n            this.fireHook(Hook.beforeDetach);\n            var previousState = this.state;\n            this.state = NodeLifeCycle.DETACHING;\n            var root = this.root;\n            var newEnv = root.environment;\n            var newIdCache = root.identifierCache.splitCache(this);\n            try {\n                this.parent.removeChild(this.subpath);\n                this.baseSetParent(null, \"\");\n                this.environment = newEnv;\n                this.identifierCache = newIdCache;\n            }\n            finally {\n                this.state = previousState;\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"setParent\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (newParent, subpath) {\n            var parentChanged = newParent !== this.parent;\n            var subpathChanged = subpath !== this.subpath;\n            if (!parentChanged && !subpathChanged) {\n                return;\n            }\n            if (devMode()) {\n                if (!subpath) {\n                    // istanbul ignore next\n                    throw fail$1(\"assertion failed: subpath expected\");\n                }\n                if (!newParent) {\n                    // istanbul ignore next\n                    throw fail$1(\"assertion failed: new parent expected\");\n                }\n                if (this.parent && parentChanged) {\n                    throw fail$1(\"A node cannot exists twice in the state tree. Failed to add \" + this + \" to path '\" + newParent.path + \"/\" + subpath + \"'.\");\n                }\n                if (!this.parent && newParent.root === this) {\n                    throw fail$1(\"A state tree is not allowed to contain itself. Cannot assign \" + this + \" to path '\" + newParent.path + \"/\" + subpath + \"'\");\n                }\n                if (!this.parent &&\n                    !!this.environment &&\n                    this.environment !== newParent.root.environment) {\n                    throw fail$1(\"A state tree cannot be made part of another state tree as long as their environments are different.\");\n                }\n            }\n            if (parentChanged) {\n                // attach to new parent\n                this.environment = undefined; // will use root's\n                newParent.root.identifierCache.mergeCache(this);\n                this.baseSetParent(newParent, subpath);\n                this.fireHook(Hook.afterAttach);\n            }\n            else if (subpathChanged) {\n                // moving to a new subpath on the same parent\n                this.baseSetParent(this.parent, subpath);\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"fireHook\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (name) {\n            var _this = this;\n            this.fireInternalHook(name);\n            var fn = this.storedValue &&\n                typeof this.storedValue === \"object\" &&\n                this.storedValue[name];\n            if (typeof fn === \"function\") {\n                // we check for it to allow old mobx peer dependencies that don't have the method to work (even when still bugged)\n                if (mobx__WEBPACK_IMPORTED_MODULE_0__._allowStateChangesInsideComputed) {\n                    (0,mobx__WEBPACK_IMPORTED_MODULE_0__._allowStateChangesInsideComputed)(function () {\n                        fn.apply(_this.storedValue);\n                    });\n                }\n                else {\n                    fn.apply(this.storedValue);\n                }\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"snapshot\", {\n        // advantage of using computed for a snapshot is that nicely respects transactions etc.\n        get: function () {\n            return this._snapshotComputed.get();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    // NOTE: we use this method to get snapshot without creating @computed overhead\n    Object.defineProperty(ObjectNode.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (!this.isAlive)\n                return this._snapshotUponDeath;\n            return this._observableInstanceState === 2 /* CREATED */\n                ? this._getActualSnapshot()\n                : this._getCachedInitialSnapshot();\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"_getActualSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this.type.getSnapshot(this);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"_getCachedInitialSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (!this._cachedInitialSnapshotCreated) {\n                var type = this.type;\n                var childNodes = this._childNodes;\n                var snapshot = this._initialSnapshot;\n                this._cachedInitialSnapshot = type.processInitialSnapshot(childNodes, snapshot);\n                this._cachedInitialSnapshotCreated = true;\n            }\n            return this._cachedInitialSnapshot;\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"isRunningAction\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (this._isRunningAction)\n                return true;\n            if (this.isRoot)\n                return false;\n            return this.parent.isRunningAction();\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"assertAlive\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (context) {\n            var livelinessChecking = getLivelinessChecking();\n            if (!this.isAlive && livelinessChecking !== \"ignore\") {\n                var error = this._getAssertAliveError(context);\n                switch (livelinessChecking) {\n                    case \"error\":\n                        throw fail$1(error);\n                    case \"warn\":\n                        warnError(error);\n                }\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"_getAssertAliveError\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (context) {\n            var escapedPath = this.getEscapedPath(false) || this.pathUponDeath || \"\";\n            var subpath = (context.subpath && escapeJsonPath(context.subpath)) || \"\";\n            var actionContext = context.actionContext || getCurrentActionContext();\n            // try to use a real action context if possible since it includes the action name\n            if (actionContext && actionContext.type !== \"action\" && actionContext.parentActionEvent) {\n                actionContext = actionContext.parentActionEvent;\n            }\n            var actionFullPath = \"\";\n            if (actionContext && actionContext.name != null) {\n                // try to use the context, and if it not available use the node one\n                var actionPath = (actionContext && actionContext.context && getPath(actionContext.context)) ||\n                    escapedPath;\n                actionFullPath = actionPath + \".\" + actionContext.name + \"()\";\n            }\n            return \"You are trying to read or write to an object that is no longer part of a state tree. (Object type: '\" + this.type.name + \"', Path upon death: '\" + escapedPath + \"', Subpath: '\" + subpath + \"', Action: '\" + actionFullPath + \"'). Either detach nodes first, or don't use objects after removing / replacing them in the tree.\";\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"getChildNode\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (subpath) {\n            this.assertAlive({\n                subpath: subpath\n            });\n            this._autoUnbox = false;\n            try {\n                return this._observableInstanceState === 2 /* CREATED */\n                    ? this.type.getChildNode(this, subpath)\n                    : this._childNodes[subpath];\n            }\n            finally {\n                this._autoUnbox = true;\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"getChildren\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.assertAlive(EMPTY_OBJECT);\n            this._autoUnbox = false;\n            try {\n                return this._observableInstanceState === 2 /* CREATED */\n                    ? this.type.getChildren(this)\n                    : convertChildNodesToArray(this._childNodes);\n            }\n            finally {\n                this._autoUnbox = true;\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"getChildType\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (propertyName) {\n            return this.type.getChildType(propertyName);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"isProtected\", {\n        get: function () {\n            return this.root.isProtectionEnabled;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ObjectNode.prototype, \"assertWritable\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (context) {\n            this.assertAlive(context);\n            if (!this.isRunningAction() && this.isProtected) {\n                throw fail$1(\"Cannot modify '\" + this + \"', the object is protected and can only be modified by using an action.\");\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"removeChild\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (subpath) {\n            this.type.removeChild(this, subpath);\n        }\n    });\n    // bound on the constructor\n    Object.defineProperty(ObjectNode.prototype, \"unbox\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (childNode) {\n            if (!childNode)\n                return childNode;\n            this.assertAlive({\n                subpath: childNode.subpath || childNode.subpathUponDeath\n            });\n            return this._autoUnbox ? childNode.value : childNode;\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"toString\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n            var identifier = this.identifier ? \"(id: \" + this.identifier + \")\" : \"\";\n            return this.type.name + \"@\" + path + identifier + (this.isAlive ? \"\" : \" [dead]\");\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"finalizeCreation\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var _this = this;\n            this.baseFinalizeCreation(function () {\n                var e_2, _a;\n                try {\n                    for (var _b = __values(_this.getChildren()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                        var child = _c.value;\n                        child.finalizeCreation();\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n                _this.fireInternalHook(Hook.afterCreationFinalization);\n            });\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"detach\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (!this.isAlive)\n                throw fail$1(\"Error while detaching, node is not alive.\");\n            this.clearParent();\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"preboot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var self = this;\n            this._applyPatches = createActionInvoker(this.storedValue, \"@APPLY_PATCHES\", function (patches) {\n                patches.forEach(function (patch) {\n                    if (!patch.path) {\n                        self.type.applySnapshot(self, patch.value);\n                        return;\n                    }\n                    var parts = splitJsonPath(patch.path);\n                    var node = resolveNodeByPathParts(self, parts.slice(0, -1));\n                    node.applyPatchLocally(parts[parts.length - 1], patch);\n                });\n            });\n            this._applySnapshot = createActionInvoker(this.storedValue, \"@APPLY_SNAPSHOT\", function (snapshot) {\n                // if the snapshot is the same as the current one, avoid performing a reconcile\n                if (snapshot === self.snapshot)\n                    return;\n                // else, apply it by calling the type logic\n                return self.type.applySnapshot(self, snapshot);\n            });\n            addHiddenFinalProp(this.storedValue, \"$treenode\", this);\n            addHiddenFinalProp(this.storedValue, \"toJSON\", toJSON);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"die\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (!this.isAlive || this.state === NodeLifeCycle.DETACHING)\n                return;\n            this.aboutToDie();\n            this.finalizeDeath();\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"aboutToDie\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (this._observableInstanceState === 0 /* UNINITIALIZED */) {\n                return;\n            }\n            this.getChildren().forEach(function (node) {\n                node.aboutToDie();\n            });\n            // beforeDestroy should run before the disposers since else we could end up in a situation where\n            // a disposer added with addDisposer at this stage (beforeDestroy) is actually never released\n            this.baseAboutToDie();\n            this._internalEventsEmit(\"dispose\" /* Dispose */);\n            this._internalEventsClear(\"dispose\" /* Dispose */);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"finalizeDeath\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            // invariant: not called directly but from \"die\"\n            this.getChildren().forEach(function (node) {\n                node.finalizeDeath();\n            });\n            this.root.identifierCache.notifyDied(this);\n            // \"kill\" the computed prop and just store the last snapshot\n            var snapshot = this.snapshot;\n            this._snapshotUponDeath = snapshot;\n            this._internalEventsClearAll();\n            this.baseFinalizeDeath();\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"onSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (onChange) {\n            this._addSnapshotReaction();\n            return this._internalEventsRegister(\"snapshot\" /* Snapshot */, onChange);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"emitSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (snapshot) {\n            this._internalEventsEmit(\"snapshot\" /* Snapshot */, snapshot);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"onPatch\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (handler) {\n            return this._internalEventsRegister(\"patch\" /* Patch */, handler);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"emitPatch\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (basePatch, source) {\n            if (this._internalEventsHasSubscribers(\"patch\" /* Patch */)) {\n                var localizedPatch = extend({}, basePatch, {\n                    path: source.path.substr(this.path.length) + \"/\" + basePatch.path // calculate the relative path of the patch\n                });\n                var _a = __read(splitPatch(localizedPatch), 2), patch = _a[0], reversePatch = _a[1];\n                this._internalEventsEmit(\"patch\" /* Patch */, patch, reversePatch);\n            }\n            if (this.parent)\n                this.parent.emitPatch(basePatch, source);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"hasDisposer\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (disposer) {\n            return this._internalEventsHas(\"dispose\" /* Dispose */, disposer);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"addDisposer\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (disposer) {\n            if (!this.hasDisposer(disposer)) {\n                this._internalEventsRegister(\"dispose\" /* Dispose */, disposer, true);\n                return;\n            }\n            throw fail$1(\"cannot add a disposer when it is already registered for execution\");\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"removeDisposer\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (disposer) {\n            if (!this._internalEventsHas(\"dispose\" /* Dispose */, disposer)) {\n                throw fail$1(\"cannot remove a disposer which was never registered for execution\");\n            }\n            this._internalEventsUnregister(\"dispose\" /* Dispose */, disposer);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"removeMiddleware\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (middleware) {\n            if (this.middlewares) {\n                var index = this.middlewares.indexOf(middleware);\n                if (index >= 0) {\n                    this.middlewares.splice(index, 1);\n                }\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"addMiddleWare\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (handler, includeHooks) {\n            var _this = this;\n            if (includeHooks === void 0) { includeHooks = true; }\n            var middleware = { handler: handler, includeHooks: includeHooks };\n            if (!this.middlewares)\n                this.middlewares = [middleware];\n            else\n                this.middlewares.push(middleware);\n            return function () {\n                _this.removeMiddleware(middleware);\n            };\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"applyPatchLocally\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (subpath, patch) {\n            this.assertWritable({\n                subpath: subpath\n            });\n            this.createObservableInstanceIfNeeded();\n            this.type.applyPatchLocally(this, subpath, patch);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"_addSnapshotReaction\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var _this = this;\n            if (!this._hasSnapshotReaction) {\n                var snapshotDisposer = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.reaction)(function () { return _this.snapshot; }, function (snapshot) { return _this.emitSnapshot(snapshot); }, snapshotReactionOptions);\n                this.addDisposer(snapshotDisposer);\n                this._hasSnapshotReaction = true;\n            }\n        }\n    });\n    // we proxy the methods to avoid creating an EventHandlers instance when it is not needed\n    Object.defineProperty(ObjectNode.prototype, \"_internalEventsHasSubscribers\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event) {\n            return !!this._internalEvents && this._internalEvents.hasSubscribers(event);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"_internalEventsRegister\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event, eventHandler, atTheBeginning) {\n            if (atTheBeginning === void 0) { atTheBeginning = false; }\n            if (!this._internalEvents) {\n                this._internalEvents = new EventHandlers();\n            }\n            return this._internalEvents.register(event, eventHandler, atTheBeginning);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"_internalEventsHas\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event, eventHandler) {\n            return !!this._internalEvents && this._internalEvents.has(event, eventHandler);\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"_internalEventsUnregister\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event, eventHandler) {\n            if (this._internalEvents) {\n                this._internalEvents.unregister(event, eventHandler);\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"_internalEventsEmit\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event) {\n            var _a;\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            if (this._internalEvents) {\n                (_a = this._internalEvents).emit.apply(_a, __spread([event], args));\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"_internalEventsClear\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event) {\n            if (this._internalEvents) {\n                this._internalEvents.clear(event);\n            }\n        }\n    });\n    Object.defineProperty(ObjectNode.prototype, \"_internalEventsClearAll\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (this._internalEvents) {\n                this._internalEvents.clearAll();\n            }\n        }\n    });\n    return ObjectNode;\n}(BaseNode));\nObjectNode.prototype.createObservableInstance = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.action)(ObjectNode.prototype.createObservableInstance);\nObjectNode.prototype.detach = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.action)(ObjectNode.prototype.detach);\nObjectNode.prototype.die = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.action)(ObjectNode.prototype.die);\n\nvar _a;\n/**\n * @internal\n * @hidden\n */\nvar TypeFlags;\n(function (TypeFlags) {\n    TypeFlags[TypeFlags[\"String\"] = 1] = \"String\";\n    TypeFlags[TypeFlags[\"Number\"] = 2] = \"Number\";\n    TypeFlags[TypeFlags[\"Boolean\"] = 4] = \"Boolean\";\n    TypeFlags[TypeFlags[\"Date\"] = 8] = \"Date\";\n    TypeFlags[TypeFlags[\"Literal\"] = 16] = \"Literal\";\n    TypeFlags[TypeFlags[\"Array\"] = 32] = \"Array\";\n    TypeFlags[TypeFlags[\"Map\"] = 64] = \"Map\";\n    TypeFlags[TypeFlags[\"Object\"] = 128] = \"Object\";\n    TypeFlags[TypeFlags[\"Frozen\"] = 256] = \"Frozen\";\n    TypeFlags[TypeFlags[\"Optional\"] = 512] = \"Optional\";\n    TypeFlags[TypeFlags[\"Reference\"] = 1024] = \"Reference\";\n    TypeFlags[TypeFlags[\"Identifier\"] = 2048] = \"Identifier\";\n    TypeFlags[TypeFlags[\"Late\"] = 4096] = \"Late\";\n    TypeFlags[TypeFlags[\"Refinement\"] = 8192] = \"Refinement\";\n    TypeFlags[TypeFlags[\"Union\"] = 16384] = \"Union\";\n    TypeFlags[TypeFlags[\"Null\"] = 32768] = \"Null\";\n    TypeFlags[TypeFlags[\"Undefined\"] = 65536] = \"Undefined\";\n    TypeFlags[TypeFlags[\"Integer\"] = 131072] = \"Integer\";\n    TypeFlags[TypeFlags[\"Custom\"] = 262144] = \"Custom\";\n    TypeFlags[TypeFlags[\"SnapshotProcessor\"] = 524288] = \"SnapshotProcessor\";\n})(TypeFlags || (TypeFlags = {}));\n/**\n * @internal\n * @hidden\n */\nvar cannotDetermineSubtype = \"cannotDetermine\";\n/** @hidden */\nvar $type = Symbol(\"$type\");\n/**\n * A base type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\nvar BaseType = /** @class */ (function () {\n    function BaseType(name) {\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // these are just to make inner types avaialable to inherited classes\n        Object.defineProperty(this, \"C\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"S\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"T\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"N\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"isType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = name;\n    }\n    Object.defineProperty(BaseType.prototype, \"create\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (snapshot, environment) {\n            typecheckInternal(this, snapshot);\n            return this.instantiate(null, \"\", environment, snapshot).value;\n        }\n    });\n    Object.defineProperty(BaseType.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, applyPostProcess) {\n            // istanbul ignore next\n            throw fail$1(\"unimplemented method\");\n        }\n    });\n    Object.defineProperty(BaseType.prototype, \"isAssignableFrom\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (type) {\n            return type === this;\n        }\n    });\n    Object.defineProperty(BaseType.prototype, \"validate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            var node = getStateTreeNodeSafe(value);\n            if (node) {\n                var valueType = getType(value);\n                return this.isAssignableFrom(valueType)\n                    ? typeCheckSuccess()\n                    : typeCheckFailure(context, value);\n                // it is tempting to compare snapshots, but in that case we should always clone on assignments...\n            }\n            return this.isValidSnapshot(value, context);\n        }\n    });\n    Object.defineProperty(BaseType.prototype, \"is\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (thing) {\n            return this.validate(thing, [{ path: \"\", type: this }]).length === 0;\n        }\n    });\n    Object.defineProperty(BaseType.prototype, \"Type\", {\n        get: function () {\n            // istanbul ignore next\n            throw fail$1(\"Factory.Type should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.Type`\");\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseType.prototype, \"TypeWithoutSTN\", {\n        get: function () {\n            // istanbul ignore next\n            throw fail$1(\"Factory.TypeWithoutSTN should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.TypeWithoutSTN`\");\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseType.prototype, \"SnapshotType\", {\n        get: function () {\n            // istanbul ignore next\n            throw fail$1(\"Factory.SnapshotType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.SnapshotType`\");\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BaseType.prototype, \"CreationType\", {\n        get: function () {\n            // istanbul ignore next\n            throw fail$1(\"Factory.CreationType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.CreationType`\");\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return BaseType;\n}());\n_a = $type;\nBaseType.prototype.create = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.action)(BaseType.prototype.create);\n/**\n * A complex type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\nvar ComplexType = /** @class */ (function (_super) {\n    __extends(ComplexType, _super);\n    function ComplexType(name) {\n        var _this = _super.call(this, name) || this;\n        Object.defineProperty(_this, \"identifierAttribute\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        return _this;\n    }\n    Object.defineProperty(ComplexType.prototype, \"create\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (snapshot, environment) {\n            if (snapshot === void 0) { snapshot = this.getDefaultSnapshot(); }\n            return _super.prototype.create.call(this, snapshot, environment);\n        }\n    });\n    Object.defineProperty(ComplexType.prototype, \"getValue\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            node.createObservableInstanceIfNeeded();\n            return node.storedValue;\n        }\n    });\n    Object.defineProperty(ComplexType.prototype, \"isMatchingSnapshotId\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, snapshot) {\n            return (!current.identifierAttribute ||\n                current.identifier ===\n                    normalizeIdentifier(snapshot[current.identifierAttribute]));\n        }\n    });\n    Object.defineProperty(ComplexType.prototype, \"tryToReconcileNode\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, newValue) {\n            if (current.isDetaching)\n                return false;\n            if (current.snapshot === newValue) {\n                // newValue is the current snapshot of the node, noop\n                return true;\n            }\n            if (isStateTreeNode(newValue) && getStateTreeNode(newValue) === current) {\n                // the current node is the same as the new one\n                return true;\n            }\n            if (current.type === this &&\n                isMutable(newValue) &&\n                !isStateTreeNode(newValue) &&\n                this.isMatchingSnapshotId(current, newValue)) {\n                // the newValue has no node, so can be treated like a snapshot\n                // we can reconcile\n                current.applySnapshot(newValue);\n                return true;\n            }\n            return false;\n        }\n    });\n    Object.defineProperty(ComplexType.prototype, \"reconcile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, newValue, parent, subpath) {\n            var nodeReconciled = this.tryToReconcileNode(current, newValue);\n            if (nodeReconciled) {\n                current.setParent(parent, subpath);\n                return current;\n            }\n            // current node cannot be recycled in any way\n            current.die(); // noop if detaching\n            // attempt to reuse the new one\n            if (isStateTreeNode(newValue) && this.isAssignableFrom(getType(newValue))) {\n                // newValue is a Node as well, move it here..\n                var newNode = getStateTreeNode(newValue);\n                newNode.setParent(parent, subpath);\n                return newNode;\n            }\n            // nothing to do, we have to create a new node\n            return this.instantiate(parent, subpath, undefined, newValue);\n        }\n    });\n    Object.defineProperty(ComplexType.prototype, \"getSubTypes\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return null;\n        }\n    });\n    return ComplexType;\n}(BaseType));\nComplexType.prototype.create = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.action)(ComplexType.prototype.create);\n/**\n * @internal\n * @hidden\n */\nvar SimpleType = /** @class */ (function (_super) {\n    __extends(SimpleType, _super);\n    function SimpleType() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Object.defineProperty(SimpleType.prototype, \"createNewInstance\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (snapshot) {\n            return snapshot;\n        }\n    });\n    Object.defineProperty(SimpleType.prototype, \"getValue\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            // if we ever find a case where scalar nodes can be accessed without iterating through its parent\n            // uncomment this to make sure the parent chain is created when this is accessed\n            // if (node.parent) {\n            //     node.parent.createObservableInstanceIfNeeded()\n            // }\n            return node.storedValue;\n        }\n    });\n    Object.defineProperty(SimpleType.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            return node.storedValue;\n        }\n    });\n    Object.defineProperty(SimpleType.prototype, \"reconcile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, newValue, parent, subpath) {\n            // reconcile only if type and value are still the same, and only if the node is not detaching\n            if (!current.isDetaching && current.type === this && current.storedValue === newValue) {\n                return current;\n            }\n            var res = this.instantiate(parent, subpath, undefined, newValue);\n            current.die(); // noop if detaching\n            return res;\n        }\n    });\n    Object.defineProperty(SimpleType.prototype, \"getSubTypes\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return null;\n        }\n    });\n    return SimpleType;\n}(BaseType));\n/**\n * Returns if a given value represents a type.\n *\n * @param value Value to check.\n * @returns `true` if the value is a type.\n */\nfunction isType(value) {\n    return typeof value === \"object\" && value && value.isType === true;\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsType(type, argNumber) {\n    assertArg(type, isType, \"mobx-state-tree type\", argNumber);\n}\n\nvar runningActions = new Map();\n/**\n * Note: Consider migrating to `createActionTrackingMiddleware2`, it is easier to use.\n *\n * Convenience utility to create action based middleware that supports async processes more easily.\n * All hooks are called for both synchronous and asynchronous actions. Except that either `onSuccess` or `onFail` is called\n *\n * The create middleware tracks the process of an action (assuming it passes the `filter`).\n * `onResume` can return any value, which will be passed as second argument to any other hook. This makes it possible to keep state during a process.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\nfunction createActionTrackingMiddleware(hooks) {\n    return function actionTrackingMiddleware(call, next, abort) {\n        switch (call.type) {\n            case \"action\": {\n                if (!hooks.filter || hooks.filter(call) === true) {\n                    var context = hooks.onStart(call);\n                    hooks.onResume(call, context);\n                    runningActions.set(call.id, {\n                        call: call,\n                        context: context,\n                        async: false\n                    });\n                    try {\n                        var res = next(call);\n                        hooks.onSuspend(call, context);\n                        if (runningActions.get(call.id).async === false) {\n                            runningActions.delete(call.id);\n                            hooks.onSuccess(call, context, res);\n                        }\n                        return res;\n                    }\n                    catch (e) {\n                        runningActions.delete(call.id);\n                        hooks.onFail(call, context, e);\n                        throw e;\n                    }\n                }\n                else {\n                    return next(call);\n                }\n            }\n            case \"flow_spawn\": {\n                var root = runningActions.get(call.rootId);\n                root.async = true;\n                return next(call);\n            }\n            case \"flow_resume\":\n            case \"flow_resume_error\": {\n                var root = runningActions.get(call.rootId);\n                hooks.onResume(call, root.context);\n                try {\n                    return next(call);\n                }\n                finally {\n                    hooks.onSuspend(call, root.context);\n                }\n            }\n            case \"flow_throw\": {\n                var root = runningActions.get(call.rootId);\n                runningActions.delete(call.rootId);\n                hooks.onFail(call, root.context, call.args[0]);\n                return next(call);\n            }\n            case \"flow_return\": {\n                var root = runningActions.get(call.rootId);\n                runningActions.delete(call.rootId);\n                hooks.onSuccess(call, root.context, call.args[0]);\n                return next(call);\n            }\n        }\n    };\n}\n\nvar RunningAction = /** @class */ (function () {\n    function RunningAction(hooks, call) {\n        Object.defineProperty(this, \"hooks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: hooks\n        });\n        Object.defineProperty(this, \"call\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: call\n        });\n        Object.defineProperty(this, \"flowsPending\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"running\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        if (hooks) {\n            hooks.onStart(call);\n        }\n    }\n    Object.defineProperty(RunningAction.prototype, \"finish\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (error) {\n            if (this.running) {\n                this.running = false;\n                if (this.hooks) {\n                    this.hooks.onFinish(this.call, error);\n                }\n            }\n        }\n    });\n    Object.defineProperty(RunningAction.prototype, \"incFlowsPending\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.flowsPending++;\n        }\n    });\n    Object.defineProperty(RunningAction.prototype, \"decFlowsPending\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.flowsPending--;\n        }\n    });\n    Object.defineProperty(RunningAction.prototype, \"hasFlowsPending\", {\n        get: function () {\n            return this.flowsPending > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return RunningAction;\n}());\n/**\n * Convenience utility to create action based middleware that supports async processes more easily.\n * The flow is like this:\n * - for each action: if filter passes -> `onStart` -> (inner actions recursively) -> `onFinish`\n *\n * Example: if we had an action `a` that called inside an action `b1`, then `b2` the flow would be:\n * - `filter(a)`\n * - `onStart(a)`\n *   - `filter(b1)`\n *   - `onStart(b1)`\n *   - `onFinish(b1)`\n *   - `filter(b2)`\n *   - `onStart(b2)`\n *   - `onFinish(b2)`\n * - `onFinish(a)`\n *\n * The flow is the same no matter if the actions are sync or async.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\nfunction createActionTrackingMiddleware2(middlewareHooks) {\n    var runningActions = new WeakMap();\n    return function actionTrackingMiddleware(call, next) {\n        // find parentRunningAction\n        var parentRunningAction = call.parentActionEvent\n            ? runningActions.get(call.parentActionEvent)\n            : undefined;\n        if (call.type === \"action\") {\n            var newCall = __assign(__assign({}, call), { \n                // make a shallow copy of the parent action env\n                env: parentRunningAction && parentRunningAction.call.env, parentCall: parentRunningAction && parentRunningAction.call });\n            var passesFilter = !middlewareHooks.filter || middlewareHooks.filter(newCall);\n            var hooks = passesFilter ? middlewareHooks : undefined;\n            var runningAction = new RunningAction(hooks, newCall);\n            runningActions.set(call, runningAction);\n            var res = void 0;\n            try {\n                res = next(call);\n            }\n            catch (e) {\n                runningAction.finish(e);\n                throw e;\n            }\n            if (!runningAction.hasFlowsPending) {\n                // sync action finished\n                runningAction.finish();\n            }\n            return res;\n        }\n        else {\n            if (!parentRunningAction) {\n                return next(call);\n            }\n            switch (call.type) {\n                case \"flow_spawn\": {\n                    parentRunningAction.incFlowsPending();\n                    return next(call);\n                }\n                case \"flow_resume\":\n                case \"flow_resume_error\": {\n                    return next(call);\n                }\n                case \"flow_throw\": {\n                    var error = call.args[0];\n                    try {\n                        return next(call);\n                    }\n                    finally {\n                        parentRunningAction.decFlowsPending();\n                        if (!parentRunningAction.hasFlowsPending) {\n                            parentRunningAction.finish(error);\n                        }\n                    }\n                }\n                case \"flow_return\": {\n                    try {\n                        return next(call);\n                    }\n                    finally {\n                        parentRunningAction.decFlowsPending();\n                        if (!parentRunningAction.hasFlowsPending) {\n                            parentRunningAction.finish();\n                        }\n                    }\n                }\n            }\n        }\n    };\n}\n\nfunction serializeArgument(node, actionName, index, arg) {\n    if (arg instanceof Date)\n        return { $MST_DATE: arg.getTime() };\n    if (isPrimitive(arg))\n        return arg;\n    // We should not serialize MST nodes, even if we can, because we don't know if the receiving party can handle a raw snapshot instead of an\n    // MST type instance. So if one wants to serialize a MST node that was pass in, either explitly pass: 1: an id, 2: a (relative) path, 3: a snapshot\n    if (isStateTreeNode(arg))\n        return serializeTheUnserializable(\"[MSTNode: \" + getType(arg).name + \"]\");\n    if (typeof arg === \"function\")\n        return serializeTheUnserializable(\"[function]\");\n    if (typeof arg === \"object\" && !isPlainObject(arg) && !isArray(arg))\n        return serializeTheUnserializable(\"[object \" + ((arg && arg.constructor && arg.constructor.name) ||\n            \"Complex Object\") + \"]\");\n    try {\n        // Check if serializable, cycle free etc...\n        // MWE: there must be a better way....\n        JSON.stringify(arg); // or throws\n        return arg;\n    }\n    catch (e) {\n        return serializeTheUnserializable(\"\" + e);\n    }\n}\nfunction deserializeArgument(adm, value) {\n    if (value && typeof value === \"object\" && \"$MST_DATE\" in value)\n        return new Date(value[\"$MST_DATE\"]);\n    return value;\n}\nfunction serializeTheUnserializable(baseType) {\n    return {\n        $MST_UNSERIALIZABLE: true,\n        type: baseType\n    };\n}\n/**\n * Applies an action or a series of actions in a single MobX transaction.\n * Does not return any value\n * Takes an action description as produced by the `onAction` middleware.\n *\n * @param target\n * @param actions\n */\nfunction applyAction(target, actions) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertArg(actions, function (a) { return typeof a === \"object\"; }, \"object or array\", 2);\n    (0,mobx__WEBPACK_IMPORTED_MODULE_0__.runInAction)(function () {\n        asArray(actions).forEach(function (action) { return baseApplyAction(target, action); });\n    });\n}\nfunction baseApplyAction(target, action) {\n    var resolvedTarget = tryResolve(target, action.path || \"\");\n    if (!resolvedTarget)\n        throw fail$1(\"Invalid action path: \" + (action.path || \"\"));\n    var node = getStateTreeNode(resolvedTarget);\n    // Reserved functions\n    if (action.name === \"@APPLY_PATCHES\") {\n        return applyPatch.call(null, resolvedTarget, action.args[0]);\n    }\n    if (action.name === \"@APPLY_SNAPSHOT\") {\n        return applySnapshot.call(null, resolvedTarget, action.args[0]);\n    }\n    if (!(typeof resolvedTarget[action.name] === \"function\"))\n        throw fail$1(\"Action '\" + action.name + \"' does not exist in '\" + node.path + \"'\");\n    return resolvedTarget[action.name].apply(resolvedTarget, action.args ? action.args.map(function (v) { return deserializeArgument(node, v); }) : []);\n}\n/**\n * Small abstraction around `onAction` and `applyAction`, attaches an action listener to a tree and records all the actions emitted.\n * Returns an recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IActionRecorder {\n *      // the recorded actions\n *      actions: ISerializedActionCall[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording actions\n *      stop(): void\n *      // resume recording actions\n *      resume(): void\n *      // apply all the recorded actions on the given object\n *      replay(target: IAnyStateTreeNode): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain actions.\n *\n * @param subject\n * @returns\n */\nfunction recordActions(subject, filter) {\n    // check all arguments\n    assertIsStateTreeNode(subject, 1);\n    var actions = [];\n    var listener = function (call) {\n        var recordThis = filter ? filter(call, getRunningActionContext()) : true;\n        if (recordThis) {\n            actions.push(call);\n        }\n    };\n    var disposer;\n    var recorder = {\n        actions: actions,\n        get recording() {\n            return !!disposer;\n        },\n        stop: function () {\n            if (disposer) {\n                disposer();\n                disposer = undefined;\n            }\n        },\n        resume: function () {\n            if (disposer)\n                return;\n            disposer = onAction(subject, listener);\n        },\n        replay: function (target) {\n            applyAction(target, actions);\n        }\n    };\n    recorder.resume();\n    return recorder;\n}\n/**\n * Registers a function that will be invoked for each action that is called on the provided model instance, or to any of its children.\n * See [actions](https://github.com/mobxjs/mobx-state-tree#actions) for more details. onAction events are emitted only for the outermost called action in the stack.\n * Action can also be intercepted by middleware using addMiddleware to change the function call before it will be run.\n *\n * Not all action arguments might be serializable. For unserializable arguments, a struct like `{ $MST_UNSERIALIZABLE: true, type: \"someType\" }` will be generated.\n * MST Nodes are considered non-serializable as well (they could be serialized as there snapshot, but it is uncertain whether an replaying party will be able to handle such a non-instantiated snapshot).\n * Rather, when using `onAction` middleware, one should consider in passing arguments which are 1: an id, 2: a (relative) path, or 3: a snapshot. Instead of a real MST node.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * }).actions(self => ({\n *   add(todo) {\n *     self.todos.push(todo);\n *   }\n * }))\n *\n * const s = TodoStore.create({ todos: [] })\n *\n * let disposer = onAction(s, (call) => {\n *   console.log(call);\n * })\n *\n * s.add({ task: \"Grab a coffee\" })\n * // Logs: { name: \"add\", path: \"\", args: [{ task: \"Grab a coffee\" }] }\n * ```\n *\n * @param target\n * @param listener\n * @param attachAfter (default false) fires the listener *after* the action has executed instead of before.\n * @returns\n */\nfunction onAction(target, listener, attachAfter) {\n    if (attachAfter === void 0) { attachAfter = false; }\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    if (devMode()) {\n        if (!isRoot(target))\n            warnError(\"Warning: Attaching onAction listeners to non root nodes is dangerous: No events will be emitted for actions initiated higher up in the tree.\");\n        if (!isProtected(target))\n            warnError(\"Warning: Attaching onAction listeners to non protected nodes is dangerous: No events will be emitted for direct modifications without action.\");\n    }\n    return addMiddleware(target, function handler(rawCall, next) {\n        if (rawCall.type === \"action\" && rawCall.id === rawCall.rootId) {\n            var sourceNode_1 = getStateTreeNode(rawCall.context);\n            var info = {\n                name: rawCall.name,\n                path: getRelativePathBetweenNodes(getStateTreeNode(target), sourceNode_1),\n                args: rawCall.args.map(function (arg, index) {\n                    return serializeArgument(sourceNode_1, rawCall.name, index, arg);\n                })\n            };\n            if (attachAfter) {\n                var res = next(rawCall);\n                listener(info);\n                return res;\n            }\n            else {\n                listener(info);\n                return next(rawCall);\n            }\n        }\n        else {\n            return next(rawCall);\n        }\n    });\n}\n\nvar nextActionId = 1;\nvar currentActionContext;\n/**\n * @internal\n * @hidden\n */\nfunction getCurrentActionContext() {\n    return currentActionContext;\n}\n/**\n * @internal\n * @hidden\n */\nfunction getNextActionId() {\n    return nextActionId++;\n}\n// TODO: optimize away entire action context if there is no middleware in tree?\n/**\n * @internal\n * @hidden\n */\nfunction runWithActionContext(context, fn) {\n    var node = getStateTreeNode(context.context);\n    if (context.type === \"action\") {\n        node.assertAlive({\n            actionContext: context\n        });\n    }\n    var baseIsRunningAction = node._isRunningAction;\n    node._isRunningAction = true;\n    var previousContext = currentActionContext;\n    currentActionContext = context;\n    try {\n        return runMiddleWares(node, context, fn);\n    }\n    finally {\n        currentActionContext = previousContext;\n        node._isRunningAction = baseIsRunningAction;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction getParentActionContext(parentContext) {\n    if (!parentContext)\n        return undefined;\n    if (parentContext.type === \"action\")\n        return parentContext;\n    return parentContext.parentActionEvent;\n}\n/**\n * @internal\n * @hidden\n */\nfunction createActionInvoker(target, name, fn) {\n    var res = function () {\n        var id = getNextActionId();\n        var parentContext = currentActionContext;\n        var parentActionContext = getParentActionContext(parentContext);\n        return runWithActionContext({\n            type: \"action\",\n            name: name,\n            id: id,\n            args: argsToArray(arguments),\n            context: target,\n            tree: getRoot(target),\n            rootId: parentContext ? parentContext.rootId : id,\n            parentId: parentContext ? parentContext.id : 0,\n            allParentIds: parentContext\n                ? __spread(parentContext.allParentIds, [parentContext.id]) : [],\n            parentEvent: parentContext,\n            parentActionEvent: parentActionContext\n        }, fn);\n    };\n    res._isMSTAction = true;\n    return res;\n}\n/**\n * Middleware can be used to intercept any action is invoked on the subtree where it is attached.\n * If a tree is protected (by default), this means that any mutation of the tree will pass through your middleware.\n *\n * For more details, see the [middleware docs](concepts/middleware.md)\n *\n * @param target Node to apply the middleware to.\n * @param middleware Middleware to apply.\n * @returns A callable function to dispose the middleware.\n */\nfunction addMiddleware(target, handler, includeHooks) {\n    if (includeHooks === void 0) { includeHooks = true; }\n    var node = getStateTreeNode(target);\n    if (devMode()) {\n        if (!node.isProtectionEnabled) {\n            warnError(\"It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`\");\n        }\n    }\n    return node.addMiddleWare(handler, includeHooks);\n}\n/**\n * Binds middleware to a specific action.\n *\n * Example:\n * ```ts\n * type.actions(self => {\n *   function takeA____() {\n *       self.toilet.donate()\n *       self.wipe()\n *       self.wipe()\n *       self.toilet.flush()\n *   }\n *   return {\n *     takeA____: decorate(atomic, takeA____)\n *   }\n * })\n * ```\n *\n * @param handler\n * @param fn\n * @param includeHooks\n * @returns The original function\n */\nfunction decorate(handler, fn, includeHooks) {\n    if (includeHooks === void 0) { includeHooks = true; }\n    var middleware = { handler: handler, includeHooks: includeHooks };\n    fn.$mst_middleware = fn.$mst_middleware || [];\n    fn.$mst_middleware.push(middleware);\n    return fn;\n}\nvar CollectedMiddlewares = /** @class */ (function () {\n    function CollectedMiddlewares(node, fn) {\n        Object.defineProperty(this, \"arrayIndex\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"inArrayIndex\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"middlewares\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        // we just push middleware arrays into an array of arrays to avoid making copies\n        if (fn.$mst_middleware) {\n            this.middlewares.push(fn.$mst_middleware);\n        }\n        var n = node;\n        // Find all middlewares. Optimization: cache this?\n        while (n) {\n            if (n.middlewares)\n                this.middlewares.push(n.middlewares);\n            n = n.parent;\n        }\n    }\n    Object.defineProperty(CollectedMiddlewares.prototype, \"isEmpty\", {\n        get: function () {\n            return this.middlewares.length <= 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(CollectedMiddlewares.prototype, \"getNextMiddleware\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var array = this.middlewares[this.arrayIndex];\n            if (!array)\n                return undefined;\n            var item = array[this.inArrayIndex++];\n            if (!item) {\n                this.arrayIndex++;\n                this.inArrayIndex = 0;\n                return this.getNextMiddleware();\n            }\n            return item;\n        }\n    });\n    return CollectedMiddlewares;\n}());\nfunction runMiddleWares(node, baseCall, originalFn) {\n    var middlewares = new CollectedMiddlewares(node, originalFn);\n    // Short circuit\n    if (middlewares.isEmpty)\n        return (0,mobx__WEBPACK_IMPORTED_MODULE_0__.action)(originalFn).apply(null, baseCall.args);\n    var result = null;\n    function runNextMiddleware(call) {\n        var middleware = middlewares.getNextMiddleware();\n        var handler = middleware && middleware.handler;\n        if (!handler) {\n            return (0,mobx__WEBPACK_IMPORTED_MODULE_0__.action)(originalFn).apply(null, call.args);\n        }\n        // skip hooks if asked to\n        if (!middleware.includeHooks && Hook[call.name]) {\n            return runNextMiddleware(call);\n        }\n        var nextInvoked = false;\n        function next(call2, callback) {\n            nextInvoked = true;\n            // the result can contain\n            // - the non manipulated return value from an action\n            // - the non manipulated abort value\n            // - one of the above but manipulated through the callback function\n            result = runNextMiddleware(call2);\n            if (callback) {\n                result = callback(result);\n            }\n        }\n        var abortInvoked = false;\n        function abort(value) {\n            abortInvoked = true;\n            // overwrite the result\n            // can be manipulated through middlewares earlier in the queue using the callback fn\n            result = value;\n        }\n        handler(call, next, abort);\n        if (devMode()) {\n            if (!nextInvoked && !abortInvoked) {\n                var node2 = getStateTreeNode(call.tree);\n                throw fail$1(\"Neither the next() nor the abort() callback within the middleware \" + handler.name + \" for the action: \\\"\" + call.name + \"\\\" on the node: \" + node2.type.name + \" was invoked.\");\n            }\n            else if (nextInvoked && abortInvoked) {\n                var node2 = getStateTreeNode(call.tree);\n                throw fail$1(\"The next() and abort() callback within the middleware \" + handler.name + \" for the action: \\\"\" + call.name + \"\\\" on the node: \" + node2.type.name + \" were invoked.\");\n            }\n        }\n        return result;\n    }\n    return runNextMiddleware(baseCall);\n}\n\n/**\n * Returns the currently executing MST action context, or undefined if none.\n */\nfunction getRunningActionContext() {\n    var current = getCurrentActionContext();\n    while (current && current.type !== \"action\") {\n        current = current.parentActionEvent;\n    }\n    return current;\n}\nfunction _isActionContextThisOrChildOf(actionContext, sameOrParent, includeSame) {\n    var parentId = typeof sameOrParent === \"number\" ? sameOrParent : sameOrParent.id;\n    var current = includeSame\n        ? actionContext\n        : actionContext.parentActionEvent;\n    while (current) {\n        if (current.id === parentId) {\n            return true;\n        }\n        current = current.parentActionEvent;\n    }\n    return false;\n}\n/**\n * Returns if the given action context is a parent of this action context.\n */\nfunction isActionContextChildOf(actionContext, parent) {\n    return _isActionContextThisOrChildOf(actionContext, parent, false);\n}\n/**\n * Returns if the given action context is this or a parent of this action context.\n */\nfunction isActionContextThisOrChildOf(actionContext, parentOrThis) {\n    return _isActionContextThisOrChildOf(actionContext, parentOrThis, true);\n}\n\nfunction safeStringify(value) {\n    try {\n        return JSON.stringify(value);\n    }\n    catch (e) {\n        // istanbul ignore next\n        return \"<Unserializable: \" + e + \">\";\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction prettyPrintValue(value) {\n    return typeof value === \"function\"\n        ? \"<function\" + (value.name ? \" \" + value.name : \"\") + \">\"\n        : isStateTreeNode(value)\n            ? \"<\" + value + \">\"\n            : \"`\" + safeStringify(value) + \"`\";\n}\nfunction shortenPrintValue(valueInString) {\n    return valueInString.length < 280\n        ? valueInString\n        : valueInString.substring(0, 272) + \"......\" + valueInString.substring(valueInString.length - 8);\n}\nfunction toErrorString(error) {\n    var value = error.value;\n    var type = error.context[error.context.length - 1].type;\n    var fullPath = error.context\n        .map(function (_a) {\n        var path = _a.path;\n        return path;\n    })\n        .filter(function (path) { return path.length > 0; })\n        .join(\"/\");\n    var pathPrefix = fullPath.length > 0 ? \"at path \\\"/\" + fullPath + \"\\\" \" : \"\";\n    var currentTypename = isStateTreeNode(value)\n        ? \"value of type \" + getStateTreeNode(value).type.name + \":\"\n        : isPrimitive(value)\n            ? \"value\"\n            : \"snapshot\";\n    var isSnapshotCompatible = type && isStateTreeNode(value) && type.is(getStateTreeNode(value).snapshot);\n    return (\"\" + pathPrefix + currentTypename + \" \" + prettyPrintValue(value) + \" is not assignable \" + (type ? \"to type: `\" + type.name + \"`\" : \"\") +\n        (error.message ? \" (\" + error.message + \")\" : \"\") +\n        (type\n            ? isPrimitiveType(type) || isPrimitive(value)\n                ? \".\"\n                : \", expected an instance of `\" + type.name + \"` or a snapshot like `\" + type.describe() + \"` instead.\" +\n                    (isSnapshotCompatible\n                        ? \" (Note that a snapshot of the provided value is compatible with the targeted type)\"\n                        : \"\")\n            : \".\"));\n}\n/**\n * @internal\n * @hidden\n */\nfunction getContextForPath(context, path, type) {\n    return context.concat([{ path: path, type: type }]);\n}\n/**\n * @internal\n * @hidden\n */\nfunction typeCheckSuccess() {\n    return EMPTY_ARRAY;\n}\n/**\n * @internal\n * @hidden\n */\nfunction typeCheckFailure(context, value, message) {\n    return [{ context: context, value: value, message: message }];\n}\n/**\n * @internal\n * @hidden\n */\nfunction flattenTypeErrors(errors) {\n    return errors.reduce(function (a, i) { return a.concat(i); }, []);\n}\n// TODO; doublecheck: typecheck should only needed to be invoked from: type.create and array / map / value.property will change\n/**\n * @internal\n * @hidden\n */\nfunction typecheckInternal(type, value) {\n    // runs typeChecking if it is in dev-mode or through a process.env.ENABLE_TYPE_CHECK flag\n    if (isTypeCheckingEnabled()) {\n        typecheck(type, value);\n    }\n}\n/**\n * Run's the typechecker for the given type on the given value, which can be a snapshot or an instance.\n * Throws if the given value is not according the provided type specification.\n * Use this if you need typechecks even in a production build (by default all automatic runtime type checks will be skipped in production builds)\n *\n * @param type Type to check against.\n * @param value Value to be checked, either a snapshot or an instance.\n */\nfunction typecheck(type, value) {\n    var errors = type.validate(value, [{ path: \"\", type: type }]);\n    if (errors.length > 0) {\n        throw fail$1(validationErrorsToString(type, value, errors));\n    }\n}\nfunction validationErrorsToString(type, value, errors) {\n    if (errors.length === 0) {\n        return undefined;\n    }\n    return (\"Error while converting \" + shortenPrintValue(prettyPrintValue(value)) + \" to `\" + type.name + \"`:\\n\\n    \" + errors.map(toErrorString).join(\"\\n    \"));\n}\n\nvar identifierCacheId = 0;\n/**\n * @internal\n * @hidden\n */\nvar IdentifierCache = /** @class */ (function () {\n    function IdentifierCache() {\n        Object.defineProperty(this, \"cacheId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: identifierCacheId++\n        });\n        // n.b. in cache all identifiers are normalized to strings\n        Object.defineProperty(this, \"cache\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: mobx__WEBPACK_IMPORTED_MODULE_0__.observable.map()\n        });\n        // last time the cache (array) for a given time changed\n        // n.b. it is not really the time, but just an integer that gets increased after each modification to the array\n        Object.defineProperty(this, \"lastCacheModificationPerId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: mobx__WEBPACK_IMPORTED_MODULE_0__.observable.map()\n        });\n    }\n    Object.defineProperty(IdentifierCache.prototype, \"updateLastCacheModificationPerId\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (identifier) {\n            var lcm = this.lastCacheModificationPerId.get(identifier);\n            // we start at 1 since 0 means no update since cache creation\n            this.lastCacheModificationPerId.set(identifier, lcm === undefined ? 1 : lcm + 1);\n        }\n    });\n    Object.defineProperty(IdentifierCache.prototype, \"getLastCacheModificationPerId\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (identifier) {\n            var modificationId = this.lastCacheModificationPerId.get(identifier) || 0;\n            return this.cacheId + \"-\" + modificationId;\n        }\n    });\n    Object.defineProperty(IdentifierCache.prototype, \"addNodeToCache\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, lastCacheUpdate) {\n            if (lastCacheUpdate === void 0) { lastCacheUpdate = true; }\n            if (node.identifierAttribute) {\n                var identifier = node.identifier;\n                if (!this.cache.has(identifier)) {\n                    this.cache.set(identifier, mobx__WEBPACK_IMPORTED_MODULE_0__.observable.array([], mobxShallow));\n                }\n                var set = this.cache.get(identifier);\n                if (set.indexOf(node) !== -1)\n                    throw fail$1(\"Already registered\");\n                set.push(node);\n                if (lastCacheUpdate) {\n                    this.updateLastCacheModificationPerId(identifier);\n                }\n            }\n        }\n    });\n    Object.defineProperty(IdentifierCache.prototype, \"mergeCache\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            var _this = this;\n            (0,mobx__WEBPACK_IMPORTED_MODULE_0__.values)(node.identifierCache.cache).forEach(function (nodes) {\n                return nodes.forEach(function (child) {\n                    _this.addNodeToCache(child);\n                });\n            });\n        }\n    });\n    Object.defineProperty(IdentifierCache.prototype, \"notifyDied\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            if (node.identifierAttribute) {\n                var id = node.identifier;\n                var set = this.cache.get(id);\n                if (set) {\n                    set.remove(node);\n                    // remove empty sets from cache\n                    if (!set.length) {\n                        this.cache.delete(id);\n                    }\n                    this.updateLastCacheModificationPerId(node.identifier);\n                }\n            }\n        }\n    });\n    Object.defineProperty(IdentifierCache.prototype, \"splitCache\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            var _this = this;\n            var res = new IdentifierCache();\n            var basePath = node.path;\n            (0,mobx__WEBPACK_IMPORTED_MODULE_0__.entries)(this.cache).forEach(function (_a) {\n                var _b = __read(_a, 2), id = _b[0], nodes = _b[1];\n                var modified = false;\n                for (var i = nodes.length - 1; i >= 0; i--) {\n                    if (nodes[i].path.indexOf(basePath) === 0) {\n                        res.addNodeToCache(nodes[i], false); // no need to update lastUpdated since it is a whole new cache\n                        nodes.splice(i, 1);\n                        modified = true;\n                    }\n                }\n                if (modified) {\n                    _this.updateLastCacheModificationPerId(id);\n                }\n            });\n            return res;\n        }\n    });\n    Object.defineProperty(IdentifierCache.prototype, \"has\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (type, identifier) {\n            var set = this.cache.get(identifier);\n            if (!set)\n                return false;\n            return set.some(function (candidate) { return type.isAssignableFrom(candidate.type); });\n        }\n    });\n    Object.defineProperty(IdentifierCache.prototype, \"resolve\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (type, identifier) {\n            var set = this.cache.get(identifier);\n            if (!set)\n                return null;\n            var matches = set.filter(function (candidate) { return type.isAssignableFrom(candidate.type); });\n            switch (matches.length) {\n                case 0:\n                    return null;\n                case 1:\n                    return matches[0];\n                default:\n                    throw fail$1(\"Cannot resolve a reference to type '\" + type.name + \"' with id: '\" + identifier + \"' unambigously, there are multiple candidates: \" + matches\n                        .map(function (n) { return n.path; })\n                        .join(\", \"));\n            }\n        }\n    });\n    return IdentifierCache;\n}());\n\n/**\n * @internal\n * @hidden\n */\nfunction createObjectNode(type, parent, subpath, environment, initialValue) {\n    var existingNode = getStateTreeNodeSafe(initialValue);\n    if (existingNode) {\n        if (existingNode.parent) {\n            // istanbul ignore next\n            throw fail$1(\"Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '\" + (parent ? parent.path : \"\") + \"/\" + subpath + \"', but it lives already at '\" + existingNode.path + \"'\");\n        }\n        if (parent) {\n            existingNode.setParent(parent, subpath);\n        }\n        // else it already has no parent since it is a pre-requisite\n        return existingNode;\n    }\n    // not a node, a snapshot\n    return new ObjectNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\nfunction createScalarNode(type, parent, subpath, environment, initialValue) {\n    return new ScalarNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\nfunction isNode(value) {\n    return value instanceof ScalarNode || value instanceof ObjectNode;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar NodeLifeCycle;\n(function (NodeLifeCycle) {\n    NodeLifeCycle[NodeLifeCycle[\"INITIALIZING\"] = 0] = \"INITIALIZING\";\n    NodeLifeCycle[NodeLifeCycle[\"CREATED\"] = 1] = \"CREATED\";\n    NodeLifeCycle[NodeLifeCycle[\"FINALIZED\"] = 2] = \"FINALIZED\";\n    NodeLifeCycle[NodeLifeCycle[\"DETACHING\"] = 3] = \"DETACHING\";\n    NodeLifeCycle[NodeLifeCycle[\"DEAD\"] = 4] = \"DEAD\"; // no coming back from this one\n})(NodeLifeCycle || (NodeLifeCycle = {}));\n/**\n * Returns true if the given value is a node in a state tree.\n * More precisely, that is, if the value is an instance of a\n * `types.model`, `types.array` or `types.map`.\n *\n * @param value\n * @returns true if the value is a state tree node.\n */\nfunction isStateTreeNode(value) {\n    return !!(value && value.$treenode);\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsStateTreeNode(value, argNumber) {\n    assertArg(value, isStateTreeNode, \"mobx-state-tree node\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\nfunction getStateTreeNode(value) {\n    if (!isStateTreeNode(value)) {\n        // istanbul ignore next\n        throw fail$1(\"Value \" + value + \" is no MST Node\");\n    }\n    return value.$treenode;\n}\n/**\n * @internal\n * @hidden\n */\nfunction getStateTreeNodeSafe(value) {\n    return (value && value.$treenode) || null;\n}\n/**\n * @internal\n * @hidden\n */\nfunction toJSON() {\n    return getStateTreeNode(this).snapshot;\n}\nvar doubleDot = function (_) { return \"..\"; };\n/**\n * @internal\n * @hidden\n */\nfunction getRelativePathBetweenNodes(base, target) {\n    // PRE condition target is (a child of) base!\n    if (base.root !== target.root) {\n        throw fail$1(\"Cannot calculate relative path: objects '\" + base + \"' and '\" + target + \"' are not part of the same object tree\");\n    }\n    var baseParts = splitJsonPath(base.path);\n    var targetParts = splitJsonPath(target.path);\n    var common = 0;\n    for (; common < baseParts.length; common++) {\n        if (baseParts[common] !== targetParts[common])\n            break;\n    }\n    // TODO: assert that no targetParts paths are \"..\", \".\" or \"\"!\n    return (baseParts.slice(common).map(doubleDot).join(\"/\") + joinJsonPath(targetParts.slice(common)));\n}\n/**\n * @internal\n * @hidden\n */\nfunction resolveNodeByPath(base, path, failIfResolveFails) {\n    if (failIfResolveFails === void 0) { failIfResolveFails = true; }\n    return resolveNodeByPathParts(base, splitJsonPath(path), failIfResolveFails);\n}\n/**\n * @internal\n * @hidden\n */\nfunction resolveNodeByPathParts(base, pathParts, failIfResolveFails) {\n    if (failIfResolveFails === void 0) { failIfResolveFails = true; }\n    var current = base;\n    for (var i = 0; i < pathParts.length; i++) {\n        var part = pathParts[i];\n        if (part === \"..\") {\n            current = current.parent;\n            if (current)\n                continue; // not everything has a parent\n        }\n        else if (part === \".\") {\n            continue;\n        }\n        else if (current) {\n            if (current instanceof ScalarNode) {\n                // check if the value of a scalar resolves to a state tree node (e.g. references)\n                // then we can continue resolving...\n                try {\n                    var value = current.value;\n                    if (isStateTreeNode(value)) {\n                        current = getStateTreeNode(value);\n                        // fall through\n                    }\n                }\n                catch (e) {\n                    if (!failIfResolveFails) {\n                        return undefined;\n                    }\n                    throw e;\n                }\n            }\n            if (current instanceof ObjectNode) {\n                var subType = current.getChildType(part);\n                if (subType) {\n                    current = current.getChildNode(part);\n                    if (current)\n                        continue;\n                }\n            }\n        }\n        if (failIfResolveFails)\n            throw fail$1(\"Could not resolve '\" + part + \"' in path '\" + (joinJsonPath(pathParts.slice(0, i)) || \"/\") + \"' while resolving '\" + joinJsonPath(pathParts) + \"'\");\n        else\n            return undefined;\n    }\n    return current;\n}\n/**\n * @internal\n * @hidden\n */\nfunction convertChildNodesToArray(childNodes) {\n    if (!childNodes)\n        return EMPTY_ARRAY;\n    var keys = Object.keys(childNodes);\n    if (!keys.length)\n        return EMPTY_ARRAY;\n    var result = new Array(keys.length);\n    keys.forEach(function (key, index) {\n        result[index] = childNodes[key];\n    });\n    return result;\n}\n\n// based on: https://github.com/mobxjs/mobx-utils/blob/master/src/async-action.ts\n/*\n    All contents of this file are deprecated.\n\n    The term `process` has been replaced with `flow` to avoid conflicts with the\n    global `process` object.\n\n    Refer to `flow.ts` for any further changes to this implementation.\n*/\nvar DEPRECATION_MESSAGE = \"See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information. \" +\n    \"Note that the middleware event types starting with `process` now start with `flow`.\";\n/**\n * @hidden\n *\n * @deprecated has been renamed to `flow()`.\n * See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information.\n * Note that the middleware event types starting with `process` now start with `flow`.\n *\n * @returns {Promise}\n */\nfunction process$1(asyncAction) {\n    deprecated(\"process\", \"`process()` has been renamed to `flow()`. \" + DEPRECATION_MESSAGE);\n    return flow(asyncAction);\n}\n\nvar plainObjectString = Object.toString();\n/**\n * @internal\n * @hidden\n */\nvar EMPTY_ARRAY = Object.freeze([]);\n/**\n * @internal\n * @hidden\n */\nvar EMPTY_OBJECT = Object.freeze({});\n/**\n * @internal\n * @hidden\n */\nvar mobxShallow = (0,mobx__WEBPACK_IMPORTED_MODULE_0__._getGlobalState)().useProxies\n    ? { deep: false }\n    : { deep: false, proxy: false };\nObject.freeze(mobxShallow);\n/**\n * @internal\n * @hidden\n */\nfunction fail$1(message) {\n    if (message === void 0) { message = \"Illegal state\"; }\n    return new Error(\"[mobx-state-tree] \" + message);\n}\n/**\n * @internal\n * @hidden\n */\nfunction identity(_) {\n    return _;\n}\n/**\n * pollyfill (for IE) suggested in MDN:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\n * @internal\n * @hidden\n */\nvar isInteger = Number.isInteger ||\n    function (value) {\n        return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n/**\n * @internal\n * @hidden\n */\nfunction isArray(val) {\n    return Array.isArray(val) || (0,mobx__WEBPACK_IMPORTED_MODULE_0__.isObservableArray)(val);\n}\n/**\n * @internal\n * @hidden\n */\nfunction asArray(val) {\n    if (!val)\n        return EMPTY_ARRAY;\n    if (isArray(val))\n        return val;\n    return [val];\n}\n/**\n * @internal\n * @hidden\n */\nfunction extend(a) {\n    var b = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        b[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < b.length; i++) {\n        var current = b[i];\n        for (var key in current)\n            a[key] = current[key];\n    }\n    return a;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isPlainObject(value) {\n    var _a;\n    if (value === null || typeof value !== \"object\")\n        return false;\n    var proto = Object.getPrototypeOf(value);\n    if (proto == null)\n        return true;\n    return ((_a = proto.constructor) === null || _a === void 0 ? void 0 : _a.toString()) === plainObjectString;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isMutable(value) {\n    return (value !== null &&\n        typeof value === \"object\" &&\n        !(value instanceof Date) &&\n        !(value instanceof RegExp));\n}\n/**\n * @internal\n * @hidden\n */\nfunction isPrimitive(value, includeDate) {\n    if (includeDate === void 0) { includeDate = true; }\n    return (value === null ||\n        value === undefined ||\n        typeof value === \"string\" ||\n        typeof value === \"number\" ||\n        typeof value === \"boolean\" ||\n        (includeDate && value instanceof Date));\n}\n/**\n * @internal\n * @hidden\n * Freeze a value and return it (if not in production)\n */\nfunction freeze(value) {\n    if (!devMode())\n        return value;\n    return isPrimitive(value) || (0,mobx__WEBPACK_IMPORTED_MODULE_0__.isObservableArray)(value) ? value : Object.freeze(value);\n}\n/**\n * @internal\n * @hidden\n * Recursively freeze a value (if not in production)\n */\nfunction deepFreeze(value) {\n    if (!devMode())\n        return value;\n    freeze(value);\n    if (isPlainObject(value)) {\n        Object.keys(value).forEach(function (propKey) {\n            if (!isPrimitive(value[propKey]) &&\n                !Object.isFrozen(value[propKey])) {\n                deepFreeze(value[propKey]);\n            }\n        });\n    }\n    return value;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isSerializable(value) {\n    return typeof value !== \"function\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction defineProperty(object, key, descriptor) {\n    (0,mobx__WEBPACK_IMPORTED_MODULE_0__.isObservableObject)(object)\n        ? (0,mobx__WEBPACK_IMPORTED_MODULE_0__.defineProperty)(object, key, descriptor)\n        : Object.defineProperty(object, key, descriptor);\n}\n/**\n * @internal\n * @hidden\n */\nfunction addHiddenFinalProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\n/**\n * @internal\n * @hidden\n */\nfunction addHiddenWritableProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\n/**\n * @internal\n * @hidden\n */\nvar EventHandler = /** @class */ (function () {\n    function EventHandler() {\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    Object.defineProperty(EventHandler.prototype, \"hasSubscribers\", {\n        get: function () {\n            return this.handlers.length > 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventHandler.prototype, \"register\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (fn, atTheBeginning) {\n            var _this = this;\n            if (atTheBeginning === void 0) { atTheBeginning = false; }\n            if (atTheBeginning) {\n                this.handlers.unshift(fn);\n            }\n            else {\n                this.handlers.push(fn);\n            }\n            return function () {\n                _this.unregister(fn);\n            };\n        }\n    });\n    Object.defineProperty(EventHandler.prototype, \"has\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (fn) {\n            return this.handlers.indexOf(fn) >= 0;\n        }\n    });\n    Object.defineProperty(EventHandler.prototype, \"unregister\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (fn) {\n            var index = this.handlers.indexOf(fn);\n            if (index >= 0) {\n                this.handlers.splice(index, 1);\n            }\n        }\n    });\n    Object.defineProperty(EventHandler.prototype, \"clear\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.handlers.length = 0;\n        }\n    });\n    Object.defineProperty(EventHandler.prototype, \"emit\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            // make a copy just in case it changes\n            var handlers = this.handlers.slice();\n            handlers.forEach(function (f) { return f.apply(void 0, __spread(args)); });\n        }\n    });\n    return EventHandler;\n}());\n/**\n * @internal\n * @hidden\n */\nvar EventHandlers = /** @class */ (function () {\n    function EventHandlers() {\n        Object.defineProperty(this, \"eventHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    Object.defineProperty(EventHandlers.prototype, \"hasSubscribers\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event) {\n            var handler = this.eventHandlers && this.eventHandlers[event];\n            return !!handler && handler.hasSubscribers;\n        }\n    });\n    Object.defineProperty(EventHandlers.prototype, \"register\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event, fn, atTheBeginning) {\n            if (atTheBeginning === void 0) { atTheBeginning = false; }\n            if (!this.eventHandlers) {\n                this.eventHandlers = {};\n            }\n            var handler = this.eventHandlers[event];\n            if (!handler) {\n                handler = this.eventHandlers[event] = new EventHandler();\n            }\n            return handler.register(fn, atTheBeginning);\n        }\n    });\n    Object.defineProperty(EventHandlers.prototype, \"has\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event, fn) {\n            var handler = this.eventHandlers && this.eventHandlers[event];\n            return !!handler && handler.has(fn);\n        }\n    });\n    Object.defineProperty(EventHandlers.prototype, \"unregister\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event, fn) {\n            var handler = this.eventHandlers && this.eventHandlers[event];\n            if (handler) {\n                handler.unregister(fn);\n            }\n        }\n    });\n    Object.defineProperty(EventHandlers.prototype, \"clear\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event) {\n            if (this.eventHandlers) {\n                delete this.eventHandlers[event];\n            }\n        }\n    });\n    Object.defineProperty(EventHandlers.prototype, \"clearAll\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            this.eventHandlers = undefined;\n        }\n    });\n    Object.defineProperty(EventHandlers.prototype, \"emit\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (event) {\n            var _a;\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var handler = this.eventHandlers && this.eventHandlers[event];\n            if (handler) {\n                (_a = handler).emit.apply(_a, __spread(args));\n            }\n        }\n    });\n    return EventHandlers;\n}());\n/**\n * @internal\n * @hidden\n */\nfunction argsToArray(args) {\n    var res = new Array(args.length);\n    for (var i = 0; i < args.length; i++)\n        res[i] = args[i];\n    return res;\n}\n/**\n * @internal\n * @hidden\n */\nfunction stringStartsWith(str, beginning) {\n    return str.indexOf(beginning) === 0;\n}\n/**\n * @internal\n * @hidden\n */\nvar deprecated = function (id, message) {\n    // skip if running production\n    if (!devMode())\n        return;\n    // warn if hasn't been warned before\n    if (deprecated.ids && !deprecated.ids.hasOwnProperty(id)) {\n        warnError(\"Deprecation warning: \" + message);\n    }\n    // mark as warned to avoid duplicate warn message\n    if (deprecated.ids)\n        deprecated.ids[id] = true;\n};\ndeprecated.ids = {};\n/**\n * @internal\n * @hidden\n */\nfunction warnError(msg) {\n    console.warn(new Error(\"[mobx-state-tree] \" + msg));\n}\n/**\n * @internal\n * @hidden\n */\nfunction isTypeCheckingEnabled() {\n    return (devMode() ||\n        (typeof process !== \"undefined\" && process.env && process.env.ENABLE_TYPE_CHECK === \"true\"));\n}\n/**\n * @internal\n * @hidden\n */\nfunction devMode() {\n    return \"development\" !== \"production\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertArg(value, fn, typeName, argNumber) {\n    if (devMode()) {\n        if (!fn(value)) {\n            // istanbul ignore next\n            throw fail$1(\"expected \" + typeName + \" as argument \" + asArray(argNumber).join(\" or \") + \", got \" + value + \" instead\");\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsFunction(value, argNumber) {\n    assertArg(value, function (fn) { return typeof fn === \"function\"; }, \"function\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsNumber(value, argNumber, min, max) {\n    assertArg(value, function (n) { return typeof n === \"number\"; }, \"number\", argNumber);\n    if (min !== undefined) {\n        assertArg(value, function (n) { return n >= min; }, \"number greater than \" + min, argNumber);\n    }\n    if (max !== undefined) {\n        assertArg(value, function (n) { return n <= max; }, \"number lesser than \" + max, argNumber);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsString(value, argNumber, canBeEmpty) {\n    if (canBeEmpty === void 0) { canBeEmpty = true; }\n    assertArg(value, function (s) { return typeof s === \"string\"; }, \"string\", argNumber);\n    if (!canBeEmpty) {\n        assertArg(value, function (s) { return s !== \"\"; }, \"not empty string\", argNumber);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction setImmediateWithFallback(fn) {\n    if (typeof queueMicrotask === \"function\") {\n        queueMicrotask(fn);\n    }\n    else if (typeof setImmediate === \"function\") {\n        setImmediate(fn);\n    }\n    else {\n        setTimeout(fn, 1);\n    }\n}\n\n/**\n * See [asynchronous actions](concepts/async-actions.md).\n *\n * @returns The flow as a promise.\n */\nfunction flow(generator) {\n    return createFlowSpawner(generator.name, generator);\n}\n/**\n * @deprecated Not needed since TS3.6.\n * Used for TypeScript to make flows that return a promise return the actual promise result.\n *\n * @param val\n * @returns\n */\nfunction castFlowReturn(val) {\n    return val;\n}\n/**\n * @experimental\n * experimental api - might change on minor/patch releases\n *\n * Convert a promise-returning function to a generator-returning one.\n * This is intended to allow for usage of `yield*` in async actions to\n * retain the promise return type.\n *\n * Example:\n * ```ts\n * function getDataAsync(input: string): Promise<number> { ... }\n * const getDataGen = toGeneratorFunction(getDataAsync);\n *\n * const someModel.actions(self => ({\n *   someAction: flow(function*() {\n *     // value is typed as number\n *     const value = yield* getDataGen(\"input value\");\n *     ...\n *   })\n * }))\n * ```\n */\nfunction toGeneratorFunction(p) {\n    return function () {\n        var _i;\n        var args = [];\n        for (_i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, p.apply(void 0, __spread(args))];\n                case 1: return [2 /*return*/, (_a.sent())];\n            }\n        });\n    };\n}\n/**\n * @experimental\n * experimental api - might change on minor/patch releases\n *\n * Convert a promise to a generator yielding that promise\n * This is intended to allow for usage of `yield*` in async actions to\n * retain the promise return type.\n *\n * Example:\n * ```ts\n * function getDataAsync(input: string): Promise<number> { ... }\n *\n * const someModel.actions(self => ({\n *   someAction: flow(function*() {\n *     // value is typed as number\n *     const value = yield* toGenerator(getDataAsync(\"input value\"));\n *     ...\n *   })\n * }))\n * ```\n */\nfunction toGenerator(p) {\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, p];\n            case 1: return [2 /*return*/, (_a.sent())];\n        }\n    });\n}\n/**\n * @internal\n * @hidden\n */\nfunction createFlowSpawner(name, generator) {\n    var spawner = function flowSpawner() {\n        // Implementation based on https://github.com/tj/co/blob/master/index.js\n        var runId = getNextActionId();\n        var parentContext = getCurrentActionContext();\n        if (!parentContext) {\n            throw fail$1(\"a mst flow must always have a parent context\");\n        }\n        var parentActionContext = getParentActionContext(parentContext);\n        if (!parentActionContext) {\n            throw fail$1(\"a mst flow must always have a parent action context\");\n        }\n        var contextBase = {\n            name: name,\n            id: runId,\n            tree: parentContext.tree,\n            context: parentContext.context,\n            parentId: parentContext.id,\n            allParentIds: __spread(parentContext.allParentIds, [parentContext.id]),\n            rootId: parentContext.rootId,\n            parentEvent: parentContext,\n            parentActionEvent: parentActionContext\n        };\n        var args = arguments;\n        function wrap(fn, type, arg) {\n            fn.$mst_middleware = spawner.$mst_middleware; // pick up any middleware attached to the flow\n            return runWithActionContext(__assign(__assign({}, contextBase), { type: type, args: [arg] }), fn);\n        }\n        return new Promise(function (resolve, reject) {\n            var gen;\n            var init = function asyncActionInit() {\n                gen = generator.apply(null, arguments);\n                onFulfilled(undefined); // kick off the flow\n            };\n            init.$mst_middleware = spawner.$mst_middleware;\n            runWithActionContext(__assign(__assign({}, contextBase), { type: \"flow_spawn\", args: argsToArray(args) }), init);\n            function onFulfilled(res) {\n                var ret;\n                try {\n                    // prettier-ignore\n                    var cancelError = wrap(function (r) { ret = gen.next(r); }, \"flow_resume\", res);\n                    if (cancelError instanceof Error) {\n                        ret = gen.throw(cancelError);\n                    }\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediateWithFallback(function () {\n                        wrap(function (r) { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n                return;\n            }\n            function onRejected(err) {\n                var ret;\n                try {\n                    // prettier-ignore\n                    wrap(function (r) { ret = gen.throw(r); }, \"flow_resume_error\", err); // or yieldError?\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediateWithFallback(function () {\n                        wrap(function (r) { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n            }\n            function next(ret) {\n                if (ret.done) {\n                    // prettier-ignore\n                    setImmediateWithFallback(function () {\n                        wrap(function (r) { resolve(r); }, \"flow_return\", ret.value);\n                    });\n                    return;\n                }\n                // TODO: support more type of values? See https://github.com/tj/co/blob/249bbdc72da24ae44076afd716349d2089b31c4c/index.js#L100\n                if (!ret.value || typeof ret.value.then !== \"function\") {\n                    // istanbul ignore next\n                    throw fail$1(\"Only promises can be yielded to `async`, got: \" + ret);\n                }\n                return ret.value.then(onFulfilled, onRejected);\n            }\n        });\n    };\n    return spawner;\n}\n\n/**\n * @internal\n * @hidden\n */\nfunction splitPatch(patch) {\n    if (!(\"oldValue\" in patch))\n        throw fail$1(\"Patches without `oldValue` field cannot be inversed\");\n    return [stripPatch(patch), invertPatch(patch)];\n}\n/**\n * @internal\n * @hidden\n */\nfunction stripPatch(patch) {\n    // strips `oldvalue` information from the patch, so that it becomes a patch conform the json-patch spec\n    // this removes the ability to undo the patch\n    switch (patch.op) {\n        case \"add\":\n            return { op: \"add\", path: patch.path, value: patch.value };\n        case \"remove\":\n            return { op: \"remove\", path: patch.path };\n        case \"replace\":\n            return { op: \"replace\", path: patch.path, value: patch.value };\n    }\n}\nfunction invertPatch(patch) {\n    switch (patch.op) {\n        case \"add\":\n            return {\n                op: \"remove\",\n                path: patch.path\n            };\n        case \"remove\":\n            return {\n                op: \"add\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n        case \"replace\":\n            return {\n                op: \"replace\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n    }\n}\n/**\n * Simple simple check to check it is a number.\n */\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\n/**\n * Escape slashes and backslashes.\n *\n * http://tools.ietf.org/html/rfc6901\n */\nfunction escapeJsonPath(path) {\n    if (isNumber(path) === true) {\n        return \"\" + path;\n    }\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1)\n        return path;\n    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescape slashes and backslashes.\n */\nfunction unescapeJsonPath(path) {\n    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n/**\n * Generates a json-path compliant json path from path parts.\n *\n * @param path\n * @returns\n */\nfunction joinJsonPath(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    if (path.length === 0)\n        return \"\";\n    var getPathStr = function (p) { return p.map(escapeJsonPath).join(\"/\"); };\n    if (path[0] === \".\" || path[0] === \"..\") {\n        // relative\n        return getPathStr(path);\n    }\n    else {\n        // absolute\n        return \"/\" + getPathStr(path);\n    }\n}\n/**\n * Splits and decodes a json path into several parts.\n *\n * @param path\n * @returns\n */\nfunction splitJsonPath(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    var parts = path.split(\"/\").map(unescapeJsonPath);\n    var valid = path === \"\" ||\n        path === \".\" ||\n        path === \"..\" ||\n        stringStartsWith(path, \"/\") ||\n        stringStartsWith(path, \"./\") ||\n        stringStartsWith(path, \"../\");\n    if (!valid) {\n        throw fail$1(\"a json path must be either rooted, empty or relative, but got '\" + path + \"'\");\n    }\n    // '/a/b/c' -> [\"a\", \"b\", \"c\"]\n    // '../../b/c' -> [\"..\", \"..\", \"b\", \"c\"]\n    // '' -> []\n    // '/' -> ['']\n    // './a' -> [\".\", \"a\"]\n    // /./a' -> [\".\", \"a\"] equivalent to './a'\n    if (parts[0] === \"\") {\n        parts.shift();\n    }\n    return parts;\n}\n\n/** @hidden */\nvar $preProcessorFailed = Symbol(\"$preProcessorFailed\");\nvar SnapshotProcessor = /** @class */ (function (_super) {\n    __extends(SnapshotProcessor, _super);\n    function SnapshotProcessor(_subtype, _processors, name) {\n        var _this = _super.call(this, name || _subtype.name) || this;\n        Object.defineProperty(_this, \"_subtype\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _subtype\n        });\n        Object.defineProperty(_this, \"_processors\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _processors\n        });\n        return _this;\n    }\n    Object.defineProperty(SnapshotProcessor.prototype, \"flags\", {\n        get: function () {\n            return this._subtype.flags | TypeFlags.SnapshotProcessor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return \"snapshotProcessor(\" + this._subtype.describe() + \")\";\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"preProcessSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (sn) {\n            if (this._processors.preProcessor) {\n                return this._processors.preProcessor.call(null, sn);\n            }\n            return sn;\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"preProcessSnapshotSafe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (sn) {\n            try {\n                return this.preProcessSnapshot(sn);\n            }\n            catch (e) {\n                return $preProcessorFailed;\n            }\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"postProcessSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (sn) {\n            if (this._processors.postProcessor) {\n                return this._processors.postProcessor.call(null, sn);\n            }\n            return sn;\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"_fixNode\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            var _this = this;\n            // the node has to use these methods rather than the original type ones\n            proxyNodeTypeMethods(node.type, this, \"create\");\n            var oldGetSnapshot = node.getSnapshot;\n            node.getSnapshot = function () {\n                return _this.postProcessSnapshot(oldGetSnapshot.call(node));\n            };\n            if (!isUnionType(this._subtype)) {\n                node.getReconciliationType = function () {\n                    return _this;\n                };\n            }\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            var processedInitialValue = isStateTreeNode(initialValue)\n                ? initialValue\n                : this.preProcessSnapshot(initialValue);\n            var node = this._subtype.instantiate(parent, subpath, environment, processedInitialValue);\n            this._fixNode(node);\n            return node;\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"reconcile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, newValue, parent, subpath) {\n            var node = this._subtype.reconcile(current, isStateTreeNode(newValue) ? newValue : this.preProcessSnapshot(newValue), parent, subpath);\n            if (node !== current) {\n                this._fixNode(node);\n            }\n            return node;\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, applyPostProcess) {\n            if (applyPostProcess === void 0) { applyPostProcess = true; }\n            var sn = this._subtype.getSnapshot(node);\n            return applyPostProcess ? this.postProcessSnapshot(sn) : sn;\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            var processedSn = this.preProcessSnapshotSafe(value);\n            if (processedSn === $preProcessorFailed) {\n                return typeCheckFailure(context, value, \"Failed to preprocess value\");\n            }\n            return this._subtype.validate(processedSn, context);\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"getSubTypes\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this._subtype;\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"is\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (thing) {\n            var value = isType(thing)\n                ? this._subtype\n                : isStateTreeNode(thing)\n                    ? getSnapshot(thing, false)\n                    : this.preProcessSnapshotSafe(thing);\n            if (value === $preProcessorFailed) {\n                return false;\n            }\n            return this._subtype.validate(value, [{ path: \"\", type: this._subtype }]).length === 0;\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"isAssignableFrom\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (type) {\n            return this._subtype.isAssignableFrom(type);\n        }\n    });\n    Object.defineProperty(SnapshotProcessor.prototype, \"isMatchingSnapshotId\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, snapshot) {\n            if (!(this._subtype instanceof ComplexType)) {\n                return false;\n            }\n            var processedSn = this.preProcessSnapshot(snapshot);\n            return this._subtype.isMatchingSnapshotId(current, processedSn);\n        }\n    });\n    return SnapshotProcessor;\n}(BaseType));\nfunction proxyNodeTypeMethods(nodeType, snapshotProcessorType) {\n    var e_1, _a;\n    var methods = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        methods[_i - 2] = arguments[_i];\n    }\n    try {\n        for (var methods_1 = __values(methods), methods_1_1 = methods_1.next(); !methods_1_1.done; methods_1_1 = methods_1.next()) {\n            var method = methods_1_1.value;\n            nodeType[method] = snapshotProcessorType[method].bind(snapshotProcessorType);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (methods_1_1 && !methods_1_1.done && (_a = methods_1.return)) _a.call(methods_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n}\n/**\n * `types.snapshotProcessor` - Runs a pre/post snapshot processor before/after serializing a given type.\n *\n * Example:\n * ```ts\n * const Todo1 = types.model({ text: types.string })\n * // in the backend the text type must be null when empty\n * interface BackendTodo {\n *     text: string | null\n * }\n * const Todo2 = types.snapshotProcessor(Todo1, {\n *     // from snapshot to instance\n *     preProcessor(sn: BackendTodo) {\n *         return {\n *             text: sn.text || \"\";\n *         }\n *     },\n *     // from instance to snapshot\n *     postProcessor(sn): BackendTodo {\n *         return {\n *             text: !sn.text ? null : sn.text\n *         }\n *     }\n * })\n * ```\n *\n * @param type Type to run the processors over.\n * @param processors Processors to run.\n * @param name Type name, or undefined to inherit the inner type one.\n * @returns\n */\nfunction snapshotProcessor(type, processors, name) {\n    assertIsType(type, 1);\n    if (devMode()) {\n        if (processors.postProcessor && typeof processors.postProcessor !== \"function\") {\n            // istanbul ignore next\n            throw fail(\"postSnapshotProcessor must be a function\");\n        }\n        if (processors.preProcessor && typeof processors.preProcessor !== \"function\") {\n            // istanbul ignore next\n            throw fail(\"preSnapshotProcessor must be a function\");\n        }\n    }\n    return new SnapshotProcessor(type, processors, name);\n}\n\nvar needsIdentifierError = \"Map.put can only be used to store complex values that have an identifier type attribute\";\nfunction tryCollectModelTypes(type, modelTypes) {\n    var e_1, _a;\n    var subtypes = type.getSubTypes();\n    if (subtypes === cannotDetermineSubtype) {\n        return false;\n    }\n    if (subtypes) {\n        var subtypesArray = asArray(subtypes);\n        try {\n            for (var subtypesArray_1 = __values(subtypesArray), subtypesArray_1_1 = subtypesArray_1.next(); !subtypesArray_1_1.done; subtypesArray_1_1 = subtypesArray_1.next()) {\n                var subtype = subtypesArray_1_1.value;\n                if (!tryCollectModelTypes(subtype, modelTypes))\n                    return false;\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (subtypesArray_1_1 && !subtypesArray_1_1.done && (_a = subtypesArray_1.return)) _a.call(subtypesArray_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    }\n    if (type instanceof ModelType) {\n        modelTypes.push(type);\n    }\n    return true;\n}\n/**\n * @internal\n * @hidden\n */\nvar MapIdentifierMode;\n(function (MapIdentifierMode) {\n    MapIdentifierMode[MapIdentifierMode[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    MapIdentifierMode[MapIdentifierMode[\"YES\"] = 1] = \"YES\";\n    MapIdentifierMode[MapIdentifierMode[\"NO\"] = 2] = \"NO\";\n})(MapIdentifierMode || (MapIdentifierMode = {}));\nvar MSTMap = /** @class */ (function (_super) {\n    __extends(MSTMap, _super);\n    function MSTMap(initialData) {\n        return _super.call(this, initialData, mobx__WEBPACK_IMPORTED_MODULE_0__.observable.ref.enhancer) || this;\n    }\n    Object.defineProperty(MSTMap.prototype, \"get\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (key) {\n            // maybe this is over-enthousiastic? normalize numeric keys to strings\n            return _super.prototype.get.call(this, \"\" + key);\n        }\n    });\n    Object.defineProperty(MSTMap.prototype, \"has\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (key) {\n            return _super.prototype.has.call(this, \"\" + key);\n        }\n    });\n    Object.defineProperty(MSTMap.prototype, \"delete\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (key) {\n            return _super.prototype.delete.call(this, \"\" + key);\n        }\n    });\n    Object.defineProperty(MSTMap.prototype, \"set\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (key, value) {\n            return _super.prototype.set.call(this, \"\" + key, value);\n        }\n    });\n    Object.defineProperty(MSTMap.prototype, \"put\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value) {\n            if (!value)\n                throw fail$1(\"Map.put cannot be used to set empty values\");\n            if (isStateTreeNode(value)) {\n                var node = getStateTreeNode(value);\n                if (devMode()) {\n                    if (!node.identifierAttribute) {\n                        throw fail$1(needsIdentifierError);\n                    }\n                }\n                if (node.identifier === null) {\n                    throw fail$1(needsIdentifierError);\n                }\n                this.set(node.identifier, value);\n                return value;\n            }\n            else if (!isMutable(value)) {\n                throw fail$1(\"Map.put can only be used to store complex values\");\n            }\n            else {\n                var mapNode = getStateTreeNode(this);\n                var mapType = mapNode.type;\n                if (mapType.identifierMode !== MapIdentifierMode.YES) {\n                    throw fail$1(needsIdentifierError);\n                }\n                var idAttr = mapType.mapIdentifierAttribute;\n                var id = value[idAttr];\n                if (!isValidIdentifier(id)) {\n                    // try again but this time after creating a node for the value\n                    // since it might be an optional identifier\n                    var newNode = this.put(mapType.getChildType().create(value, mapNode.environment));\n                    return this.put(getSnapshot(newNode));\n                }\n                var key = normalizeIdentifier(id);\n                this.set(key, value);\n                return this.get(key);\n            }\n        }\n    });\n    return MSTMap;\n}(mobx__WEBPACK_IMPORTED_MODULE_0__.ObservableMap));\n/**\n * @internal\n * @hidden\n */\nvar MapType = /** @class */ (function (_super) {\n    __extends(MapType, _super);\n    function MapType(name, _subType, hookInitializers) {\n        if (hookInitializers === void 0) { hookInitializers = []; }\n        var _this = _super.call(this, name) || this;\n        Object.defineProperty(_this, \"_subType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _subType\n        });\n        Object.defineProperty(_this, \"identifierMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: MapIdentifierMode.UNKNOWN\n        });\n        Object.defineProperty(_this, \"mapIdentifierAttribute\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: undefined\n        });\n        Object.defineProperty(_this, \"flags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: TypeFlags.Map\n        });\n        Object.defineProperty(_this, \"hookInitializers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        _this._determineIdentifierMode();\n        _this.hookInitializers = hookInitializers;\n        return _this;\n    }\n    Object.defineProperty(MapType.prototype, \"hooks\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (hooks) {\n            var hookInitializers = this.hookInitializers.length > 0 ? this.hookInitializers.concat(hooks) : [hooks];\n            return new MapType(this.name, this._subType, hookInitializers);\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            this._determineIdentifierMode();\n            return createObjectNode(this, parent, subpath, environment, initialValue);\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"_determineIdentifierMode\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            if (this.identifierMode !== MapIdentifierMode.UNKNOWN) {\n                return;\n            }\n            var modelTypes = [];\n            if (tryCollectModelTypes(this._subType, modelTypes)) {\n                var identifierAttribute = modelTypes.reduce(function (current, type) {\n                    if (!type.identifierAttribute)\n                        return current;\n                    if (current && current !== type.identifierAttribute) {\n                        throw fail$1(\"The objects in a map should all have the same identifier attribute, expected '\" + current + \"', but child of type '\" + type.name + \"' declared attribute '\" + type.identifierAttribute + \"' as identifier\");\n                    }\n                    return type.identifierAttribute;\n                }, undefined);\n                if (identifierAttribute) {\n                    this.identifierMode = MapIdentifierMode.YES;\n                    this.mapIdentifierAttribute = identifierAttribute;\n                }\n                else {\n                    this.identifierMode = MapIdentifierMode.NO;\n                }\n            }\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"initializeChildNodes\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (objNode, initialSnapshot) {\n            if (initialSnapshot === void 0) { initialSnapshot = {}; }\n            var subType = objNode.type._subType;\n            var result = {};\n            Object.keys(initialSnapshot).forEach(function (name) {\n                result[name] = subType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n            });\n            return result;\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"createNewInstance\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (childNodes) {\n            return new MSTMap(childNodes);\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"finalizeNewInstance\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, instance) {\n            (0,mobx__WEBPACK_IMPORTED_MODULE_0__._interceptReads)(instance, node.unbox);\n            var type = node.type;\n            type.hookInitializers.forEach(function (initializer) {\n                var hooks = initializer(instance);\n                Object.keys(hooks).forEach(function (name) {\n                    var hook = hooks[name];\n                    var actionInvoker = createActionInvoker(instance, name, hook);\n                    (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n                });\n            });\n            (0,mobx__WEBPACK_IMPORTED_MODULE_0__.intercept)(instance, this.willChange);\n            (0,mobx__WEBPACK_IMPORTED_MODULE_0__.observe)(instance, this.didChange);\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return \"Map<string, \" + this._subType.describe() + \">\";\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"getChildren\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            // return (node.storedValue as ObservableMap<any>).values()\n            return (0,mobx__WEBPACK_IMPORTED_MODULE_0__.values)(node.storedValue);\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"getChildNode\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, key) {\n            var childNode = node.storedValue.get(\"\" + key);\n            if (!childNode)\n                throw fail$1(\"Not a child \" + key);\n            return childNode;\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"willChange\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (change) {\n            var node = getStateTreeNode(change.object);\n            var key = change.name;\n            node.assertWritable({ subpath: key });\n            var mapType = node.type;\n            var subType = mapType._subType;\n            switch (change.type) {\n                case \"update\":\n                    {\n                        var newValue = change.newValue;\n                        var oldValue = change.object.get(key);\n                        if (newValue === oldValue)\n                            return null;\n                        typecheckInternal(subType, newValue);\n                        change.newValue = subType.reconcile(node.getChildNode(key), change.newValue, node, key);\n                        mapType.processIdentifier(key, change.newValue);\n                    }\n                    break;\n                case \"add\":\n                    {\n                        typecheckInternal(subType, change.newValue);\n                        change.newValue = subType.instantiate(node, key, undefined, change.newValue);\n                        mapType.processIdentifier(key, change.newValue);\n                    }\n                    break;\n            }\n            return change;\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"processIdentifier\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (expected, node) {\n            if (this.identifierMode === MapIdentifierMode.YES && node instanceof ObjectNode) {\n                var identifier = node.identifier;\n                if (identifier !== expected)\n                    throw fail$1(\"A map of objects containing an identifier should always store the object under their own identifier. Trying to store key '\" + identifier + \"', but expected: '\" + expected + \"'\");\n            }\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            var res = {};\n            node.getChildren().forEach(function (childNode) {\n                res[childNode.subpath] = childNode.snapshot;\n            });\n            return res;\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"processInitialSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (childNodes) {\n            var processed = {};\n            Object.keys(childNodes).forEach(function (key) {\n                processed[key] = childNodes[key].getSnapshot();\n            });\n            return processed;\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"didChange\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (change) {\n            var node = getStateTreeNode(change.object);\n            switch (change.type) {\n                case \"update\":\n                    return void node.emitPatch({\n                        op: \"replace\",\n                        path: escapeJsonPath(change.name),\n                        value: change.newValue.snapshot,\n                        oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                    }, node);\n                case \"add\":\n                    return void node.emitPatch({\n                        op: \"add\",\n                        path: escapeJsonPath(change.name),\n                        value: change.newValue.snapshot,\n                        oldValue: undefined\n                    }, node);\n                case \"delete\":\n                    // a node got deleted, get the old snapshot and make the node die\n                    var oldSnapshot = change.oldValue.snapshot;\n                    change.oldValue.die();\n                    // emit the patch\n                    return void node.emitPatch({\n                        op: \"remove\",\n                        path: escapeJsonPath(change.name),\n                        oldValue: oldSnapshot\n                    }, node);\n            }\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"applyPatchLocally\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, subpath, patch) {\n            var target = node.storedValue;\n            switch (patch.op) {\n                case \"add\":\n                case \"replace\":\n                    target.set(subpath, patch.value);\n                    break;\n                case \"remove\":\n                    target.delete(subpath);\n                    break;\n            }\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"applySnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, snapshot) {\n            typecheckInternal(this, snapshot);\n            var target = node.storedValue;\n            var currentKeys = {};\n            Array.from(target.keys()).forEach(function (key) {\n                currentKeys[key] = false;\n            });\n            if (snapshot) {\n                // Don't use target.replace, as it will throw away all existing items first\n                for (var key in snapshot) {\n                    target.set(key, snapshot[key]);\n                    currentKeys[\"\" + key] = true;\n                }\n            }\n            Object.keys(currentKeys).forEach(function (key) {\n                if (currentKeys[key] === false)\n                    target.delete(key);\n            });\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"getChildType\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this._subType;\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            var _this = this;\n            if (!isPlainObject(value)) {\n                return typeCheckFailure(context, value, \"Value is not a plain object\");\n            }\n            return flattenTypeErrors(Object.keys(value).map(function (path) {\n                return _this._subType.validate(value[path], getContextForPath(context, path, _this._subType));\n            }));\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"getDefaultSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return EMPTY_OBJECT;\n        }\n    });\n    Object.defineProperty(MapType.prototype, \"removeChild\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, subpath) {\n            node.storedValue.delete(subpath);\n        }\n    });\n    return MapType;\n}(ComplexType));\nMapType.prototype.applySnapshot = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.action)(MapType.prototype.applySnapshot);\n/**\n * `types.map` - Creates a key based collection type who's children are all of a uniform declared type.\n * If the type stored in a map has an identifier, it is mandatory to store the child under that identifier in the map.\n *\n * This type will always produce [observable maps](https://mobx.js.org/api.html#observablemap)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   id: types.identifier,\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.map(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: {} })\n * unprotect(s)\n * s.todos.set(17, { task: \"Grab coffee\", id: 17 })\n * s.todos.put({ task: \"Grab cookie\", id: 18 }) // put will infer key from the identifier\n * console.log(s.todos.get(17).task) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\nfunction map(subtype) {\n    return new MapType(\"map<string, \" + subtype.name + \">\", subtype);\n}\n/**\n * Returns if a given value represents a map type.\n *\n * @param type\n * @returns `true` if it is a map type.\n */\nfunction isMapType(type) {\n    return isType(type) && (type.flags & TypeFlags.Map) > 0;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar ArrayType = /** @class */ (function (_super) {\n    __extends(ArrayType, _super);\n    function ArrayType(name, _subType, hookInitializers) {\n        if (hookInitializers === void 0) { hookInitializers = []; }\n        var _this = _super.call(this, name) || this;\n        Object.defineProperty(_this, \"_subType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _subType\n        });\n        Object.defineProperty(_this, \"flags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: TypeFlags.Array\n        });\n        Object.defineProperty(_this, \"hookInitializers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        _this.hookInitializers = hookInitializers;\n        return _this;\n    }\n    Object.defineProperty(ArrayType.prototype, \"hooks\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (hooks) {\n            var hookInitializers = this.hookInitializers.length > 0 ? this.hookInitializers.concat(hooks) : [hooks];\n            return new ArrayType(this.name, this._subType, hookInitializers);\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            return createObjectNode(this, parent, subpath, environment, initialValue);\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"initializeChildNodes\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (objNode, snapshot) {\n            if (snapshot === void 0) { snapshot = []; }\n            var subType = objNode.type._subType;\n            var result = {};\n            snapshot.forEach(function (item, index) {\n                var subpath = \"\" + index;\n                result[subpath] = subType.instantiate(objNode, subpath, undefined, item);\n            });\n            return result;\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"createNewInstance\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (childNodes) {\n            return mobx__WEBPACK_IMPORTED_MODULE_0__.observable.array(convertChildNodesToArray(childNodes), mobxShallow);\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"finalizeNewInstance\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, instance) {\n            (0,mobx__WEBPACK_IMPORTED_MODULE_0__._getAdministration)(instance).dehancer = node.unbox;\n            var type = node.type;\n            type.hookInitializers.forEach(function (initializer) {\n                var hooks = initializer(instance);\n                Object.keys(hooks).forEach(function (name) {\n                    var hook = hooks[name];\n                    var actionInvoker = createActionInvoker(instance, name, hook);\n                    (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n                });\n            });\n            (0,mobx__WEBPACK_IMPORTED_MODULE_0__.intercept)(instance, this.willChange);\n            (0,mobx__WEBPACK_IMPORTED_MODULE_0__.observe)(instance, this.didChange);\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this._subType.describe() + \"[]\";\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"getChildren\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            return node.storedValue.slice();\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"getChildNode\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, key) {\n            var index = Number(key);\n            if (index < node.storedValue.length)\n                return node.storedValue[index];\n            throw fail$1(\"Not a child: \" + key);\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"willChange\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (change) {\n            var node = getStateTreeNode(change.object);\n            node.assertWritable({ subpath: \"\" + change.index });\n            var subType = node.type._subType;\n            var childNodes = node.getChildren();\n            switch (change.type) {\n                case \"update\":\n                    {\n                        if (change.newValue === change.object[change.index])\n                            return null;\n                        var updatedNodes = reconcileArrayChildren(node, subType, [childNodes[change.index]], [change.newValue], [change.index]);\n                        if (!updatedNodes) {\n                            return null;\n                        }\n                        change.newValue = updatedNodes[0];\n                    }\n                    break;\n                case \"splice\":\n                    {\n                        var index_1 = change.index, removedCount = change.removedCount, added = change.added;\n                        var addedNodes = reconcileArrayChildren(node, subType, childNodes.slice(index_1, index_1 + removedCount), added, added.map(function (_, i) { return index_1 + i; }));\n                        if (!addedNodes) {\n                            return null;\n                        }\n                        change.added = addedNodes;\n                        // update paths of remaining items\n                        for (var i = index_1 + removedCount; i < childNodes.length; i++) {\n                            childNodes[i].setParent(node, \"\" + (i + added.length - removedCount));\n                        }\n                    }\n                    break;\n            }\n            return change;\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            return node.getChildren().map(function (childNode) { return childNode.snapshot; });\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"processInitialSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (childNodes) {\n            var processed = [];\n            Object.keys(childNodes).forEach(function (key) {\n                processed.push(childNodes[key].getSnapshot());\n            });\n            return processed;\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"didChange\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (change) {\n            var node = getStateTreeNode(change.object);\n            switch (change.type) {\n                case \"update\":\n                    return void node.emitPatch({\n                        op: \"replace\",\n                        path: \"\" + change.index,\n                        value: change.newValue.snapshot,\n                        oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                    }, node);\n                case \"splice\":\n                    for (var i = change.removedCount - 1; i >= 0; i--)\n                        node.emitPatch({\n                            op: \"remove\",\n                            path: \"\" + (change.index + i),\n                            oldValue: change.removed[i].snapshot\n                        }, node);\n                    for (var i = 0; i < change.addedCount; i++)\n                        node.emitPatch({\n                            op: \"add\",\n                            path: \"\" + (change.index + i),\n                            value: node.getChildNode(\"\" + (change.index + i)).snapshot,\n                            oldValue: undefined\n                        }, node);\n                    return;\n            }\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"applyPatchLocally\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, subpath, patch) {\n            var target = node.storedValue;\n            var index = subpath === \"-\" ? target.length : Number(subpath);\n            switch (patch.op) {\n                case \"replace\":\n                    target[index] = patch.value;\n                    break;\n                case \"add\":\n                    target.splice(index, 0, patch.value);\n                    break;\n                case \"remove\":\n                    target.splice(index, 1);\n                    break;\n            }\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"applySnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, snapshot) {\n            typecheckInternal(this, snapshot);\n            var target = node.storedValue;\n            target.replace(snapshot);\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"getChildType\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this._subType;\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            var _this = this;\n            if (!isArray(value)) {\n                return typeCheckFailure(context, value, \"Value is not an array\");\n            }\n            return flattenTypeErrors(value.map(function (item, index) {\n                return _this._subType.validate(item, getContextForPath(context, \"\" + index, _this._subType));\n            }));\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"getDefaultSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return EMPTY_ARRAY;\n        }\n    });\n    Object.defineProperty(ArrayType.prototype, \"removeChild\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, subpath) {\n            node.storedValue.splice(Number(subpath), 1);\n        }\n    });\n    return ArrayType;\n}(ComplexType));\nArrayType.prototype.applySnapshot = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.action)(ArrayType.prototype.applySnapshot);\n/**\n * `types.array` - Creates an index based collection type who's children are all of a uniform declared type.\n *\n * This type will always produce [observable arrays](https://mobx.js.org/api.html#observablearray)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: [] })\n * unprotect(s) // needed to allow modifying outside of an action\n * s.todos.push({ task: \"Grab coffee\" })\n * console.log(s.todos[0]) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\nfunction array(subtype) {\n    assertIsType(subtype, 1);\n    return new ArrayType(subtype.name + \"[]\", subtype);\n}\nfunction reconcileArrayChildren(parent, childType, oldNodes, newValues, newPaths) {\n    var nothingChanged = true;\n    for (var i = 0;; i++) {\n        var hasNewNode = i <= newValues.length - 1;\n        var oldNode = oldNodes[i];\n        var newValue = hasNewNode ? newValues[i] : undefined;\n        var newPath = \"\" + newPaths[i];\n        // for some reason, instead of newValue we got a node, fallback to the storedValue\n        // TODO: https://github.com/mobxjs/mobx-state-tree/issues/340#issuecomment-325581681\n        if (isNode(newValue))\n            newValue = newValue.storedValue;\n        if (!oldNode && !hasNewNode) {\n            // both are empty, end\n            break;\n        }\n        else if (!hasNewNode) {\n            // new one does not exists\n            nothingChanged = false;\n            oldNodes.splice(i, 1);\n            if (oldNode instanceof ObjectNode) {\n                // since it is going to be returned by pop/splice/shift better create it before killing it\n                // so it doesn't end up in an undead state\n                oldNode.createObservableInstanceIfNeeded();\n            }\n            oldNode.die();\n            i--;\n        }\n        else if (!oldNode) {\n            // there is no old node, create it\n            // check if already belongs to the same parent. if so, avoid pushing item in. only swapping can occur.\n            if (isStateTreeNode(newValue) && getStateTreeNode(newValue).parent === parent) {\n                // this node is owned by this parent, but not in the reconcilable set, so it must be double\n                throw fail$1(\"Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '\" + parent.path + \"/\" + newPath + \"', but it lives already at '\" + getStateTreeNode(newValue).path + \"'\");\n            }\n            nothingChanged = false;\n            var newNode = valueAsNode(childType, parent, newPath, newValue);\n            oldNodes.splice(i, 0, newNode);\n        }\n        else if (areSame(oldNode, newValue)) {\n            // both are the same, reconcile\n            oldNodes[i] = valueAsNode(childType, parent, newPath, newValue, oldNode);\n        }\n        else {\n            // nothing to do, try to reorder\n            var oldMatch = undefined;\n            // find a possible candidate to reuse\n            for (var j = i; j < oldNodes.length; j++) {\n                if (areSame(oldNodes[j], newValue)) {\n                    oldMatch = oldNodes.splice(j, 1)[0];\n                    break;\n                }\n            }\n            nothingChanged = false;\n            var newNode = valueAsNode(childType, parent, newPath, newValue, oldMatch);\n            oldNodes.splice(i, 0, newNode);\n        }\n    }\n    return nothingChanged ? null : oldNodes;\n}\n/**\n * Convert a value to a node at given parent and subpath. Attempts to reuse old node if possible and given.\n */\nfunction valueAsNode(childType, parent, subpath, newValue, oldNode) {\n    // ensure the value is valid-ish\n    typecheckInternal(childType, newValue);\n    function getNewNode() {\n        // the new value has a MST node\n        if (isStateTreeNode(newValue)) {\n            var childNode = getStateTreeNode(newValue);\n            childNode.assertAlive(EMPTY_OBJECT);\n            // the node lives here\n            if (childNode.parent !== null && childNode.parent === parent) {\n                childNode.setParent(parent, subpath);\n                return childNode;\n            }\n        }\n        // there is old node and new one is a value/snapshot\n        if (oldNode) {\n            return childType.reconcile(oldNode, newValue, parent, subpath);\n        }\n        // nothing to do, create from scratch\n        return childType.instantiate(parent, subpath, undefined, newValue);\n    }\n    var newNode = getNewNode();\n    if (oldNode && oldNode !== newNode) {\n        if (oldNode instanceof ObjectNode) {\n            // since it is going to be returned by pop/splice/shift better create it before killing it\n            // so it doesn't end up in an undead state\n            oldNode.createObservableInstanceIfNeeded();\n        }\n        oldNode.die();\n    }\n    return newNode;\n}\n/**\n * Check if a node holds a value.\n */\nfunction areSame(oldNode, newValue) {\n    // never consider dead old nodes for reconciliation\n    if (!oldNode.isAlive) {\n        return false;\n    }\n    // the new value has the same node\n    if (isStateTreeNode(newValue)) {\n        var newNode = getStateTreeNode(newValue);\n        return newNode.isAlive && newNode === oldNode;\n    }\n    // the provided value is the snapshot of the old node\n    if (oldNode.snapshot === newValue) {\n        return true;\n    }\n    // Non object nodes don't get reconciled\n    if (!(oldNode instanceof ObjectNode)) {\n        return false;\n    }\n    var oldNodeType = oldNode.getReconciliationType();\n    // new value is a snapshot with the correct identifier\n    return (oldNode.identifier !== null &&\n        oldNode.identifierAttribute &&\n        isPlainObject(newValue) &&\n        oldNodeType.is(newValue) &&\n        oldNodeType.isMatchingSnapshotId(oldNode, newValue));\n}\n/**\n * Returns if a given value represents an array type.\n *\n * @param type\n * @returns `true` if the type is an array type.\n */\nfunction isArrayType(type) {\n    return isType(type) && (type.flags & TypeFlags.Array) > 0;\n}\n\nvar PRE_PROCESS_SNAPSHOT = \"preProcessSnapshot\";\nvar POST_PROCESS_SNAPSHOT = \"postProcessSnapshot\";\nfunction objectTypeToString() {\n    return getStateTreeNode(this).toString();\n}\nvar defaultObjectOptions = {\n    name: \"AnonymousModel\",\n    properties: {},\n    initializers: EMPTY_ARRAY\n};\nfunction toPropertiesObject(declaredProps) {\n    // loop through properties and ensures that all items are types\n    return Object.keys(declaredProps).reduce(function (props, key) {\n        var _a, _b, _c;\n        // warn if user intended a HOOK\n        if (key in Hook)\n            throw fail$1(\"Hook '\" + key + \"' was defined as property. Hooks should be defined as part of the actions\");\n        // the user intended to use a view\n        var descriptor = Object.getOwnPropertyDescriptor(props, key);\n        if (\"get\" in descriptor) {\n            throw fail$1(\"Getters are not supported as properties. Please use views instead\");\n        }\n        // undefined and null are not valid\n        var value = descriptor.value;\n        if (value === null || value === undefined) {\n            throw fail$1(\"The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?\");\n            // its a primitive, convert to its type\n        }\n        else if (isPrimitive(value)) {\n            return Object.assign({}, props, (_a = {},\n                _a[key] = optional(getPrimitiveFactoryFromValue(value), value),\n                _a));\n            // map defaults to empty object automatically for models\n        }\n        else if (value instanceof MapType) {\n            return Object.assign({}, props, (_b = {},\n                _b[key] = optional(value, {}),\n                _b));\n        }\n        else if (value instanceof ArrayType) {\n            return Object.assign({}, props, (_c = {}, _c[key] = optional(value, []), _c));\n            // its already a type\n        }\n        else if (isType(value)) {\n            return props;\n            // its a function, maybe the user wanted a view?\n        }\n        else if (devMode() && typeof value === \"function\") {\n            throw fail$1(\"Invalid type definition for property '\" + key + \"', it looks like you passed a function. Did you forget to invoke it, or did you intend to declare a view / action?\");\n            // no other complex values\n        }\n        else if (devMode() && typeof value === \"object\") {\n            throw fail$1(\"Invalid type definition for property '\" + key + \"', it looks like you passed an object. Try passing another model type or a types.frozen.\");\n            // WTF did you pass in mate?\n        }\n        else {\n            throw fail$1(\"Invalid type definition for property '\" + key + \"', cannot infer a type from a value like '\" + value + \"' (\" + typeof value + \")\");\n        }\n    }, declaredProps);\n}\n/**\n * @internal\n * @hidden\n */\nvar ModelType = /** @class */ (function (_super) {\n    __extends(ModelType, _super);\n    function ModelType(opts) {\n        var _this = _super.call(this, opts.name || defaultObjectOptions.name) || this;\n        Object.defineProperty(_this, \"flags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: TypeFlags.Object\n        });\n        /*\n         * The original object definition\n         */\n        Object.defineProperty(_this, \"initializers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"properties\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"preProcessor\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"postProcessor\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"propertyNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"named\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: function (name) {\n                return _this.cloneAndEnhance({ name: name });\n            }\n        });\n        Object.defineProperty(_this, \"props\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: function (properties) {\n                return _this.cloneAndEnhance({ properties: properties });\n            }\n        });\n        Object.defineProperty(_this, \"preProcessSnapshot\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: function (preProcessor) {\n                var currentPreprocessor = _this.preProcessor;\n                if (!currentPreprocessor)\n                    return _this.cloneAndEnhance({ preProcessor: preProcessor });\n                else\n                    return _this.cloneAndEnhance({\n                        preProcessor: function (snapshot) { return currentPreprocessor(preProcessor(snapshot)); }\n                    });\n            }\n        });\n        Object.defineProperty(_this, \"postProcessSnapshot\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: function (postProcessor) {\n                var currentPostprocessor = _this.postProcessor;\n                if (!currentPostprocessor)\n                    return _this.cloneAndEnhance({ postProcessor: postProcessor });\n                else\n                    return _this.cloneAndEnhance({\n                        postProcessor: function (snapshot) { return postProcessor(currentPostprocessor(snapshot)); }\n                    });\n            }\n        });\n        Object.assign(_this, defaultObjectOptions, opts);\n        // ensures that any default value gets converted to its related type\n        _this.properties = toPropertiesObject(_this.properties);\n        freeze(_this.properties); // make sure nobody messes with it\n        _this.propertyNames = Object.keys(_this.properties);\n        _this.identifierAttribute = _this._getIdentifierAttribute();\n        return _this;\n    }\n    Object.defineProperty(ModelType.prototype, \"_getIdentifierAttribute\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var identifierAttribute = undefined;\n            this.forAllProps(function (propName, propType) {\n                if (propType.flags & TypeFlags.Identifier) {\n                    if (identifierAttribute)\n                        throw fail$1(\"Cannot define property '\" + propName + \"' as object identifier, property '\" + identifierAttribute + \"' is already defined as identifier property\");\n                    identifierAttribute = propName;\n                }\n            });\n            return identifierAttribute;\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"cloneAndEnhance\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (opts) {\n            return new ModelType({\n                name: opts.name || this.name,\n                properties: Object.assign({}, this.properties, opts.properties),\n                initializers: this.initializers.concat(opts.initializers || []),\n                preProcessor: opts.preProcessor || this.preProcessor,\n                postProcessor: opts.postProcessor || this.postProcessor\n            });\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"actions\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (fn) {\n            var _this = this;\n            var actionInitializer = function (self) {\n                _this.instantiateActions(self, fn(self));\n                return self;\n            };\n            return this.cloneAndEnhance({ initializers: [actionInitializer] });\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"instantiateActions\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (self, actions) {\n            // check if return is correct\n            if (!isPlainObject(actions))\n                throw fail$1(\"actions initializer should return a plain object containing actions\");\n            // bind actions to the object created\n            Object.keys(actions).forEach(function (name) {\n                // warn if preprocessor was given\n                if (name === PRE_PROCESS_SNAPSHOT)\n                    throw fail$1(\"Cannot define action '\" + PRE_PROCESS_SNAPSHOT + \"', it should be defined using 'type.preProcessSnapshot(fn)' instead\");\n                // warn if postprocessor was given\n                if (name === POST_PROCESS_SNAPSHOT)\n                    throw fail$1(\"Cannot define action '\" + POST_PROCESS_SNAPSHOT + \"', it should be defined using 'type.postProcessSnapshot(fn)' instead\");\n                var action2 = actions[name];\n                // apply hook composition\n                var baseAction = self[name];\n                if (name in Hook && baseAction) {\n                    var specializedAction_1 = action2;\n                    action2 = function () {\n                        baseAction.apply(null, arguments);\n                        specializedAction_1.apply(null, arguments);\n                    };\n                }\n                // the goal of this is to make sure actions using \"this\" can call themselves,\n                // while still allowing the middlewares to register them\n                var middlewares = action2.$mst_middleware; // make sure middlewares are not lost\n                var boundAction = action2.bind(actions);\n                boundAction.$mst_middleware = middlewares;\n                var actionInvoker = createActionInvoker(self, name, boundAction);\n                actions[name] = actionInvoker;\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, name, actionInvoker);\n            });\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"volatile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (fn) {\n            var _this = this;\n            if (typeof fn !== \"function\") {\n                throw fail$1(\"You passed an \" + typeof fn + \" to volatile state as an argument, when function is expected\");\n            }\n            var stateInitializer = function (self) {\n                _this.instantiateVolatileState(self, fn(self));\n                return self;\n            };\n            return this.cloneAndEnhance({ initializers: [stateInitializer] });\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"instantiateVolatileState\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (self, state) {\n            // check views return\n            if (!isPlainObject(state))\n                throw fail$1(\"volatile state initializer should return a plain object containing state\");\n            (0,mobx__WEBPACK_IMPORTED_MODULE_0__.set)(self, state);\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"extend\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (fn) {\n            var _this = this;\n            var initializer = function (self) {\n                var _a = fn(self), actions = _a.actions, views = _a.views, state = _a.state, rest = __rest(_a, [\"actions\", \"views\", \"state\"]);\n                for (var key in rest)\n                    throw fail$1(\"The `extend` function should return an object with a subset of the fields 'actions', 'views' and 'state'. Found invalid key '\" + key + \"'\");\n                if (state)\n                    _this.instantiateVolatileState(self, state);\n                if (views)\n                    _this.instantiateViews(self, views);\n                if (actions)\n                    _this.instantiateActions(self, actions);\n                return self;\n            };\n            return this.cloneAndEnhance({ initializers: [initializer] });\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"views\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (fn) {\n            var _this = this;\n            var viewInitializer = function (self) {\n                _this.instantiateViews(self, fn(self));\n                return self;\n            };\n            return this.cloneAndEnhance({ initializers: [viewInitializer] });\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"instantiateViews\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (self, views) {\n            // check views return\n            if (!isPlainObject(views))\n                throw fail$1(\"views initializer should return a plain object containing views\");\n            Object.getOwnPropertyNames(views).forEach(function (key) {\n                var _a;\n                // is this a computed property?\n                var descriptor = Object.getOwnPropertyDescriptor(views, key);\n                if (\"get\" in descriptor) {\n                    (0,mobx__WEBPACK_IMPORTED_MODULE_0__.defineProperty)(self, key, descriptor);\n                    (0,mobx__WEBPACK_IMPORTED_MODULE_0__.makeObservable)(self, (_a = {}, _a[key] = mobx__WEBPACK_IMPORTED_MODULE_0__.computed, _a));\n                }\n                else if (typeof descriptor.value === \"function\") {\n                    (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, key, descriptor.value);\n                }\n                else {\n                    throw fail$1(\"A view member should either be a function or getter based property\");\n                }\n            });\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            var value = isStateTreeNode(initialValue)\n                ? initialValue\n                : this.applySnapshotPreProcessor(initialValue);\n            return createObjectNode(this, parent, subpath, environment, value);\n            // Optimization: record all prop- view- and action names after first construction, and generate an optimal base class\n            // that pre-reserves all these fields for fast object-member lookups\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"initializeChildNodes\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (objNode, initialSnapshot) {\n            if (initialSnapshot === void 0) { initialSnapshot = {}; }\n            var type = objNode.type;\n            var result = {};\n            type.forAllProps(function (name, childType) {\n                result[name] = childType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n            });\n            return result;\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"createNewInstance\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (childNodes) {\n            return mobx__WEBPACK_IMPORTED_MODULE_0__.observable.object(childNodes, EMPTY_OBJECT, mobxShallow);\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"finalizeNewInstance\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, instance) {\n            addHiddenFinalProp(instance, \"toString\", objectTypeToString);\n            this.forAllProps(function (name) {\n                (0,mobx__WEBPACK_IMPORTED_MODULE_0__._interceptReads)(instance, name, node.unbox);\n            });\n            this.initializers.reduce(function (self, fn) { return fn(self); }, instance);\n            (0,mobx__WEBPACK_IMPORTED_MODULE_0__.intercept)(instance, this.willChange);\n            (0,mobx__WEBPACK_IMPORTED_MODULE_0__.observe)(instance, this.didChange);\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"willChange\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (chg) {\n            // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n            var change = chg;\n            var node = getStateTreeNode(change.object);\n            var subpath = change.name;\n            node.assertWritable({ subpath: subpath });\n            var childType = node.type.properties[subpath];\n            // only properties are typed, state are stored as-is references\n            if (childType) {\n                typecheckInternal(childType, change.newValue);\n                change.newValue = childType.reconcile(node.getChildNode(subpath), change.newValue, node, subpath);\n            }\n            return change;\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"didChange\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (chg) {\n            // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n            var change = chg;\n            var childNode = getStateTreeNode(change.object);\n            var childType = childNode.type.properties[change.name];\n            if (!childType) {\n                // don't emit patches for volatile state\n                return;\n            }\n            var oldChildValue = change.oldValue ? change.oldValue.snapshot : undefined;\n            childNode.emitPatch({\n                op: \"replace\",\n                path: escapeJsonPath(change.name),\n                value: change.newValue.snapshot,\n                oldValue: oldChildValue\n            }, childNode);\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"getChildren\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            var _this = this;\n            var res = [];\n            this.forAllProps(function (name) {\n                res.push(_this.getChildNode(node, name));\n            });\n            return res;\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"getChildNode\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, key) {\n            if (!(key in this.properties))\n                throw fail$1(\"Not a value property: \" + key);\n            var adm = (0,mobx__WEBPACK_IMPORTED_MODULE_0__._getAdministration)(node.storedValue, key);\n            var childNode = adm.raw();\n            if (!childNode)\n                throw fail$1(\"Node not available for property \" + key);\n            return childNode;\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, applyPostProcess) {\n            var _this = this;\n            if (applyPostProcess === void 0) { applyPostProcess = true; }\n            var res = {};\n            this.forAllProps(function (name, type) {\n                (0,mobx__WEBPACK_IMPORTED_MODULE_0__.getAtom)(node.storedValue, name).reportObserved();\n                res[name] = _this.getChildNode(node, name).snapshot;\n            });\n            if (applyPostProcess) {\n                return this.applySnapshotPostProcessor(res);\n            }\n            return res;\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"processInitialSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (childNodes) {\n            var processed = {};\n            Object.keys(childNodes).forEach(function (key) {\n                processed[key] = childNodes[key].getSnapshot();\n            });\n            return this.applySnapshotPostProcessor(processed);\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"applyPatchLocally\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, subpath, patch) {\n            if (!(patch.op === \"replace\" || patch.op === \"add\")) {\n                throw fail$1(\"object does not support operation \" + patch.op);\n            }\n            node.storedValue[subpath] = patch.value;\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"applySnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, snapshot) {\n            typecheckInternal(this, snapshot);\n            var preProcessedSnapshot = this.applySnapshotPreProcessor(snapshot);\n            this.forAllProps(function (name) {\n                node.storedValue[name] = preProcessedSnapshot[name];\n            });\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"applySnapshotPreProcessor\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (snapshot) {\n            var processor = this.preProcessor;\n            return processor ? processor.call(null, snapshot) : snapshot;\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"applySnapshotPostProcessor\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (snapshot) {\n            var postProcessor = this.postProcessor;\n            if (postProcessor)\n                return postProcessor.call(null, snapshot);\n            return snapshot;\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"getChildType\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (propertyName) {\n            assertIsString(propertyName, 1);\n            return this.properties[propertyName];\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            var _this = this;\n            var snapshot = this.applySnapshotPreProcessor(value);\n            if (!isPlainObject(snapshot)) {\n                return typeCheckFailure(context, snapshot, \"Value is not a plain object\");\n            }\n            return flattenTypeErrors(this.propertyNames.map(function (key) {\n                return _this.properties[key].validate(snapshot[key], getContextForPath(context, key, _this.properties[key]));\n            }));\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"forAllProps\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (fn) {\n            var _this = this;\n            this.propertyNames.forEach(function (key) { return fn(key, _this.properties[key]); });\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var _this = this;\n            // optimization: cache\n            return (\"{ \" +\n                this.propertyNames\n                    .map(function (key) { return key + \": \" + _this.properties[key].describe(); })\n                    .join(\"; \") +\n                \" }\");\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"getDefaultSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return EMPTY_OBJECT;\n        }\n    });\n    Object.defineProperty(ModelType.prototype, \"removeChild\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node, subpath) {\n            node.storedValue[subpath] = undefined;\n        }\n    });\n    return ModelType;\n}(ComplexType));\nModelType.prototype.applySnapshot = (0,mobx__WEBPACK_IMPORTED_MODULE_0__.action)(ModelType.prototype.applySnapshot);\n/**\n * `types.model` - Creates a new model type by providing a name, properties, volatile state and actions.\n *\n * See the [model type](/concepts/trees#creating-models) description or the [getting started](intro/getting-started.md#getting-started-1) tutorial.\n */\nfunction model() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var name = typeof args[0] === \"string\" ? args.shift() : \"AnonymousModel\";\n    var properties = args.shift() || {};\n    return new ModelType({ name: name, properties: properties });\n}\n/**\n * `types.compose` - Composes a new model from one or more existing model types.\n * This method can be invoked in two forms:\n * Given 2 or more model types, the types are composed into a new Type.\n * Given first parameter as a string and 2 or more model types,\n * the types are composed into a new Type with the given name\n */\nfunction compose() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    // TODO: just join the base type names if no name is provided\n    var hasTypename = typeof args[0] === \"string\";\n    var typeName = hasTypename ? args[0] : \"AnonymousModel\";\n    if (hasTypename) {\n        args.shift();\n    }\n    // check all parameters\n    if (devMode()) {\n        args.forEach(function (type, i) {\n            assertArg(type, isModelType, \"mobx-state-tree model type\", hasTypename ? i + 2 : i + 1);\n        });\n    }\n    return args\n        .reduce(function (prev, cur) {\n        return prev.cloneAndEnhance({\n            name: prev.name + \"_\" + cur.name,\n            properties: cur.properties,\n            initializers: cur.initializers,\n            preProcessor: function (snapshot) {\n                return cur.applySnapshotPreProcessor(prev.applySnapshotPreProcessor(snapshot));\n            },\n            postProcessor: function (snapshot) {\n                return cur.applySnapshotPostProcessor(prev.applySnapshotPostProcessor(snapshot));\n            }\n        });\n    })\n        .named(typeName);\n}\n/**\n * Returns if a given value represents a model type.\n *\n * @param type\n * @returns\n */\nfunction isModelType(type) {\n    return isType(type) && (type.flags & TypeFlags.Object) > 0;\n}\n\n// TODO: implement CoreType using types.custom ?\n/**\n * @internal\n * @hidden\n */\nvar CoreType = /** @class */ (function (_super) {\n    __extends(CoreType, _super);\n    function CoreType(name, flags, checker, initializer) {\n        if (initializer === void 0) { initializer = identity; }\n        var _this = _super.call(this, name) || this;\n        Object.defineProperty(_this, \"flags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: flags\n        });\n        Object.defineProperty(_this, \"checker\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: checker\n        });\n        Object.defineProperty(_this, \"initializer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: initializer\n        });\n        _this.flags = flags;\n        return _this;\n    }\n    Object.defineProperty(CoreType.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this.name;\n        }\n    });\n    Object.defineProperty(CoreType.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            return createScalarNode(this, parent, subpath, environment, initialValue);\n        }\n    });\n    Object.defineProperty(CoreType.prototype, \"createNewInstance\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (snapshot) {\n            return this.initializer(snapshot);\n        }\n    });\n    Object.defineProperty(CoreType.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            if (isPrimitive(value) && this.checker(value)) {\n                return typeCheckSuccess();\n            }\n            var typeName = this.name === \"Date\" ? \"Date or a unix milliseconds timestamp\" : this.name;\n            return typeCheckFailure(context, value, \"Value is not a \" + typeName);\n        }\n    });\n    return CoreType;\n}(SimpleType));\n/**\n * `types.string` - Creates a type that can only contain a string value.\n * This type is used for string values by default\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *   firstName: types.string,\n *   lastName: \"Doe\"\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nvar string = new CoreType(\"string\", TypeFlags.String, function (v) { return typeof v === \"string\"; });\n/**\n * `types.number` - Creates a type that can only contain a numeric value.\n * This type is used for numeric values by default\n *\n * Example:\n * ```ts\n * const Vector = types.model({\n *   x: types.number,\n *   y: 1.5\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nvar number = new CoreType(\"number\", TypeFlags.Number, function (v) { return typeof v === \"number\"; });\n/**\n * `types.integer` - Creates a type that can only contain an integer value.\n * This type is used for integer values by default\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.integer,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nvar integer = new CoreType(\"integer\", TypeFlags.Integer, function (v) { return isInteger(v); });\n/**\n * `types.boolean` - Creates a type that can only contain a boolean value.\n * This type is used for boolean values by default\n *\n * Example:\n * ```ts\n * const Thing = types.model({\n *   isCool: types.boolean,\n *   isAwesome: false\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nvar boolean = new CoreType(\"boolean\", TypeFlags.Boolean, function (v) { return typeof v === \"boolean\"; });\n/**\n * `types.null` - The type of the value `null`\n */\nvar nullType = new CoreType(\"null\", TypeFlags.Null, function (v) { return v === null; });\n/**\n * `types.undefined` - The type of the value `undefined`\n */\nvar undefinedType = new CoreType(\"undefined\", TypeFlags.Undefined, function (v) { return v === undefined; });\nvar _DatePrimitive = new CoreType(\"Date\", TypeFlags.Date, function (v) { return typeof v === \"number\" || v instanceof Date; }, function (v) { return (v instanceof Date ? v : new Date(v)); });\n_DatePrimitive.getSnapshot = function (node) {\n    return node.storedValue.getTime();\n};\n/**\n * `types.Date` - Creates a type that can only contain a javascript Date value.\n *\n * Example:\n * ```ts\n * const LogLine = types.model({\n *   timestamp: types.Date,\n * })\n *\n * LogLine.create({ timestamp: new Date() })\n * ```\n */\nvar DatePrimitive = _DatePrimitive;\n/**\n * @internal\n * @hidden\n */\nfunction getPrimitiveFactoryFromValue(value) {\n    switch (typeof value) {\n        case \"string\":\n            return string;\n        case \"number\":\n            return number; // In the future, isInteger(value) ? integer : number would be interesting, but would be too breaking for now\n        case \"boolean\":\n            return boolean;\n        case \"object\":\n            if (value instanceof Date)\n                return DatePrimitive;\n    }\n    throw fail$1(\"Cannot determine primitive type from value \" + value);\n}\n/**\n * Returns if a given value represents a primitive type.\n *\n * @param type\n * @returns\n */\nfunction isPrimitiveType(type) {\n    return (isType(type) &&\n        (type.flags &\n            (TypeFlags.String |\n                TypeFlags.Number |\n                TypeFlags.Integer |\n                TypeFlags.Boolean |\n                TypeFlags.Date)) >\n            0);\n}\n\n/**\n * @internal\n * @hidden\n */\nvar Literal = /** @class */ (function (_super) {\n    __extends(Literal, _super);\n    function Literal(value) {\n        var _this = _super.call(this, JSON.stringify(value)) || this;\n        Object.defineProperty(_this, \"value\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"flags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: TypeFlags.Literal\n        });\n        _this.value = value;\n        return _this;\n    }\n    Object.defineProperty(Literal.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            return createScalarNode(this, parent, subpath, environment, initialValue);\n        }\n    });\n    Object.defineProperty(Literal.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return JSON.stringify(this.value);\n        }\n    });\n    Object.defineProperty(Literal.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            if (isPrimitive(value) && value === this.value) {\n                return typeCheckSuccess();\n            }\n            return typeCheckFailure(context, value, \"Value is not a literal \" + JSON.stringify(this.value));\n        }\n    });\n    return Literal;\n}(SimpleType));\n/**\n * `types.literal` - The literal type will return a type that will match only the exact given type.\n * The given value must be a primitive, in order to be serialized to a snapshot correctly.\n * You can use literal to match exact strings for example the exact male or female string.\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *     name: types.string,\n *     gender: types.union(types.literal('male'), types.literal('female'))\n * })\n * ```\n *\n * @param value The value to use in the strict equal check\n * @returns\n */\nfunction literal(value) {\n    // check that the given value is a primitive\n    assertArg(value, isPrimitive, \"primitive\", 1);\n    return new Literal(value);\n}\n/**\n * Returns if a given value represents a literal type.\n *\n * @param type\n * @returns\n */\nfunction isLiteralType(type) {\n    return isType(type) && (type.flags & TypeFlags.Literal) > 0;\n}\n\nvar Refinement = /** @class */ (function (_super) {\n    __extends(Refinement, _super);\n    function Refinement(name, _subtype, _predicate, _message) {\n        var _this = _super.call(this, name) || this;\n        Object.defineProperty(_this, \"_subtype\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _subtype\n        });\n        Object.defineProperty(_this, \"_predicate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _predicate\n        });\n        Object.defineProperty(_this, \"_message\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _message\n        });\n        return _this;\n    }\n    Object.defineProperty(Refinement.prototype, \"flags\", {\n        get: function () {\n            return this._subtype.flags | TypeFlags.Refinement;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Refinement.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this.name;\n        }\n    });\n    Object.defineProperty(Refinement.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            // create the child type\n            return this._subtype.instantiate(parent, subpath, environment, initialValue);\n        }\n    });\n    Object.defineProperty(Refinement.prototype, \"isAssignableFrom\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (type) {\n            return this._subtype.isAssignableFrom(type);\n        }\n    });\n    Object.defineProperty(Refinement.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            var subtypeErrors = this._subtype.validate(value, context);\n            if (subtypeErrors.length > 0)\n                return subtypeErrors;\n            var snapshot = isStateTreeNode(value) ? getStateTreeNode(value).snapshot : value;\n            if (!this._predicate(snapshot)) {\n                return typeCheckFailure(context, value, this._message(value));\n            }\n            return typeCheckSuccess();\n        }\n    });\n    Object.defineProperty(Refinement.prototype, \"reconcile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, newValue, parent, subpath) {\n            return this._subtype.reconcile(current, newValue, parent, subpath);\n        }\n    });\n    Object.defineProperty(Refinement.prototype, \"getSubTypes\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this._subtype;\n        }\n    });\n    return Refinement;\n}(BaseType));\n/**\n * `types.refinement` - Creates a type that is more specific than the base type, e.g. `types.refinement(types.string, value => value.length > 5)` to create a type of strings that can only be longer then 5.\n *\n * @param name\n * @param type\n * @param predicate\n * @returns\n */\nfunction refinement() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var name = typeof args[0] === \"string\" ? args.shift() : isType(args[0]) ? args[0].name : null;\n    var type = args[0];\n    var predicate = args[1];\n    var message = args[2]\n        ? args[2]\n        : function (v) { return \"Value does not respect the refinement predicate\"; };\n    // ensures all parameters are correct\n    assertIsType(type, [1, 2]);\n    assertIsString(name, 1);\n    assertIsFunction(predicate, [2, 3]);\n    assertIsFunction(message, [3, 4]);\n    return new Refinement(name, type, predicate, message);\n}\n/**\n * Returns if a given value is a refinement type.\n *\n * @param type\n * @returns\n */\nfunction isRefinementType(type) {\n    return (type.flags & TypeFlags.Refinement) > 0;\n}\n\n/**\n * `types.enumeration` - Can be used to create an string based enumeration.\n * (note: this methods is just sugar for a union of string literals)\n *\n * Example:\n * ```ts\n * const TrafficLight = types.model({\n *   color: types.enumeration(\"Color\", [\"Red\", \"Orange\", \"Green\"])\n * })\n * ```\n *\n * @param name descriptive name of the enumeration (optional)\n * @param options possible values this enumeration can have\n * @returns\n */\nfunction enumeration(name, options) {\n    var realOptions = typeof name === \"string\" ? options : name;\n    // check all options\n    if (devMode()) {\n        realOptions.forEach(function (option, i) {\n            assertIsString(option, i + 1);\n        });\n    }\n    var type = union.apply(void 0, __spread(realOptions.map(function (option) { return literal(\"\" + option); })));\n    if (typeof name === \"string\")\n        type.name = name;\n    return type;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar Union = /** @class */ (function (_super) {\n    __extends(Union, _super);\n    function Union(name, _types, options) {\n        var _this = _super.call(this, name) || this;\n        Object.defineProperty(_this, \"_types\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _types\n        });\n        Object.defineProperty(_this, \"_dispatcher\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(_this, \"_eager\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        options = __assign({ eager: true, dispatcher: undefined }, options);\n        _this._dispatcher = options.dispatcher;\n        if (!options.eager)\n            _this._eager = false;\n        return _this;\n    }\n    Object.defineProperty(Union.prototype, \"flags\", {\n        get: function () {\n            var result = TypeFlags.Union;\n            this._types.forEach(function (type) {\n                result |= type.flags;\n            });\n            return result;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Union.prototype, \"isAssignableFrom\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (type) {\n            return this._types.some(function (subType) { return subType.isAssignableFrom(type); });\n        }\n    });\n    Object.defineProperty(Union.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return \"(\" + this._types.map(function (factory) { return factory.describe(); }).join(\" | \") + \")\";\n        }\n    });\n    Object.defineProperty(Union.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            var type = this.determineType(initialValue, undefined);\n            if (!type)\n                throw fail$1(\"No matching type for union \" + this.describe()); // can happen in prod builds\n            return type.instantiate(parent, subpath, environment, initialValue);\n        }\n    });\n    Object.defineProperty(Union.prototype, \"reconcile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, newValue, parent, subpath) {\n            var type = this.determineType(newValue, current.getReconciliationType());\n            if (!type)\n                throw fail$1(\"No matching type for union \" + this.describe()); // can happen in prod builds\n            return type.reconcile(current, newValue, parent, subpath);\n        }\n    });\n    Object.defineProperty(Union.prototype, \"determineType\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, reconcileCurrentType) {\n            // try the dispatcher, if defined\n            if (this._dispatcher) {\n                return this._dispatcher(value);\n            }\n            // find the most accomodating type\n            // if we are using reconciliation try the current node type first (fix for #1045)\n            if (reconcileCurrentType) {\n                if (reconcileCurrentType.is(value)) {\n                    return reconcileCurrentType;\n                }\n                return this._types\n                    .filter(function (t) { return t !== reconcileCurrentType; })\n                    .find(function (type) { return type.is(value); });\n            }\n            else {\n                return this._types.find(function (type) { return type.is(value); });\n            }\n        }\n    });\n    Object.defineProperty(Union.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            if (this._dispatcher) {\n                return this._dispatcher(value).validate(value, context);\n            }\n            var allErrors = [];\n            var applicableTypes = 0;\n            for (var i = 0; i < this._types.length; i++) {\n                var type = this._types[i];\n                var errors = type.validate(value, context);\n                if (errors.length === 0) {\n                    if (this._eager)\n                        return typeCheckSuccess();\n                    else\n                        applicableTypes++;\n                }\n                else {\n                    allErrors.push(errors);\n                }\n            }\n            if (applicableTypes === 1)\n                return typeCheckSuccess();\n            return typeCheckFailure(context, value, \"No type is applicable for the union\").concat(flattenTypeErrors(allErrors));\n        }\n    });\n    Object.defineProperty(Union.prototype, \"getSubTypes\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this._types;\n        }\n    });\n    return Union;\n}(BaseType));\n/**\n * `types.union` - Create a union of multiple types. If the correct type cannot be inferred unambiguously from a snapshot, provide a dispatcher function of the form `(snapshot) => Type`.\n *\n * @param optionsOrType\n * @param otherTypes\n * @returns\n */\nfunction union(optionsOrType) {\n    var otherTypes = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        otherTypes[_i - 1] = arguments[_i];\n    }\n    var options = isType(optionsOrType) ? undefined : optionsOrType;\n    var types = isType(optionsOrType) ? __spread([optionsOrType], otherTypes) : otherTypes;\n    var name = \"(\" + types.map(function (type) { return type.name; }).join(\" | \") + \")\";\n    // check all options\n    if (devMode()) {\n        if (options) {\n            assertArg(options, function (o) { return isPlainObject(o); }, \"object { eager?: boolean, dispatcher?: Function }\", 1);\n        }\n        types.forEach(function (type, i) {\n            assertIsType(type, options ? i + 2 : i + 1);\n        });\n    }\n    return new Union(name, types, options);\n}\n/**\n * Returns if a given value represents a union type.\n *\n * @param type\n * @returns\n */\nfunction isUnionType(type) {\n    return (type.flags & TypeFlags.Union) > 0;\n}\n\n/**\n * @hidden\n * @internal\n */\nvar OptionalValue = /** @class */ (function (_super) {\n    __extends(OptionalValue, _super);\n    function OptionalValue(_subtype, _defaultValue, optionalValues) {\n        var _this = _super.call(this, _subtype.name) || this;\n        Object.defineProperty(_this, \"_subtype\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _subtype\n        });\n        Object.defineProperty(_this, \"_defaultValue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _defaultValue\n        });\n        Object.defineProperty(_this, \"optionalValues\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: optionalValues\n        });\n        return _this;\n    }\n    Object.defineProperty(OptionalValue.prototype, \"flags\", {\n        get: function () {\n            return this._subtype.flags | TypeFlags.Optional;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(OptionalValue.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this._subtype.describe() + \"?\";\n        }\n    });\n    Object.defineProperty(OptionalValue.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            if (this.optionalValues.indexOf(initialValue) >= 0) {\n                var defaultInstanceOrSnapshot = this.getDefaultInstanceOrSnapshot();\n                return this._subtype.instantiate(parent, subpath, environment, defaultInstanceOrSnapshot);\n            }\n            return this._subtype.instantiate(parent, subpath, environment, initialValue);\n        }\n    });\n    Object.defineProperty(OptionalValue.prototype, \"reconcile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, newValue, parent, subpath) {\n            return this._subtype.reconcile(current, this.optionalValues.indexOf(newValue) < 0 && this._subtype.is(newValue)\n                ? newValue\n                : this.getDefaultInstanceOrSnapshot(), parent, subpath);\n        }\n    });\n    Object.defineProperty(OptionalValue.prototype, \"getDefaultInstanceOrSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var defaultInstanceOrSnapshot = typeof this._defaultValue === \"function\"\n                ? this._defaultValue()\n                : this._defaultValue;\n            // while static values are already snapshots and checked on types.optional\n            // generator functions must always be rechecked just in case\n            if (typeof this._defaultValue === \"function\") {\n                typecheckInternal(this, defaultInstanceOrSnapshot);\n            }\n            return defaultInstanceOrSnapshot;\n        }\n    });\n    Object.defineProperty(OptionalValue.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            // defaulted values can be skipped\n            if (this.optionalValues.indexOf(value) >= 0) {\n                return typeCheckSuccess();\n            }\n            // bounce validation to the sub-type\n            return this._subtype.validate(value, context);\n        }\n    });\n    Object.defineProperty(OptionalValue.prototype, \"isAssignableFrom\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (type) {\n            return this._subtype.isAssignableFrom(type);\n        }\n    });\n    Object.defineProperty(OptionalValue.prototype, \"getSubTypes\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this._subtype;\n        }\n    });\n    return OptionalValue;\n}(BaseType));\nfunction checkOptionalPreconditions(type, defaultValueOrFunction) {\n    // make sure we never pass direct instances\n    if (typeof defaultValueOrFunction !== \"function\" && isStateTreeNode(defaultValueOrFunction)) {\n        throw fail$1(\"default value cannot be an instance, pass a snapshot or a function that creates an instance/snapshot instead\");\n    }\n    assertIsType(type, 1);\n    if (devMode()) {\n        // we only check default values if they are passed directly\n        // if they are generator functions they will be checked once they are generated\n        // we don't check generator function results here to avoid generating a node just for type-checking purposes\n        // which might generate side-effects\n        if (typeof defaultValueOrFunction !== \"function\") {\n            typecheckInternal(type, defaultValueOrFunction);\n        }\n    }\n}\n/**\n * `types.optional` - Can be used to create a property with a default value.\n *\n * Depending on the third argument (`optionalValues`) there are two ways of operation:\n * - If the argument is not provided, then if a value is not provided in the snapshot (`undefined` or missing),\n *   it will default to the provided `defaultValue`\n * - If the argument is provided, then if the value in the snapshot matches one of the optional values inside the array then it will\n *   default to the provided `defaultValue`. Additionally, if one of the optional values inside the array is `undefined` then a missing\n *   property is also valid.\n *\n *   Note that it is also possible to include values of the same type as the intended subtype as optional values,\n *   in this case the optional value will be transformed into the `defaultValue` (e.g. `types.optional(types.string, \"unnamed\", [undefined, \"\"])`\n *   will transform the snapshot values `undefined` (and therefore missing) and empty strings into the string `\"unnamed\"` when it gets\n *   instantiated).\n *\n * If `defaultValue` is a function, the function will be invoked for every new instance.\n * Applying a snapshot in which the optional value is one of the optional values (or `undefined`/_not_ present if none are provided) causes the\n * value to be reset.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string,\n *   subtitle1: types.optional(types.string, \"\", [null]),\n *   subtitle2: types.optional(types.string, \"\", [null, undefined]),\n *   done: types.optional(types.boolean, false),\n *   created: types.optional(types.Date, () => new Date()),\n * })\n *\n * // if done is missing / undefined it will become false\n * // if created is missing / undefined it will get a freshly generated timestamp\n * // if subtitle1 is null it will default to \"\", but it cannot be missing or undefined\n * // if subtitle2 is null or undefined it will default to \"\"; since it can be undefined it can also be missing\n * const todo = Todo.create({ title: \"Get coffee\", subtitle1: null })\n * ```\n *\n * @param type\n * @param defaultValueOrFunction\n * @param optionalValues an optional array with zero or more primitive values (string, number, boolean, null or undefined)\n *                       that will be converted into the default. `[ undefined ]` is assumed when none is provided\n * @returns\n */\nfunction optional(type, defaultValueOrFunction, optionalValues) {\n    checkOptionalPreconditions(type, defaultValueOrFunction);\n    return new OptionalValue(type, defaultValueOrFunction, optionalValues ? optionalValues : undefinedAsOptionalValues);\n}\nvar undefinedAsOptionalValues = [undefined];\n/**\n * Returns if a value represents an optional type.\n *\n * @template IT\n * @param type\n * @returns\n */\nfunction isOptionalType(type) {\n    return isType(type) && (type.flags & TypeFlags.Optional) > 0;\n}\n\nvar optionalUndefinedType = optional(undefinedType, undefined);\nvar optionalNullType = optional(nullType, null);\n/**\n * `types.maybe` - Maybe will make a type nullable, and also optional.\n * The value `undefined` will be used to represent nullability.\n *\n * @param type\n * @returns\n */\nfunction maybe(type) {\n    assertIsType(type, 1);\n    return union(type, optionalUndefinedType);\n}\n/**\n * `types.maybeNull` - Maybe will make a type nullable, and also optional.\n * The value `null` will be used to represent no value.\n *\n * @param type\n * @returns\n */\nfunction maybeNull(type) {\n    assertIsType(type, 1);\n    return union(type, optionalNullType);\n}\n\nvar Late = /** @class */ (function (_super) {\n    __extends(Late, _super);\n    function Late(name, _definition) {\n        var _this = _super.call(this, name) || this;\n        Object.defineProperty(_this, \"_definition\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _definition\n        });\n        Object.defineProperty(_this, \"_subType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        return _this;\n    }\n    Object.defineProperty(Late.prototype, \"flags\", {\n        get: function () {\n            return (this._subType ? this._subType.flags : 0) | TypeFlags.Late;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Late.prototype, \"getSubType\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (mustSucceed) {\n            if (!this._subType) {\n                var t = undefined;\n                try {\n                    t = this._definition();\n                }\n                catch (e) {\n                    if (e instanceof ReferenceError)\n                        // can happen in strict ES5 code when a definition is self refering\n                        t = undefined;\n                    else\n                        throw e;\n                }\n                if (mustSucceed && t === undefined)\n                    throw fail$1(\"Late type seems to be used too early, the definition (still) returns undefined\");\n                if (t) {\n                    if (devMode() && !isType(t))\n                        throw fail$1(\"Failed to determine subtype, make sure types.late returns a type definition.\");\n                    this._subType = t;\n                }\n            }\n            return this._subType;\n        }\n    });\n    Object.defineProperty(Late.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            return this.getSubType(true).instantiate(parent, subpath, environment, initialValue);\n        }\n    });\n    Object.defineProperty(Late.prototype, \"reconcile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, newValue, parent, subpath) {\n            return this.getSubType(true).reconcile(current, newValue, parent, subpath);\n        }\n    });\n    Object.defineProperty(Late.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var t = this.getSubType(false);\n            return t ? t.name : \"<uknown late type>\";\n        }\n    });\n    Object.defineProperty(Late.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            var t = this.getSubType(false);\n            if (!t) {\n                // See #916; the variable the definition closure is pointing to wasn't defined yet, so can't be evaluted yet here\n                return typeCheckSuccess();\n            }\n            return t.validate(value, context);\n        }\n    });\n    Object.defineProperty(Late.prototype, \"isAssignableFrom\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (type) {\n            var t = this.getSubType(false);\n            return t ? t.isAssignableFrom(type) : false;\n        }\n    });\n    Object.defineProperty(Late.prototype, \"getSubTypes\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            var subtype = this.getSubType(false);\n            return subtype ? subtype : cannotDetermineSubtype;\n        }\n    });\n    return Late;\n}(BaseType));\n/**\n * `types.late` - Defines a type that gets implemented later. This is useful when you have to deal with circular dependencies.\n * Please notice that when defining circular dependencies TypeScript isn't smart enough to inference them.\n *\n * Example:\n * ```ts\n *   // TypeScript isn't smart enough to infer self referencing types.\n *  const Node = types.model({\n *       children: types.array(types.late((): IAnyModelType => Node)) // then typecast each array element to Instance<typeof Node>\n *  })\n * ```\n *\n * @param name The name to use for the type that will be returned.\n * @param type A function that returns the type that will be defined.\n * @returns\n */\nfunction late(nameOrType, maybeType) {\n    var name = typeof nameOrType === \"string\" ? nameOrType : \"late(\" + nameOrType.toString() + \")\";\n    var type = typeof nameOrType === \"string\" ? maybeType : nameOrType;\n    // checks that the type is actually a late type\n    if (devMode()) {\n        if (!(typeof type === \"function\" && type.length === 0))\n            throw fail$1(\"Invalid late type, expected a function with zero arguments that returns a type, got: \" +\n                type);\n    }\n    return new Late(name, type);\n}\n/**\n * Returns if a given value represents a late type.\n *\n * @param type\n * @returns\n */\nfunction isLateType(type) {\n    return isType(type) && (type.flags & TypeFlags.Late) > 0;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar Frozen = /** @class */ (function (_super) {\n    __extends(Frozen, _super);\n    function Frozen(subType) {\n        var _this = _super.call(this, subType ? \"frozen(\" + subType.name + \")\" : \"frozen\") || this;\n        Object.defineProperty(_this, \"subType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: subType\n        });\n        Object.defineProperty(_this, \"flags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: TypeFlags.Frozen\n        });\n        return _this;\n    }\n    Object.defineProperty(Frozen.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return \"<any immutable value>\";\n        }\n    });\n    Object.defineProperty(Frozen.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, value) {\n            // create the node\n            return createScalarNode(this, parent, subpath, environment, deepFreeze(value));\n        }\n    });\n    Object.defineProperty(Frozen.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            if (!isSerializable(value)) {\n                return typeCheckFailure(context, value, \"Value is not serializable and cannot be frozen\");\n            }\n            if (this.subType)\n                return this.subType.validate(value, context);\n            return typeCheckSuccess();\n        }\n    });\n    return Frozen;\n}(SimpleType));\nvar untypedFrozenInstance = new Frozen();\n/**\n * `types.frozen` - Frozen can be used to store any value that is serializable in itself (that is valid JSON).\n * Frozen values need to be immutable or treated as if immutable. They need be serializable as well.\n * Values stored in frozen will snapshotted as-is by MST, and internal changes will not be tracked.\n *\n * This is useful to store complex, but immutable values like vectors etc. It can form a powerful bridge to parts of your application that should be immutable, or that assume data to be immutable.\n *\n * Note: if you want to store free-form state that is mutable, or not serializeable, consider using volatile state instead.\n *\n * Frozen properties can be defined in three different ways\n * 1. `types.frozen(SubType)` - provide a valid MST type and frozen will check if the provided data conforms the snapshot for that type\n * 2. `types.frozen({ someDefaultValue: true})` - provide a primitive value, object or array, and MST will infer the type from that object, and also make it the default value for the field\n * 3. `types.frozen<TypeScriptType>()` - provide a typescript type, to help in strongly typing the field (design time only)\n *\n * Example:\n * ```ts\n * const GameCharacter = types.model({\n *   name: string,\n *   location: types.frozen({ x: 0, y: 0})\n * })\n *\n * const hero = GameCharacter.create({\n *   name: \"Mario\",\n *   location: { x: 7, y: 4 }\n * })\n *\n * hero.location = { x: 10, y: 2 } // OK\n * hero.location.x = 7 // Not ok!\n * ```\n *\n * ```ts\n * type Point = { x: number, y: number }\n *    const Mouse = types.model({\n *         loc: types.frozen<Point>()\n *    })\n * ```\n *\n * @param defaultValueOrType\n * @returns\n */\nfunction frozen(arg) {\n    if (arguments.length === 0)\n        return untypedFrozenInstance;\n    else if (isType(arg))\n        return new Frozen(arg);\n    else\n        return optional(untypedFrozenInstance, arg);\n}\n/**\n * Returns if a given value represents a frozen type.\n *\n * @param type\n * @returns\n */\nfunction isFrozenType(type) {\n    return isType(type) && (type.flags & TypeFlags.Frozen) > 0;\n}\n\nfunction getInvalidationCause(hook) {\n    switch (hook) {\n        case Hook.beforeDestroy:\n            return \"destroy\";\n        case Hook.beforeDetach:\n            return \"detach\";\n        default:\n            return undefined;\n    }\n}\nvar StoredReference = /** @class */ (function () {\n    function StoredReference(value, targetType) {\n        Object.defineProperty(this, \"targetType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: targetType\n        });\n        Object.defineProperty(this, \"identifier\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"node\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resolvedReference\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (isValidIdentifier(value)) {\n            this.identifier = value;\n        }\n        else if (isStateTreeNode(value)) {\n            var targetNode = getStateTreeNode(value);\n            if (!targetNode.identifierAttribute)\n                throw fail$1(\"Can only store references with a defined identifier attribute.\");\n            var id = targetNode.unnormalizedIdentifier;\n            if (id === null || id === undefined) {\n                throw fail$1(\"Can only store references to tree nodes with a defined identifier.\");\n            }\n            this.identifier = id;\n        }\n        else {\n            throw fail$1(\"Can only store references to tree nodes or identifiers, got: '\" + value + \"'\");\n        }\n    }\n    Object.defineProperty(StoredReference.prototype, \"updateResolvedReference\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            var normalizedId = normalizeIdentifier(this.identifier);\n            var root = node.root;\n            var lastCacheModification = root.identifierCache.getLastCacheModificationPerId(normalizedId);\n            if (!this.resolvedReference ||\n                this.resolvedReference.lastCacheModification !== lastCacheModification) {\n                var targetType = this.targetType;\n                // reference was initialized with the identifier of the target\n                var target = root.identifierCache.resolve(targetType, normalizedId);\n                if (!target) {\n                    throw new InvalidReferenceError(\"[mobx-state-tree] Failed to resolve reference '\" + this.identifier + \"' to type '\" + this.targetType.name + \"' (from node: \" + node.path + \")\");\n                }\n                this.resolvedReference = {\n                    node: target,\n                    lastCacheModification: lastCacheModification\n                };\n            }\n        }\n    });\n    Object.defineProperty(StoredReference.prototype, \"resolvedValue\", {\n        get: function () {\n            this.updateResolvedReference(this.node);\n            return this.resolvedReference.node.value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return StoredReference;\n}());\n/**\n * @internal\n * @hidden\n */\nvar InvalidReferenceError = /** @class */ (function (_super) {\n    __extends(InvalidReferenceError, _super);\n    function InvalidReferenceError(m) {\n        var _this = _super.call(this, m) || this;\n        Object.setPrototypeOf(_this, InvalidReferenceError.prototype);\n        return _this;\n    }\n    return InvalidReferenceError;\n}(Error));\n/**\n * @internal\n * @hidden\n */\nvar BaseReferenceType = /** @class */ (function (_super) {\n    __extends(BaseReferenceType, _super);\n    function BaseReferenceType(targetType, onInvalidated) {\n        var _this = _super.call(this, \"reference(\" + targetType.name + \")\") || this;\n        Object.defineProperty(_this, \"targetType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: targetType\n        });\n        Object.defineProperty(_this, \"onInvalidated\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: onInvalidated\n        });\n        Object.defineProperty(_this, \"flags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: TypeFlags.Reference\n        });\n        return _this;\n    }\n    Object.defineProperty(BaseReferenceType.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this.name;\n        }\n    });\n    Object.defineProperty(BaseReferenceType.prototype, \"isAssignableFrom\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (type) {\n            return this.targetType.isAssignableFrom(type);\n        }\n    });\n    Object.defineProperty(BaseReferenceType.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            return isValidIdentifier(value)\n                ? typeCheckSuccess()\n                : typeCheckFailure(context, value, \"Value is not a valid identifier, which is a string or a number\");\n        }\n    });\n    Object.defineProperty(BaseReferenceType.prototype, \"fireInvalidated\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (cause, storedRefNode, referenceId, refTargetNode) {\n            // to actually invalidate a reference we need an alive parent,\n            // since it is a scalar value (immutable-ish) and we need to change it\n            // from the parent\n            var storedRefParentNode = storedRefNode.parent;\n            if (!storedRefParentNode || !storedRefParentNode.isAlive) {\n                return;\n            }\n            var storedRefParentValue = storedRefParentNode.storedValue;\n            if (!storedRefParentValue) {\n                return;\n            }\n            this.onInvalidated({\n                cause: cause,\n                parent: storedRefParentValue,\n                invalidTarget: refTargetNode ? refTargetNode.storedValue : undefined,\n                invalidId: referenceId,\n                replaceRef: function (newRef) {\n                    applyPatch(storedRefNode.root.storedValue, {\n                        op: \"replace\",\n                        value: newRef,\n                        path: storedRefNode.path\n                    });\n                },\n                removeRef: function () {\n                    if (isModelType(storedRefParentNode.type)) {\n                        this.replaceRef(undefined);\n                    }\n                    else {\n                        applyPatch(storedRefNode.root.storedValue, {\n                            op: \"remove\",\n                            path: storedRefNode.path\n                        });\n                    }\n                }\n            });\n        }\n    });\n    Object.defineProperty(BaseReferenceType.prototype, \"addTargetNodeWatcher\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (storedRefNode, referenceId) {\n            var _this = this;\n            // this will make sure the target node becomes created\n            var refTargetValue = this.getValue(storedRefNode);\n            if (!refTargetValue) {\n                return undefined;\n            }\n            var refTargetNode = getStateTreeNode(refTargetValue);\n            var hookHandler = function (_, refTargetNodeHook) {\n                var cause = getInvalidationCause(refTargetNodeHook);\n                if (!cause) {\n                    return;\n                }\n                _this.fireInvalidated(cause, storedRefNode, referenceId, refTargetNode);\n            };\n            var refTargetDetachHookDisposer = refTargetNode.registerHook(Hook.beforeDetach, hookHandler);\n            var refTargetDestroyHookDisposer = refTargetNode.registerHook(Hook.beforeDestroy, hookHandler);\n            return function () {\n                refTargetDetachHookDisposer();\n                refTargetDestroyHookDisposer();\n            };\n        }\n    });\n    Object.defineProperty(BaseReferenceType.prototype, \"watchTargetNodeForInvalidations\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (storedRefNode, identifier, customGetSet) {\n            var _this = this;\n            if (!this.onInvalidated) {\n                return;\n            }\n            var onRefTargetDestroyedHookDisposer;\n            // get rid of the watcher hook when the stored ref node is destroyed\n            // detached is ignored since scalar nodes (where the reference resides) cannot be detached\n            storedRefNode.registerHook(Hook.beforeDestroy, function () {\n                if (onRefTargetDestroyedHookDisposer) {\n                    onRefTargetDestroyedHookDisposer();\n                }\n            });\n            var startWatching = function (sync) {\n                // re-create hook in case the stored ref gets reattached\n                if (onRefTargetDestroyedHookDisposer) {\n                    onRefTargetDestroyedHookDisposer();\n                }\n                // make sure the target node is actually there and initialized\n                var storedRefParentNode = storedRefNode.parent;\n                var storedRefParentValue = storedRefParentNode && storedRefParentNode.storedValue;\n                if (storedRefParentNode && storedRefParentNode.isAlive && storedRefParentValue) {\n                    var refTargetNodeExists = void 0;\n                    if (customGetSet) {\n                        refTargetNodeExists = !!customGetSet.get(identifier, storedRefParentValue);\n                    }\n                    else {\n                        refTargetNodeExists = storedRefNode.root.identifierCache.has(_this.targetType, normalizeIdentifier(identifier));\n                    }\n                    if (!refTargetNodeExists) {\n                        // we cannot change the reference in sync mode\n                        // since we are in the middle of a reconciliation/instantiation and the change would be overwritten\n                        // for those cases just let the wrong reference be assigned and fail upon usage\n                        // (like current references do)\n                        // this means that effectively this code will only run when it is created from a snapshot\n                        if (!sync) {\n                            _this.fireInvalidated(\"invalidSnapshotReference\", storedRefNode, identifier, null);\n                        }\n                    }\n                    else {\n                        onRefTargetDestroyedHookDisposer = _this.addTargetNodeWatcher(storedRefNode, identifier);\n                    }\n                }\n            };\n            if (storedRefNode.state === NodeLifeCycle.FINALIZED) {\n                // already attached, so the whole tree is ready\n                startWatching(true);\n            }\n            else {\n                if (!storedRefNode.isRoot) {\n                    // start watching once the whole tree is ready\n                    storedRefNode.root.registerHook(Hook.afterCreationFinalization, function () {\n                        // make sure to attach it so it can start listening\n                        if (storedRefNode.parent) {\n                            storedRefNode.parent.createObservableInstanceIfNeeded();\n                        }\n                    });\n                }\n                // start watching once the node is attached somewhere / parent changes\n                storedRefNode.registerHook(Hook.afterAttach, function () {\n                    startWatching(false);\n                });\n            }\n        }\n    });\n    return BaseReferenceType;\n}(SimpleType));\n/**\n * @internal\n * @hidden\n */\nvar IdentifierReferenceType = /** @class */ (function (_super) {\n    __extends(IdentifierReferenceType, _super);\n    function IdentifierReferenceType(targetType, onInvalidated) {\n        return _super.call(this, targetType, onInvalidated) || this;\n    }\n    Object.defineProperty(IdentifierReferenceType.prototype, \"getValue\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (storedRefNode) {\n            if (!storedRefNode.isAlive)\n                return undefined;\n            var storedRef = storedRefNode.storedValue;\n            return storedRef.resolvedValue;\n        }\n    });\n    Object.defineProperty(IdentifierReferenceType.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (storedRefNode) {\n            var ref = storedRefNode.storedValue;\n            return ref.identifier;\n        }\n    });\n    Object.defineProperty(IdentifierReferenceType.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            var identifier = isStateTreeNode(initialValue)\n                ? getIdentifier(initialValue)\n                : initialValue;\n            var storedRef = new StoredReference(initialValue, this.targetType);\n            var storedRefNode = createScalarNode(this, parent, subpath, environment, storedRef);\n            storedRef.node = storedRefNode;\n            this.watchTargetNodeForInvalidations(storedRefNode, identifier, undefined);\n            return storedRefNode;\n        }\n    });\n    Object.defineProperty(IdentifierReferenceType.prototype, \"reconcile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, newValue, parent, subpath) {\n            if (!current.isDetaching && current.type === this) {\n                var compareByValue = isStateTreeNode(newValue);\n                var ref = current.storedValue;\n                if ((!compareByValue && ref.identifier === newValue) ||\n                    (compareByValue && ref.resolvedValue === newValue)) {\n                    current.setParent(parent, subpath);\n                    return current;\n                }\n            }\n            var newNode = this.instantiate(parent, subpath, undefined, newValue);\n            current.die(); // noop if detaching\n            return newNode;\n        }\n    });\n    return IdentifierReferenceType;\n}(BaseReferenceType));\n/**\n * @internal\n * @hidden\n */\nvar CustomReferenceType = /** @class */ (function (_super) {\n    __extends(CustomReferenceType, _super);\n    function CustomReferenceType(targetType, options, onInvalidated) {\n        var _this = _super.call(this, targetType, onInvalidated) || this;\n        Object.defineProperty(_this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: options\n        });\n        return _this;\n    }\n    Object.defineProperty(CustomReferenceType.prototype, \"getValue\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (storedRefNode) {\n            if (!storedRefNode.isAlive)\n                return undefined;\n            var referencedNode = this.options.get(storedRefNode.storedValue, storedRefNode.parent ? storedRefNode.parent.storedValue : null);\n            return referencedNode;\n        }\n    });\n    Object.defineProperty(CustomReferenceType.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (storedRefNode) {\n            return storedRefNode.storedValue;\n        }\n    });\n    Object.defineProperty(CustomReferenceType.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, newValue) {\n            var identifier = isStateTreeNode(newValue)\n                ? this.options.set(newValue, parent ? parent.storedValue : null)\n                : newValue;\n            var storedRefNode = createScalarNode(this, parent, subpath, environment, identifier);\n            this.watchTargetNodeForInvalidations(storedRefNode, identifier, this.options);\n            return storedRefNode;\n        }\n    });\n    Object.defineProperty(CustomReferenceType.prototype, \"reconcile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, newValue, parent, subpath) {\n            var newIdentifier = isStateTreeNode(newValue)\n                ? this.options.set(newValue, current ? current.storedValue : null)\n                : newValue;\n            if (!current.isDetaching &&\n                current.type === this &&\n                current.storedValue === newIdentifier) {\n                current.setParent(parent, subpath);\n                return current;\n            }\n            var newNode = this.instantiate(parent, subpath, undefined, newIdentifier);\n            current.die(); // noop if detaching\n            return newNode;\n        }\n    });\n    return CustomReferenceType;\n}(BaseReferenceType));\n/**\n * `types.reference` - Creates a reference to another type, which should have defined an identifier.\n * See also the [reference and identifiers](https://github.com/mobxjs/mobx-state-tree#references-and-identifiers) section.\n */\nfunction reference(subType, options) {\n    assertIsType(subType, 1);\n    if (devMode()) {\n        if (arguments.length === 2 && typeof arguments[1] === \"string\") {\n            // istanbul ignore next\n            throw fail$1(\"References with base path are no longer supported. Please remove the base path.\");\n        }\n    }\n    var getSetOptions = options ? options : undefined;\n    var onInvalidated = options\n        ? options.onInvalidated\n        : undefined;\n    if (getSetOptions && (getSetOptions.get || getSetOptions.set)) {\n        if (devMode()) {\n            if (!getSetOptions.get || !getSetOptions.set) {\n                throw fail$1(\"reference options must either contain both a 'get' and a 'set' method or none of them\");\n            }\n        }\n        return new CustomReferenceType(subType, {\n            get: getSetOptions.get,\n            set: getSetOptions.set\n        }, onInvalidated);\n    }\n    else {\n        return new IdentifierReferenceType(subType, onInvalidated);\n    }\n}\n/**\n * Returns if a given value represents a reference type.\n *\n * @param type\n * @returns\n */\nfunction isReferenceType(type) {\n    return (type.flags & TypeFlags.Reference) > 0;\n}\n/**\n * `types.safeReference` - A safe reference is like a standard reference, except that it accepts the undefined value by default\n * and automatically sets itself to undefined (when the parent is a model) / removes itself from arrays and maps\n * when the reference it is pointing to gets detached/destroyed.\n *\n * The optional options parameter object accepts a parameter named `acceptsUndefined`, which is set to true by default, so it is suitable\n * for model properties.\n * When used inside collections (arrays/maps), it is recommended to set this option to false so it can't take undefined as value,\n * which is usually the desired in those cases.\n * Additionally, the optional options parameter object accepts a parameter named `onInvalidated`, which will be called when the reference target node that the reference is pointing to is about to be detached/destroyed\n *\n * Strictly speaking it is a `types.maybe(types.reference(X))` (when `acceptsUndefined` is set to true, the default) and\n * `types.reference(X)` (when `acceptsUndefined` is set to false), both of them with a customized `onInvalidated` option.\n *\n * @param subType\n * @param options\n * @returns\n */\nfunction safeReference(subType, options) {\n    var refType = reference(subType, __assign(__assign({}, options), { onInvalidated: function (ev) {\n            if (options && options.onInvalidated) {\n                options.onInvalidated(ev);\n            }\n            ev.removeRef();\n        } }));\n    if (options && options.acceptsUndefined === false) {\n        return refType;\n    }\n    else {\n        return maybe(refType);\n    }\n}\n\nvar BaseIdentifierType = /** @class */ (function (_super) {\n    __extends(BaseIdentifierType, _super);\n    function BaseIdentifierType(name, validType) {\n        var _this = _super.call(this, name) || this;\n        Object.defineProperty(_this, \"validType\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: validType\n        });\n        Object.defineProperty(_this, \"flags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: TypeFlags.Identifier\n        });\n        return _this;\n    }\n    Object.defineProperty(BaseIdentifierType.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            if (!parent || !(parent.type instanceof ModelType))\n                throw fail$1(\"Identifier types can only be instantiated as direct child of a model type\");\n            return createScalarNode(this, parent, subpath, environment, initialValue);\n        }\n    });\n    Object.defineProperty(BaseIdentifierType.prototype, \"reconcile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, newValue, parent, subpath) {\n            // we don't consider detaching here since identifier are scalar nodes, and scalar nodes cannot be detached\n            if (current.storedValue !== newValue)\n                throw fail$1(\"Tried to change identifier from '\" + current.storedValue + \"' to '\" + newValue + \"'. Changing identifiers is not allowed.\");\n            current.setParent(parent, subpath);\n            return current;\n        }\n    });\n    Object.defineProperty(BaseIdentifierType.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            if (typeof value !== this.validType) {\n                return typeCheckFailure(context, value, \"Value is not a valid \" + this.describe() + \", expected a \" + this.validType);\n            }\n            return typeCheckSuccess();\n        }\n    });\n    return BaseIdentifierType;\n}(SimpleType));\n/**\n * @internal\n * @hidden\n */\nvar IdentifierType = /** @class */ (function (_super) {\n    __extends(IdentifierType, _super);\n    function IdentifierType() {\n        var _this = _super.call(this, \"identifier\", \"string\") || this;\n        Object.defineProperty(_this, \"flags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: TypeFlags.Identifier\n        });\n        return _this;\n    }\n    Object.defineProperty(IdentifierType.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return \"identifier\";\n        }\n    });\n    return IdentifierType;\n}(BaseIdentifierType));\n/**\n * @internal\n * @hidden\n */\nvar IdentifierNumberType = /** @class */ (function (_super) {\n    __extends(IdentifierNumberType, _super);\n    function IdentifierNumberType() {\n        return _super.call(this, \"identifierNumber\", \"number\") || this;\n    }\n    Object.defineProperty(IdentifierNumberType.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            return node.storedValue;\n        }\n    });\n    Object.defineProperty(IdentifierNumberType.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return \"identifierNumber\";\n        }\n    });\n    return IdentifierNumberType;\n}(BaseIdentifierType));\n/**\n * `types.identifier` - Identifiers are used to make references, lifecycle events and reconciling works.\n * Inside a state tree, for each type can exist only one instance for each given identifier.\n * For example there couldn't be 2 instances of user with id 1. If you need more, consider using references.\n * Identifier can be used only as type property of a model.\n * This type accepts as parameter the value type of the identifier field that can be either string or number.\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifier,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\nvar identifier = new IdentifierType();\n/**\n * `types.identifierNumber` - Similar to `types.identifier`. This one will serialize from / to a number when applying snapshots\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifierNumber,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\nvar identifierNumber = new IdentifierNumberType();\n/**\n * Returns if a given value represents an identifier type.\n *\n * @param type\n * @returns\n */\nfunction isIdentifierType(type) {\n    return isType(type) && (type.flags & TypeFlags.Identifier) > 0;\n}\n/**\n * @internal\n * @hidden\n */\nfunction normalizeIdentifier(id) {\n    return \"\" + id;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isValidIdentifier(id) {\n    return typeof id === \"string\" || typeof id === \"number\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsValidIdentifier(id, argNumber) {\n    assertArg(id, isValidIdentifier, \"string or number (identifier)\", argNumber);\n}\n\n/**\n * `types.custom` - Creates a custom type. Custom types can be used for arbitrary immutable values, that have a serializable representation. For example, to create your own Date representation, Decimal type etc.\n *\n * The signature of the options is:\n * ```ts\n * export interface CustomTypeOptions<S, T> {\n *     // Friendly name\n *     name: string\n *     // given a serialized value and environment, how to turn it into the target type\n *     fromSnapshot(snapshot: S, env: any): T\n *     // return the serialization of the current value\n *     toSnapshot(value: T): S\n *     // if true, this is a converted value, if false, it's a snapshot\n *     isTargetType(value: T | S): value is T\n *     // a non empty string is assumed to be a validation error\n *     getValidationMessage?(snapshot: S): string\n * }\n * ```\n *\n * Example:\n * ```ts\n * const DecimalPrimitive = types.custom<string, Decimal>({\n *     name: \"Decimal\",\n *     fromSnapshot(value: string) {\n *         return new Decimal(value)\n *     },\n *     toSnapshot(value: Decimal) {\n *         return value.toString()\n *     },\n *     isTargetType(value: string | Decimal): boolean {\n *         return value instanceof Decimal\n *     },\n *     getValidationMessage(value: string): string {\n *         if (/^-?\\d+\\.\\d+$/.test(value)) return \"\" // OK\n *         return `'${value}' doesn't look like a valid decimal number`\n *     }\n * })\n *\n * const Wallet = types.model({\n *     balance: DecimalPrimitive\n * })\n * ```\n *\n * @param options\n * @returns\n */\nfunction custom(options) {\n    return new CustomType(options);\n}\n/**\n * @internal\n * @hidden\n */\nvar CustomType = /** @class */ (function (_super) {\n    __extends(CustomType, _super);\n    function CustomType(options) {\n        var _this = _super.call(this, options.name) || this;\n        Object.defineProperty(_this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: options\n        });\n        Object.defineProperty(_this, \"flags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: TypeFlags.Custom\n        });\n        return _this;\n    }\n    Object.defineProperty(CustomType.prototype, \"describe\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function () {\n            return this.name;\n        }\n    });\n    Object.defineProperty(CustomType.prototype, \"isValidSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (value, context) {\n            if (this.options.isTargetType(value))\n                return typeCheckSuccess();\n            var typeError = this.options.getValidationMessage(value);\n            if (typeError) {\n                return typeCheckFailure(context, value, \"Invalid value for type '\" + this.name + \"': \" + typeError);\n            }\n            return typeCheckSuccess();\n        }\n    });\n    Object.defineProperty(CustomType.prototype, \"getSnapshot\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (node) {\n            return this.options.toSnapshot(node.storedValue);\n        }\n    });\n    Object.defineProperty(CustomType.prototype, \"instantiate\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (parent, subpath, environment, initialValue) {\n            var valueToStore = this.options.isTargetType(initialValue)\n                ? initialValue\n                : this.options.fromSnapshot(initialValue, parent && parent.root.environment);\n            return createScalarNode(this, parent, subpath, environment, valueToStore);\n        }\n    });\n    Object.defineProperty(CustomType.prototype, \"reconcile\", {\n        enumerable: false,\n        configurable: true,\n        writable: true,\n        value: function (current, value, parent, subpath) {\n            var isSnapshot = !this.options.isTargetType(value);\n            // in theory customs use scalar nodes which cannot be detached, but still...\n            if (!current.isDetaching) {\n                var unchanged = current.type === this &&\n                    (isSnapshot ? value === current.snapshot : value === current.storedValue);\n                if (unchanged) {\n                    current.setParent(parent, subpath);\n                    return current;\n                }\n            }\n            var valueToStore = isSnapshot\n                ? this.options.fromSnapshot(value, parent.root.environment)\n                : value;\n            var newNode = this.instantiate(parent, subpath, undefined, valueToStore);\n            current.die(); // noop if detaching\n            return newNode;\n        }\n    });\n    return CustomType;\n}(SimpleType));\n\n// we import the types to re-export them inside types.\nvar types = {\n    enumeration: enumeration,\n    model: model,\n    compose: compose,\n    custom: custom,\n    reference: reference,\n    safeReference: safeReference,\n    union: union,\n    optional: optional,\n    literal: literal,\n    maybe: maybe,\n    maybeNull: maybeNull,\n    refinement: refinement,\n    string: string,\n    boolean: boolean,\n    number: number,\n    integer: integer,\n    Date: DatePrimitive,\n    map: map,\n    array: array,\n    frozen: frozen,\n    identifier: identifier,\n    identifierNumber: identifierNumber,\n    late: late,\n    undefined: undefinedType,\n    null: nullType,\n    snapshotProcessor: snapshotProcessor\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tb2J4LXN0YXRlLXRyZWUvZGlzdC9tb2J4LXN0YXRlLXRyZWUubW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOFc7O0FBRTlXO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLCtCQUErQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNEO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0JBQStCLHNDQUFzQztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0RBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsNkJBQTZCLG9CQUFvQjtBQUNqRDtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdEQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdEQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNELDJCQUEyQiw0Q0FBTTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtDQUFrQyw4Q0FBUSxlQUFlLHFDQUFxQztBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3Ryx1QkFBdUI7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrRUFBZ0M7QUFDcEQsb0JBQW9CLHNFQUFnQztBQUNwRDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsVUFBVTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4Q0FBUSxlQUFlLHdCQUF3Qix3QkFBd0Isc0NBQXNDO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QsZ0RBQWdELDRDQUFNO0FBQ3RELDhCQUE4Qiw0Q0FBTTtBQUNwQywyQkFBMkIsNENBQU07O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNCQUFzQjtBQUNqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLDRDQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRCwrQkFBK0IsNENBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsdUlBQXVJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQkFBK0I7QUFDckUsSUFBSSxpREFBVztBQUNmLHFEQUFxRCx5Q0FBeUM7QUFDOUYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxzQ0FBc0M7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyw2Q0FBNkM7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLGNBQWMsZ0NBQWdDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNENBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHdCQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQWtEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxQkFBcUI7QUFDaEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUFVO0FBQzdCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQVU7QUFDN0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNENBQVU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0Q0FBTTtBQUNsQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkNBQU87QUFDbkI7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwrQ0FBK0M7QUFDbEc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwrQ0FBK0M7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFEQUFlO0FBQ2pDLFFBQVE7QUFDUixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1REFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVEQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHdEQUFrQjtBQUN0QixVQUFVLG9EQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5Q0FBeUM7QUFDckY7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTyxvQkFBb0IsT0FBTyxRQUFRLE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0NBQWtDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsNERBQTRELGtCQUFrQix5QkFBeUI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EscURBQXFELGtCQUFrQiw2Q0FBNkM7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsb0JBQW9CO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUIsNkJBQTZCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrQkFBK0I7QUFDbkY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixtQkFBbUI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0Ryx5QkFBeUI7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDRDQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDLENBQUMsK0NBQWE7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFlBQVksK0NBQVM7QUFDckIsWUFBWSw2Q0FBTztBQUNuQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQU07QUFDekI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNELGtDQUFrQyw0Q0FBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0EscUJBQXFCLDZCQUE2QjtBQUNsRCxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBVTtBQUM3QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFlBQVksK0NBQVM7QUFDckIsWUFBWSw2Q0FBTztBQUNuQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNEJBQTRCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxS0FBcUsscUJBQXFCO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsdUJBQXVCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNEJBQTRCO0FBQzdGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DLDRDQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BELDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0JBQXdCO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDRCQUE0QjtBQUMvRTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELHFCQUFxQjtBQUNyQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw4QkFBOEI7QUFDakY7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxxQkFBcUI7QUFDckI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1DQUFtQztBQUM3RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtDQUFrQztBQUM1RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5Q0FBRztBQUNmO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2QkFBNkI7QUFDdkU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaUNBQWlDO0FBQzNFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFnQjtBQUNwQyxvQkFBb0Isb0RBQWMsZUFBZSxZQUFZLDBDQUFRO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBVTtBQUM3QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBZTtBQUMvQixhQUFhO0FBQ2IsMkRBQTJELGtCQUFrQjtBQUM3RSxZQUFZLCtDQUFTO0FBQ3JCLFlBQVksNkNBQU87QUFDbkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsZ0JBQWdCLDZDQUFPO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCx3Q0FBd0M7QUFDaEc7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSwwQ0FBMEMsdURBQXVEO0FBQ2pHLDZCQUE2QjtBQUM3QixtQkFBbUI7QUFDbkI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DLDRDQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsK0JBQStCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsK0JBQStCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx3RUFBd0Usc0JBQXNCO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsZ0NBQWdDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxvQkFBb0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLHlCQUF5QjtBQUMzRyx5RUFBeUUsb0RBQW9ELGlCQUFpQiwrQ0FBK0M7QUFDN0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0ZBQWdGLDhCQUE4QjtBQUM5RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkJBQTZCLG9DQUFvQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsd0NBQXdDO0FBQ2pHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsNEJBQTRCO0FBQzFGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxvQ0FBb0M7QUFDL0UsNENBQTRDLHdCQUF3QjtBQUNwRTtBQUNBO0FBQ0EsMERBQTBELHdCQUF3QjtBQUNsRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1CQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCLFlBQVksd0NBQXdDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELDhCQUE4QixzQ0FBc0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsSUFBSTtBQUNKO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbW9ieC1zdGF0ZS10cmVlL2Rpc3QvbW9ieC1zdGF0ZS10cmVlLm1vZHVsZS5qcz8zYWQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzQ29tcHV0ZWRQcm9wLCBpc09ic2VydmFibGVQcm9wLCBjcmVhdGVBdG9tLCBhY3Rpb24sIGNvbXB1dGVkLCBfYWxsb3dTdGF0ZUNoYW5nZXNJbnNpZGVDb21wdXRlZCwgcmVhY3Rpb24sIHJ1bkluQWN0aW9uLCBvYnNlcnZhYmxlLCB2YWx1ZXMsIGVudHJpZXMsIF9nZXRHbG9iYWxTdGF0ZSwgaXNPYnNlcnZhYmxlQXJyYXksIGlzT2JzZXJ2YWJsZU9iamVjdCwgZGVmaW5lUHJvcGVydHkgYXMgZGVmaW5lUHJvcGVydHkkMSwgT2JzZXJ2YWJsZU1hcCwgX2ludGVyY2VwdFJlYWRzLCBpbnRlcmNlcHQsIG9ic2VydmUsIF9nZXRBZG1pbmlzdHJhdGlvbiwgc2V0LCBtYWtlT2JzZXJ2YWJsZSwgZ2V0QXRvbSB9IGZyb20gJ21vYngnO1xuXG52YXIgbGl2ZWxpbmVzc0NoZWNraW5nID0gXCJ3YXJuXCI7XG4vKipcbiAqIERlZmluZXMgd2hhdCBNU1Qgc2hvdWxkIGRvIHdoZW4gcnVubmluZyBpbnRvIHJlYWRzIC8gd3JpdGVzIHRvIG9iamVjdHMgdGhhdCBoYXZlIGRpZWQuXG4gKiBCeSBkZWZhdWx0IGl0IHdpbGwgcHJpbnQgYSB3YXJuaW5nLlxuICogVXNlIHRoZSBgXCJlcnJvclwiYCBvcHRpb24gdG8gZWFzeSBkZWJ1Z2dpbmcgdG8gc2VlIHdoZXJlIHRoZSBlcnJvciB3YXMgdGhyb3duIGFuZCB3aGVuIHRoZSBvZmZlbmRpbmcgcmVhZCAvIHdyaXRlIHRvb2sgcGxhY2VcbiAqXG4gKiBAcGFyYW0gbW9kZSBgXCJ3YXJuXCJgLCBgXCJlcnJvclwiYCBvciBgXCJpZ25vcmVcImBcbiAqL1xuZnVuY3Rpb24gc2V0TGl2ZWxpbmVzc0NoZWNraW5nKG1vZGUpIHtcbiAgICBsaXZlbGluZXNzQ2hlY2tpbmcgPSBtb2RlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IGxpdmVsaW5lc3MgY2hlY2tpbmcgbW9kZS5cbiAqXG4gKiBAcmV0dXJucyBgXCJ3YXJuXCJgLCBgXCJlcnJvclwiYCBvciBgXCJpZ25vcmVcImBcbiAqL1xuZnVuY3Rpb24gZ2V0TGl2ZWxpbmVzc0NoZWNraW5nKCkge1xuICAgIHJldHVybiBsaXZlbGluZXNzQ2hlY2tpbmc7XG59XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBzZXRMaXZlbGluZXNzQ2hlY2tpbmcgaW5zdGVhZFxuICogQGhpZGRlblxuICpcbiAqIERlZmluZXMgd2hhdCBNU1Qgc2hvdWxkIGRvIHdoZW4gcnVubmluZyBpbnRvIHJlYWRzIC8gd3JpdGVzIHRvIG9iamVjdHMgdGhhdCBoYXZlIGRpZWQuXG4gKiBCeSBkZWZhdWx0IGl0IHdpbGwgcHJpbnQgYSB3YXJuaW5nLlxuICogVXNlIHRoZSBgXCJlcnJvclwiYCBvcHRpb24gdG8gZWFzeSBkZWJ1Z2dpbmcgdG8gc2VlIHdoZXJlIHRoZSBlcnJvciB3YXMgdGhyb3duIGFuZCB3aGVuIHRoZSBvZmZlbmRpbmcgcmVhZCAvIHdyaXRlIHRvb2sgcGxhY2VcbiAqXG4gKiBAcGFyYW0gbW9kZSBgXCJ3YXJuXCJgLCBgXCJlcnJvclwiYCBvciBgXCJpZ25vcmVcImBcbiAqL1xuZnVuY3Rpb24gc2V0TGl2ZWx5bmVzc0NoZWNraW5nKG1vZGUpIHtcbiAgICBzZXRMaXZlbGluZXNzQ2hlY2tpbmcobW9kZSk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG52YXIgSG9vaztcbihmdW5jdGlvbiAoSG9vaykge1xuICAgIEhvb2tbXCJhZnRlckNyZWF0ZVwiXSA9IFwiYWZ0ZXJDcmVhdGVcIjtcbiAgICBIb29rW1wiYWZ0ZXJBdHRhY2hcIl0gPSBcImFmdGVyQXR0YWNoXCI7XG4gICAgSG9va1tcImFmdGVyQ3JlYXRpb25GaW5hbGl6YXRpb25cIl0gPSBcImFmdGVyQ3JlYXRpb25GaW5hbGl6YXRpb25cIjtcbiAgICBIb29rW1wiYmVmb3JlRGV0YWNoXCJdID0gXCJiZWZvcmVEZXRhY2hcIjtcbiAgICBIb29rW1wiYmVmb3JlRGVzdHJveVwiXSA9IFwiYmVmb3JlRGVzdHJveVwiO1xufSkoSG9vayB8fCAoSG9vayA9IHt9KSk7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5mdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIF9hY3R1YWxfIHR5cGUgb2YgdGhlIGdpdmVuIHRyZWUgbm9kZS4gKE9yIHRocm93cylcbiAqXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRUeXBlKG9iamVjdCkge1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZShvYmplY3QsIDEpO1xuICAgIHJldHVybiBnZXRTdGF0ZVRyZWVOb2RlKG9iamVjdCkudHlwZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgX2RlY2xhcmVkXyB0eXBlIG9mIHRoZSBnaXZlbiBzdWIgcHJvcGVydHkgb2YgYW4gb2JqZWN0LCBhcnJheSBvciBtYXAuXG4gKiBJbiB0aGUgY2FzZSBvZiBhcnJheXMgYW5kIG1hcHMgdGhlIHByb3BlcnR5IG5hbWUgaXMgb3B0aW9uYWwgYW5kIHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IEJveCA9IHR5cGVzLm1vZGVsKHsgeDogMCwgeTogMCB9KVxuICogY29uc3QgYm94ID0gQm94LmNyZWF0ZSgpXG4gKlxuICogY29uc29sZS5sb2coZ2V0Q2hpbGRUeXBlKGJveCwgXCJ4XCIpLm5hbWUpIC8vICdudW1iZXInXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb2JqZWN0XG4gKiBAcGFyYW0gcHJvcGVydHlOYW1lXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRDaGlsZFR5cGUob2JqZWN0LCBwcm9wZXJ0eU5hbWUpIHtcbiAgICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUob2JqZWN0LCAxKTtcbiAgICByZXR1cm4gZ2V0U3RhdGVUcmVlTm9kZShvYmplY3QpLmdldENoaWxkVHlwZShwcm9wZXJ0eU5hbWUpO1xufVxuLyoqXG4gKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCBmb3IgZWFjaCBtdXRhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gdGhlIHByb3ZpZGVkIG1vZGVsIGluc3RhbmNlLCBvciB0byBhbnkgb2YgaXRzIGNoaWxkcmVuLlxuICogU2VlIFtwYXRjaGVzXShodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngtc3RhdGUtdHJlZSNwYXRjaGVzKSBmb3IgbW9yZSBkZXRhaWxzLiBvblBhdGNoIGV2ZW50cyBhcmUgZW1pdHRlZCBpbW1lZGlhdGVseSBhbmQgd2lsbCBub3QgYXdhaXQgdGhlIGVuZCBvZiBhIHRyYW5zYWN0aW9uLlxuICogUGF0Y2hlcyBjYW4gYmUgdXNlZCB0byBkZWVwIG9ic2VydmUgYSBtb2RlbCB0cmVlLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgdGhlIG1vZGVsIGluc3RhbmNlIGZyb20gd2hpY2ggdG8gcmVjZWl2ZSBwYXRjaGVzXG4gKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCBmb3IgZWFjaCBwYXRjaC4gVGhlIHJldmVyc2VQYXRjaCBpcyBhIHBhdGNoIHRoYXQgd291bGQgYWN0dWFsbHkgdW5kbyB0aGUgZW1pdHRlZCBwYXRjaFxuICogQHJldHVybnMgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICovXG5mdW5jdGlvbiBvblBhdGNoKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gICAgYXNzZXJ0SXNGdW5jdGlvbihjYWxsYmFjaywgMik7XG4gICAgcmV0dXJuIGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5vblBhdGNoKGNhbGxiYWNrKTtcbn1cbi8qKlxuICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIHdoZW5ldmVyIGEgbmV3IHNuYXBzaG90IGZvciB0aGUgZ2l2ZW4gbW9kZWwgaW5zdGFuY2UgaXMgYXZhaWxhYmxlLlxuICogVGhlIGxpc3RlbmVyIHdpbGwgb25seSBiZSBmaXJlIGF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgTW9iWCAodHJhbnMpYWN0aW9uLlxuICogU2VlIFtzbmFwc2hvdHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1zdGF0ZS10cmVlI3NuYXBzaG90cykgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIG9uU25hcHNob3QodGFyZ2V0LCBjYWxsYmFjaykge1xuICAgIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodGFyZ2V0LCAxKTtcbiAgICBhc3NlcnRJc0Z1bmN0aW9uKGNhbGxiYWNrLCAyKTtcbiAgICByZXR1cm4gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpLm9uU25hcHNob3QoY2FsbGJhY2spO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgSlNPTi1wYXRjaCB0byB0aGUgZ2l2ZW4gbW9kZWwgaW5zdGFuY2Ugb3IgYmFpbHMgb3V0IGlmIHRoZSBwYXRjaCBjb3VsZG4ndCBiZSBhcHBsaWVkXG4gKiBTZWUgW3BhdGNoZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1zdGF0ZS10cmVlI3BhdGNoZXMpIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQ2FuIGFwcGx5IGEgc2luZ2xlIHBhc3QsIG9yIGFuIGFycmF5IG9mIHBhdGNoZXMuXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIHBhdGNoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBhcHBseVBhdGNoKHRhcmdldCwgcGF0Y2gpIHtcbiAgICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gICAgYXNzZXJ0QXJnKHBhdGNoLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gdHlwZW9mIHAgPT09IFwib2JqZWN0XCI7IH0sIFwib2JqZWN0IG9yIGFycmF5XCIsIDIpO1xuICAgIGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5hcHBseVBhdGNoZXMoYXNBcnJheShwYXRjaCkpO1xufVxuLyoqXG4gKiBTbWFsbCBhYnN0cmFjdGlvbiBhcm91bmQgYG9uUGF0Y2hgIGFuZCBgYXBwbHlQYXRjaGAsIGF0dGFjaGVzIGEgcGF0Y2ggbGlzdGVuZXIgdG8gYSB0cmVlIGFuZCByZWNvcmRzIGFsbCB0aGUgcGF0Y2hlcy5cbiAqIFJldHVybnMgYW4gcmVjb3JkZXIgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBleHBvcnQgaW50ZXJmYWNlIElQYXRjaFJlY29yZGVyIHtcbiAqICAgICAgLy8gdGhlIHJlY29yZGVkIHBhdGNoZXNcbiAqICAgICAgcGF0Y2hlczogSUpzb25QYXRjaFtdXG4gKiAgICAgIC8vIHRoZSBpbnZlcnNlIG9mIHRoZSByZWNvcmRlZCBwYXRjaGVzXG4gKiAgICAgIGludmVyc2VQYXRjaGVzOiBJSnNvblBhdGNoW11cbiAqICAgICAgLy8gdHJ1ZSBpZiBjdXJyZW50bHkgcmVjb3JkaW5nXG4gKiAgICAgIHJlY29yZGluZzogYm9vbGVhblxuICogICAgICAvLyBzdG9wIHJlY29yZGluZyBwYXRjaGVzXG4gKiAgICAgIHN0b3AoKTogdm9pZFxuICogICAgICAvLyByZXN1bWUgcmVjb3JkaW5nIHBhdGNoZXNcbiAqICAgICAgcmVzdW1lKCk6IHZvaWRcbiAqICAgICAgLy8gYXBwbHkgYWxsIHRoZSByZWNvcmRlZCBwYXRjaGVzIG9uIHRoZSBnaXZlbiB0YXJnZXQgKHRoZSBvcmlnaW5hbCBzdWJqZWN0IGlmIG9taXR0ZWQpXG4gKiAgICAgIHJlcGxheSh0YXJnZXQ/OiBJQW55U3RhdGVUcmVlTm9kZSk6IHZvaWRcbiAqICAgICAgLy8gcmV2ZXJzZSBhcHBseSB0aGUgcmVjb3JkZWQgcGF0Y2hlcyBvbiB0aGUgZ2l2ZW4gdGFyZ2V0ICAodGhlIG9yaWdpbmFsIHN1YmplY3QgaWYgb21pdHRlZClcbiAqICAgICAgLy8gc3RvcHMgdGhlIHJlY29yZGVyIGlmIG5vdCBhbHJlYWR5IHN0b3BwZWRcbiAqICAgICAgdW5kbygpOiB2b2lkXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGUgb3B0aW9uYWwgZmlsdGVyIGZ1bmN0aW9uIGFsbG93cyB0byBza2lwIHJlY29yZGluZyBjZXJ0YWluIHBhdGNoZXMuXG4gKlxuICogQHBhcmFtIHN1YmplY3RcbiAqIEBwYXJhbSBmaWx0ZXJcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHJlY29yZFBhdGNoZXMoc3ViamVjdCwgZmlsdGVyKSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZShzdWJqZWN0LCAxKTtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgcGF0Y2hlczogW10sXG4gICAgICAgIHJldmVyc2VkSW52ZXJzZVBhdGNoZXM6IFtdXG4gICAgfTtcbiAgICAvLyB3ZSB3aWxsIGdlbmVyYXRlIHRoZSBpbW11dGFibGUgY29weSBvZiBwYXRjaGVzIG9uIGRlbWFuZCBmb3IgcHVibGljIGNvbnN1bXB0aW9uXG4gICAgdmFyIHB1YmxpY0RhdGEgPSB7fTtcbiAgICB2YXIgZGlzcG9zZXI7XG4gICAgdmFyIHJlY29yZGVyID0ge1xuICAgICAgICBnZXQgcmVjb3JkaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhZGlzcG9zZXI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBwYXRjaGVzKCkge1xuICAgICAgICAgICAgaWYgKCFwdWJsaWNEYXRhLnBhdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBwdWJsaWNEYXRhLnBhdGNoZXMgPSBkYXRhLnBhdGNoZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdWJsaWNEYXRhLnBhdGNoZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCByZXZlcnNlZEludmVyc2VQYXRjaGVzKCkge1xuICAgICAgICAgICAgaWYgKCFwdWJsaWNEYXRhLnJldmVyc2VkSW52ZXJzZVBhdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBwdWJsaWNEYXRhLnJldmVyc2VkSW52ZXJzZVBhdGNoZXMgPSBkYXRhLnJldmVyc2VkSW52ZXJzZVBhdGNoZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwdWJsaWNEYXRhLnJldmVyc2VkSW52ZXJzZVBhdGNoZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpbnZlcnNlUGF0Y2hlcygpIHtcbiAgICAgICAgICAgIGlmICghcHVibGljRGF0YS5pbnZlcnNlUGF0Y2hlcykge1xuICAgICAgICAgICAgICAgIHB1YmxpY0RhdGEuaW52ZXJzZVBhdGNoZXMgPSBkYXRhLnJldmVyc2VkSW52ZXJzZVBhdGNoZXMuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHVibGljRGF0YS5pbnZlcnNlUGF0Y2hlcztcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRpc3Bvc2VyKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zZXIoKTtcbiAgICAgICAgICAgICAgICBkaXNwb3NlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZGlzcG9zZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGlzcG9zZXIgPSBvblBhdGNoKHN1YmplY3QsIGZ1bmN0aW9uIChwYXRjaCwgaW52ZXJzZVBhdGNoKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBwYXRjaGVzIHRoYXQgYXJlIGFza2VkIHRvIGJlIGZpbHRlcmVkIGlmIHRoZXJlJ3MgYSBmaWx0ZXIgaW4gcGxhY2VcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIocGF0Y2gsIGludmVyc2VQYXRjaCwgZ2V0UnVubmluZ0FjdGlvbkNvbnRleHQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLnBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgICAgICAgICAgZGF0YS5yZXZlcnNlZEludmVyc2VQYXRjaGVzLnVuc2hpZnQoaW52ZXJzZVBhdGNoKTtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGltbXV0YWJsZSBwdWJsaWMgcGF0Y2hlcyBhcyBkaXJ0eVxuICAgICAgICAgICAgICAgIHB1YmxpY0RhdGEucGF0Y2hlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBwdWJsaWNEYXRhLmludmVyc2VQYXRjaGVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHB1YmxpY0RhdGEucmV2ZXJzZWRJbnZlcnNlUGF0Y2hlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICByZXBsYXk6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGFwcGx5UGF0Y2godGFyZ2V0IHx8IHN1YmplY3QsIGRhdGEucGF0Y2hlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGFwcGx5UGF0Y2godGFyZ2V0IHx8IHN1YmplY3QsIGRhdGEucmV2ZXJzZWRJbnZlcnNlUGF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlY29yZGVyLnJlc3VtZSgpO1xuICAgIHJldHVybiByZWNvcmRlcjtcbn1cbi8qKlxuICogVGhlIGludmVyc2Ugb2YgYHVucHJvdGVjdGAuXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICovXG5mdW5jdGlvbiBwcm90ZWN0KHRhcmdldCkge1xuICAgIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodGFyZ2V0LCAxKTtcbiAgICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KTtcbiAgICBpZiAoIW5vZGUuaXNSb290KVxuICAgICAgICB0aHJvdyBmYWlsJDEoXCJgcHJvdGVjdGAgY2FuIG9ubHkgYmUgaW52b2tlZCBvbiByb290IG5vZGVzXCIpO1xuICAgIG5vZGUuaXNQcm90ZWN0aW9uRW5hYmxlZCA9IHRydWU7XG59XG4vKipcbiAqIEJ5IGRlZmF1bHQgaXQgaXMgbm90IGFsbG93ZWQgdG8gZGlyZWN0bHkgbW9kaWZ5IGEgbW9kZWwuIE1vZGVscyBjYW4gb25seSBiZSBtb2RpZmllZCB0aHJvdWdoIGFjdGlvbnMuXG4gKiBIb3dldmVyLCBpbiBzb21lIGNhc2VzIHlvdSBkb24ndCBjYXJlIGFib3V0IHRoZSBhZHZhbnRhZ2VzIChsaWtlIHJlcGxheWFiaWxpdHksIHRyYWNlYWJpbGl0eSwgZXRjKSB0aGlzIHlpZWxkcy5cbiAqIEZvciBleGFtcGxlIGJlY2F1c2UgeW91IGFyZSBidWlsZGluZyBhIFBvQyBvciBkb24ndCBoYXZlIGFueSBtaWRkbGV3YXJlIGF0dGFjaGVkIHRvIHlvdXIgdHJlZS5cbiAqXG4gKiBJbiB0aGF0IGNhc2UgeW91IGNhbiBkaXNhYmxlIHRoaXMgcHJvdGVjdGlvbiBieSBjYWxsaW5nIGB1bnByb3RlY3RgIG9uIHRoZSByb290IG9mIHlvdXIgdHJlZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IFRvZG8gPSB0eXBlcy5tb2RlbCh7XG4gKiAgICAgZG9uZTogZmFsc2VcbiAqIH0pLmFjdGlvbnMoc2VsZiA9PiAoe1xuICogICAgIHRvZ2dsZSgpIHtcbiAqICAgICAgICAgc2VsZi5kb25lID0gIXNlbGYuZG9uZVxuICogICAgIH1cbiAqIH0pKVxuICpcbiAqIGNvbnN0IHRvZG8gPSBUb2RvLmNyZWF0ZSgpXG4gKiB0b2RvLmRvbmUgPSB0cnVlIC8vIHRocm93cyFcbiAqIHRvZG8udG9nZ2xlKCkgLy8gT0tcbiAqIHVucHJvdGVjdCh0b2RvKVxuICogdG9kby5kb25lID0gZmFsc2UgLy8gT0tcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1bnByb3RlY3QodGFyZ2V0KSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICAgIHZhciBub2RlID0gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpO1xuICAgIGlmICghbm9kZS5pc1Jvb3QpXG4gICAgICAgIHRocm93IGZhaWwkMShcImB1bnByb3RlY3RgIGNhbiBvbmx5IGJlIGludm9rZWQgb24gcm9vdCBub2Rlc1wiKTtcbiAgICBub2RlLmlzUHJvdGVjdGlvbkVuYWJsZWQgPSBmYWxzZTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgaW4gcHJvdGVjdGVkIG1vZGUsIEBzZWUgcHJvdGVjdFxuICovXG5mdW5jdGlvbiBpc1Byb3RlY3RlZCh0YXJnZXQpIHtcbiAgICByZXR1cm4gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpLmlzUHJvdGVjdGVkO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgc25hcHNob3QgdG8gYSBnaXZlbiBtb2RlbCBpbnN0YW5jZXMuIFBhdGNoIGFuZCBzbmFwc2hvdCBsaXN0ZW5lcnMgd2lsbCBiZSBpbnZva2VkIGFzIHVzdWFsLlxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSBzbmFwc2hvdFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTbmFwc2hvdCh0YXJnZXQsIHNuYXBzaG90KSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICAgIHJldHVybiBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkuYXBwbHlTbmFwc2hvdChzbmFwc2hvdCk7XG59XG4vKipcbiAqIENhbGN1bGF0ZXMgYSBzbmFwc2hvdCBmcm9tIHRoZSBnaXZlbiBtb2RlbCBpbnN0YW5jZS4gVGhlIHNuYXBzaG90IHdpbGwgYWx3YXlzIHJlZmxlY3QgdGhlIGxhdGVzdCBzdGF0ZSBidXQgdXNlXG4gKiBzdHJ1Y3R1cmFsIHNoYXJpbmcgd2hlcmUgcG9zc2libGUuIERvZXNuJ3QgcmVxdWlyZSBNb2JYIHRyYW5zYWN0aW9ucyB0byBiZSBjb21wbGV0ZWQuXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIGFwcGx5UG9zdFByb2Nlc3MgSWYgdHJ1ZSAodGhlIGRlZmF1bHQpIHRoZW4gcG9zdFByb2Nlc3NTbmFwc2hvdCBnZXRzIGFwcGxpZWQuXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRTbmFwc2hvdCh0YXJnZXQsIGFwcGx5UG9zdFByb2Nlc3MpIHtcbiAgICBpZiAoYXBwbHlQb3N0UHJvY2VzcyA9PT0gdm9pZCAwKSB7IGFwcGx5UG9zdFByb2Nlc3MgPSB0cnVlOyB9XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICAgIHZhciBub2RlID0gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpO1xuICAgIGlmIChhcHBseVBvc3RQcm9jZXNzKVxuICAgICAgICByZXR1cm4gbm9kZS5zbmFwc2hvdDtcbiAgICByZXR1cm4gZnJlZXplKG5vZGUudHlwZS5nZXRTbmFwc2hvdChub2RlLCBmYWxzZSkpO1xufVxuLyoqXG4gKiBHaXZlbiBhIG1vZGVsIGluc3RhbmNlLCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0IGhhcyBhIHBhcmVudCwgdGhhdCBpcywgaXMgcGFydCBvZiBhbm90aGVyIG9iamVjdCwgbWFwIG9yIGFycmF5LlxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSBkZXB0aCBIb3cgZmFyIHNob3VsZCB3ZSBsb29rIHVwd2FyZD8gMSBieSBkZWZhdWx0LlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KHRhcmdldCwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkgeyBkZXB0aCA9IDE7IH1cbiAgICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gICAgYXNzZXJ0SXNOdW1iZXIoZGVwdGgsIDIsIDApO1xuICAgIHZhciBwYXJlbnQgPSBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKC0tZGVwdGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbW1lZGlhdGUgcGFyZW50IG9mIHRoaXMgb2JqZWN0LCBvciB0aHJvd3MuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBpbW1lZGlhdGUgcGFyZW50IGNhbiBiZSBlaXRoZXIgYW4gb2JqZWN0LCBtYXAgb3IgYXJyYXksIGFuZFxuICogZG9lc24ndCBuZWNlc3NhcmlseSByZWZlciB0byB0aGUgcGFyZW50IG1vZGVsLlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgaW4gY2hpbGQgbm9kZXMgYWNjZXNzIHRvIHRoZSByb290IGlzIG9ubHkgcG9zc2libGVcbiAqIG9uY2UgdGhlIGBhZnRlckF0dGFjaGAgaG9vayBoYXMgZmlyZWQuXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIGRlcHRoIEhvdyBmYXIgc2hvdWxkIHdlIGxvb2sgdXB3YXJkPyAxIGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRQYXJlbnQodGFyZ2V0LCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gdm9pZCAwKSB7IGRlcHRoID0gMTsgfVxuICAgIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodGFyZ2V0LCAxKTtcbiAgICBhc3NlcnRJc051bWJlcihkZXB0aCwgMiwgMCk7XG4gICAgdmFyIGQgPSBkZXB0aDtcbiAgICB2YXIgcGFyZW50ID0gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmICgtLWQgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LnN0b3JlZFZhbHVlO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICB0aHJvdyBmYWlsJDEoXCJGYWlsZWQgdG8gZmluZCB0aGUgcGFyZW50IG9mIFwiICsgZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpICsgXCIgYXQgZGVwdGggXCIgKyBkZXB0aCk7XG59XG4vKipcbiAqIEdpdmVuIGEgbW9kZWwgaW5zdGFuY2UsIHJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgaGFzIGEgcGFyZW50IG9mIGdpdmVuIHR5cGUsIHRoYXQgaXMsIGlzIHBhcnQgb2YgYW5vdGhlciBvYmplY3QsIG1hcCBvciBhcnJheVxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBoYXNQYXJlbnRPZlR5cGUodGFyZ2V0LCB0eXBlKSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICAgIGFzc2VydElzVHlwZSh0eXBlLCAyKTtcbiAgICB2YXIgcGFyZW50ID0gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmICh0eXBlLmlzKHBhcmVudC5zdG9yZWRWYWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0YXJnZXQncyBwYXJlbnQgb2YgYSBnaXZlbiB0eXBlLCBvciB0aHJvd3MuXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE9mVHlwZSh0YXJnZXQsIHR5cGUpIHtcbiAgICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gICAgYXNzZXJ0SXNUeXBlKHR5cGUsIDIpO1xuICAgIHZhciBwYXJlbnQgPSBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHR5cGUuaXMocGFyZW50LnN0b3JlZFZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuc3RvcmVkVmFsdWU7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHRocm93IGZhaWwkMShcIkZhaWxlZCB0byBmaW5kIHRoZSBwYXJlbnQgb2YgXCIgKyBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkgKyBcIiBvZiBhIGdpdmVuIHR5cGVcIik7XG59XG4vKipcbiAqIEdpdmVuIGFuIG9iamVjdCBpbiBhIG1vZGVsIHRyZWUsIHJldHVybnMgdGhlIHJvb3Qgb2JqZWN0IG9mIHRoYXQgdHJlZS5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IGluIGNoaWxkIG5vZGVzIGFjY2VzcyB0byB0aGUgcm9vdCBpcyBvbmx5IHBvc3NpYmxlXG4gKiBvbmNlIHRoZSBgYWZ0ZXJBdHRhY2hgIGhvb2sgaGFzIGZpcmVkLlxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3QodGFyZ2V0KSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICAgIHJldHVybiBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkucm9vdC5zdG9yZWRWYWx1ZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgcGF0aCBvZiB0aGUgZ2l2ZW4gb2JqZWN0IGluIHRoZSBtb2RlbCB0cmVlXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0UGF0aCh0YXJnZXQpIHtcbiAgICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gICAgcmV0dXJuIGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5wYXRoO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXRoIG9mIHRoZSBnaXZlbiBvYmplY3QgYXMgdW5lc2NhcGVkIHN0cmluZyBhcnJheS5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRQYXRoUGFydHModGFyZ2V0KSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICAgIHJldHVybiBzcGxpdEpzb25QYXRoKGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5wYXRoKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgdGhlIHJvb3Qgb2YgYSBtb2RlbCB0cmVlLlxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlzUm9vdCh0YXJnZXQpIHtcbiAgICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gICAgcmV0dXJuIGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5pc1Jvb3Q7XG59XG4vKipcbiAqIFJlc29sdmVzIGEgcGF0aCByZWxhdGl2ZWx5IHRvIGEgZ2l2ZW4gb2JqZWN0LlxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgbm8gdmFsdWUgY2FuIGJlIGZvdW5kLlxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSBwYXRoIGVzY2FwZWQganNvbiBwYXRoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiByZXNvbHZlUGF0aCh0YXJnZXQsIHBhdGgpIHtcbiAgICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gICAgYXNzZXJ0SXNTdHJpbmcocGF0aCwgMik7XG4gICAgdmFyIG5vZGUgPSByZXNvbHZlTm9kZUJ5UGF0aChnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCksIHBhdGgpO1xuICAgIHJldHVybiBub2RlID8gbm9kZS52YWx1ZSA6IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogUmVzb2x2ZXMgYSBtb2RlbCBpbnN0YW5jZSBnaXZlbiBhIHJvb3QgdGFyZ2V0LCB0aGUgdHlwZSBhbmQgdGhlIGlkZW50aWZpZXIgeW91IGFyZSBzZWFyY2hpbmcgZm9yLlxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgbm8gdmFsdWUgY2FuIGJlIGZvdW5kLlxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gaWRlbnRpZmllclxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUlkZW50aWZpZXIodHlwZSwgdGFyZ2V0LCBpZGVudGlmaWVyKSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzVHlwZSh0eXBlLCAxKTtcbiAgICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodGFyZ2V0LCAyKTtcbiAgICBhc3NlcnRJc1ZhbGlkSWRlbnRpZmllcihpZGVudGlmaWVyLCAzKTtcbiAgICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5yb290LmlkZW50aWZpZXJDYWNoZS5yZXNvbHZlKHR5cGUsIG5vcm1hbGl6ZUlkZW50aWZpZXIoaWRlbnRpZmllcikpO1xuICAgIHJldHVybiBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUudmFsdWU7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldCBub2RlLlxuICogVGhpcyBpcyB0aGUgKnN0cmluZyBub3JtYWxpemVkKiBpZGVudGlmaWVyLCB3aGljaCBtaWdodCBub3QgbWF0Y2ggdGhlIHR5cGUgb2YgdGhlIGlkZW50aWZpZXIgYXR0cmlidXRlXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0SWRlbnRpZmllcih0YXJnZXQpIHtcbiAgICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gICAgcmV0dXJuIGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5pZGVudGlmaWVyO1xufVxuLyoqXG4gKiBUZXN0cyBpZiBhIHJlZmVyZW5jZSBpcyB2YWxpZCAocG9pbnRpbmcgdG8gYW4gZXhpc3Rpbmcgbm9kZSBhbmQgb3B0aW9uYWxseSBpZiBhbGl2ZSkgYW5kIHJldHVybnMgc3VjaCByZWZlcmVuY2UgaWYgaXQgdGhlIGNoZWNrIHBhc3NlcyxcbiAqIGVsc2UgaXQgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIGdldHRlciBGdW5jdGlvbiB0byBhY2Nlc3MgdGhlIHJlZmVyZW5jZS5cbiAqIEBwYXJhbSBjaGVja0lmQWxpdmUgdHJ1ZSB0byBhbHNvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlZCBub2RlIGlzIGFsaXZlIChkZWZhdWx0KSwgZmFsc2UgdG8gc2tpcCB0aGlzIGNoZWNrLlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gdHJ5UmVmZXJlbmNlKGdldHRlciwgY2hlY2tJZkFsaXZlKSB7XG4gICAgaWYgKGNoZWNrSWZBbGl2ZSA9PT0gdm9pZCAwKSB7IGNoZWNrSWZBbGl2ZSA9IHRydWU7IH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgbm9kZSA9IGdldHRlcigpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdGF0ZVRyZWVOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrSWZBbGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQWxpdmUobm9kZSkgPyBub2RlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiVGhlIHJlZmVyZW5jZSB0byBiZSBjaGVja2VkIGlzIG5vdCBvbmUgb2Ygbm9kZSwgbnVsbCBvciB1bmRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBJbnZhbGlkUmVmZXJlbmNlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG4vKipcbiAqIFRlc3RzIGlmIGEgcmVmZXJlbmNlIGlzIHZhbGlkIChwb2ludGluZyB0byBhbiBleGlzdGluZyBub2RlIGFuZCBvcHRpb25hbGx5IGlmIGFsaXZlKSBhbmQgcmV0dXJucyBpZiB0aGUgY2hlY2sgcGFzc2VzIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gZ2V0dGVyIEZ1bmN0aW9uIHRvIGFjY2VzcyB0aGUgcmVmZXJlbmNlLlxuICogQHBhcmFtIGNoZWNrSWZBbGl2ZSB0cnVlIHRvIGFsc28gbWFrZSBzdXJlIHRoZSByZWZlcmVuY2VkIG5vZGUgaXMgYWxpdmUgKGRlZmF1bHQpLCBmYWxzZSB0byBza2lwIHRoaXMgY2hlY2suXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkUmVmZXJlbmNlKGdldHRlciwgY2hlY2tJZkFsaXZlKSB7XG4gICAgaWYgKGNoZWNrSWZBbGl2ZSA9PT0gdm9pZCAwKSB7IGNoZWNrSWZBbGl2ZSA9IHRydWU7IH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgbm9kZSA9IGdldHRlcigpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N0YXRlVHJlZU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja0lmQWxpdmUgPyBpc0FsaXZlKG5vZGUpIDogdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwkMShcIlRoZSByZWZlcmVuY2UgdG8gYmUgY2hlY2tlZCBpcyBub3Qgb25lIG9mIG5vZGUsIG51bGwgb3IgdW5kZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgSW52YWxpZFJlZmVyZW5jZUVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG4vKipcbiAqIFRyeSB0byByZXNvbHZlIGEgZ2l2ZW4gcGF0aCByZWxhdGl2ZSB0byBhIGdpdmVuIG5vZGUuXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIHBhdGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHRyeVJlc29sdmUodGFyZ2V0LCBwYXRoKSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICAgIGFzc2VydElzU3RyaW5nKHBhdGgsIDIpO1xuICAgIHZhciBub2RlID0gcmVzb2x2ZU5vZGVCeVBhdGgoZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpLCBwYXRoLCBmYWxzZSk7XG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRm9yIHdoYXQgZXZlciByZWFzb24gbm90IHJlc29sdmFibGUgKGUuZy4gdG90YWxseSBub3QgZXhpc3RpbmcgcGF0aCwgb3IgdmFsdWUgdGhhdCBjYW5ub3QgYmUgZmV0Y2hlZClcbiAgICAgICAgLy8gc2VlIHRlc3QgLyBpc3N1ZTogJ3RyeSByZXNvbHZlIGRvZXNuJ3Qgd29yayAjNjg2J1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogR2l2ZW4gdHdvIHN0YXRlIHRyZWUgbm9kZXMgdGhhdCBhcmUgcGFydCBvZiB0aGUgc2FtZSB0cmVlLFxuICogcmV0dXJucyB0aGUgc2hvcnRlc3QganNvbnBhdGggbmVlZGVkIHRvIG5hdmlnYXRlIGZyb20gdGhlIG9uZSB0byB0aGUgb3RoZXJcbiAqXG4gKiBAcGFyYW0gYmFzZVxuICogQHBhcmFtIHRhcmdldFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQYXRoKGJhc2UsIHRhcmdldCkge1xuICAgIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUoYmFzZSwgMSk7XG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMik7XG4gICAgcmV0dXJuIGdldFJlbGF0aXZlUGF0aEJldHdlZW5Ob2RlcyhnZXRTdGF0ZVRyZWVOb2RlKGJhc2UpLCBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSBnaXZlbiBzdGF0ZSB0cmVlIG5vZGUgYXMgbmV3IHRyZWUuXG4gKiBTaG9ydCBoYW5kIGZvciBgc25hcHNob3QoeCkgPSBnZXRUeXBlKHgpLmNyZWF0ZShnZXRTbmFwc2hvdCh4KSlgXG4gKlxuICogX1RpcDogY2xvbmUgd2lsbCBjcmVhdGUgYSBsaXRlcmFsIGNvcHksIGluY2x1ZGluZyB0aGUgc2FtZSBpZGVudGlmaWVycy4gVG8gbW9kaWZ5IGlkZW50aWZpZXJzIGV0YyBkdXJpbmcgY2xvbmluZywgZG9uJ3QgdXNlIGNsb25lIGJ1dCB0YWtlIGEgc25hcHNob3Qgb2YgdGhlIHRyZWUsIG1vZGlmeSBpdCwgYW5kIGNyZWF0ZSBuZXcgaW5zdGFuY2VfXG4gKlxuICogQHBhcmFtIHNvdXJjZVxuICogQHBhcmFtIGtlZXBFbnZpcm9ubWVudCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgY2xvbmUgc2hvdWxkIGluaGVyaXQgdGhlIHNhbWUgZW52aXJvbm1lbnQgKGB0cnVlYCwgdGhlIGRlZmF1bHQpLCBvciBub3QgaGF2ZSBhbiBlbnZpcm9ubWVudCAoYGZhbHNlYCkuIElmIGFuIG9iamVjdCBpcyBwYXNzZWQgaW4gYXMgc2Vjb25kIGFyZ3VtZW50LCB0aGF0IHdpbGwgYWN0IGFzIHRoZSBlbnZpcm9ubWVudCBmb3IgdGhlIGNsb25lZCB0cmVlLlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gY2xvbmUoc291cmNlLCBrZWVwRW52aXJvbm1lbnQpIHtcbiAgICBpZiAoa2VlcEVudmlyb25tZW50ID09PSB2b2lkIDApIHsga2VlcEVudmlyb25tZW50ID0gdHJ1ZTsgfVxuICAgIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUoc291cmNlLCAxKTtcbiAgICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUoc291cmNlKTtcbiAgICByZXR1cm4gbm9kZS50eXBlLmNyZWF0ZShub2RlLnNuYXBzaG90LCBrZWVwRW52aXJvbm1lbnQgPT09IHRydWVcbiAgICAgICAgPyBub2RlLnJvb3QuZW52aXJvbm1lbnRcbiAgICAgICAgOiBrZWVwRW52aXJvbm1lbnQgPT09IGZhbHNlXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBrZWVwRW52aXJvbm1lbnQpOyAvLyBpdCdzIGFuIG9iamVjdCBvciBzb21ldGhpbmcgZWxzZVxufVxuLyoqXG4gKiBSZW1vdmVzIGEgbW9kZWwgZWxlbWVudCBmcm9tIHRoZSBzdGF0ZSB0cmVlLCBhbmQgbGV0IGl0IGxpdmUgb24gYXMgYSBuZXcgc3RhdGUgdHJlZVxuICovXG5mdW5jdGlvbiBkZXRhY2godGFyZ2V0KSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICAgIGdldFN0YXRlVHJlZU5vZGUodGFyZ2V0KS5kZXRhY2goKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuLyoqXG4gKiBSZW1vdmVzIGEgbW9kZWwgZWxlbWVudCBmcm9tIHRoZSBzdGF0ZSB0cmVlLCBhbmQgbWFyayBpdCBhcyBlbmQtb2YtbGlmZTsgdGhlIGVsZW1lbnQgc2hvdWxkIG5vdCBiZSB1c2VkIGFueW1vcmVcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSh0YXJnZXQpIHtcbiAgICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gICAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCk7XG4gICAgaWYgKG5vZGUuaXNSb290KVxuICAgICAgICBub2RlLmRpZSgpO1xuICAgIGVsc2VcbiAgICAgICAgbm9kZS5wYXJlbnQucmVtb3ZlQ2hpbGQobm9kZS5zdWJwYXRoKTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBzdGF0ZSB0cmVlIG5vZGUgaXMgbm90IGtpbGxlZCB5ZXQuXG4gKiBUaGlzIG1lYW5zIHRoYXQgdGhlIG5vZGUgaXMgc3RpbGwgYSBwYXJ0IG9mIGEgdHJlZSwgYW5kIHRoYXQgYGRlc3Ryb3lgXG4gKiBoYXMgbm90IGJlZW4gY2FsbGVkLiBJZiBhIG5vZGUgaXMgbm90IGFsaXZlIGFueW1vcmUsIHRoZSBvbmx5IHRoaW5nIG9uZSBjYW4gZG8gd2l0aCBpdFxuICogaXMgcmVxdWVzdGluZyBpdCdzIGxhc3QgcGF0aCBhbmQgc25hcHNob3RcbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0FsaXZlKHRhcmdldCkge1xuICAgIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodGFyZ2V0LCAxKTtcbiAgICByZXR1cm4gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpLm9ic2VydmFibGVJc0FsaXZlO1xufVxuLyoqXG4gKiBVc2UgdGhpcyB1dGlsaXR5IHRvIHJlZ2lzdGVyIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZVxuICogdGFyZ2V0ZWQgc3RhdGUgdHJlZSBub2RlIGlzIGRlc3Ryb3llZC4gVGhpcyBpcyBhIHVzZWZ1bCBhbHRlcm5hdGl2ZSB0byBtYW5hZ2luZ1xuICogY2xlYW51cCBtZXRob2RzIHlvdXJzZWxmIHVzaW5nIHRoZSBgYmVmb3JlRGVzdHJveWAgaG9vay5cbiAqXG4gKiBUaGlzIG1ldGhvZHMgcmV0dXJucyB0aGUgc2FtZSBkaXNwb3NlciB0aGF0IHdhcyBwYXNzZWQgYXMgYXJndW1lbnQuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBUb2RvID0gdHlwZXMubW9kZWwoe1xuICogICB0aXRsZTogdHlwZXMuc3RyaW5nXG4gKiB9KS5hY3Rpb25zKHNlbGYgPT4gKHtcbiAqICAgYWZ0ZXJDcmVhdGUoKSB7XG4gKiAgICAgY29uc3QgYXV0b1NhdmVEaXNwb3NlciA9IHJlYWN0aW9uKFxuICogICAgICAgKCkgPT4gZ2V0U25hcHNob3Qoc2VsZiksXG4gKiAgICAgICBzbmFwc2hvdCA9PiBzZW5kU25hcHNob3RUb1NlcnZlclNvbWVob3coc25hcHNob3QpXG4gKiAgICAgKVxuICogICAgIC8vIHN0b3Agc2VuZGluZyB1cGRhdGVzIHRvIHNlcnZlciBpZiB0aGlzXG4gKiAgICAgLy8gaW5zdGFuY2UgaXMgZGVzdHJveWVkXG4gKiAgICAgYWRkRGlzcG9zZXIoc2VsZiwgYXV0b1NhdmVEaXNwb3NlcilcbiAqICAgfVxuICogfSkpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gZGlzcG9zZXJcbiAqIEByZXR1cm5zIFRoZSBzYW1lIGRpc3Bvc2VyIHRoYXQgd2FzIHBhc3NlZCBhcyBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBhZGREaXNwb3Nlcih0YXJnZXQsIGRpc3Bvc2VyKSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICAgIGFzc2VydElzRnVuY3Rpb24oZGlzcG9zZXIsIDIpO1xuICAgIHZhciBub2RlID0gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpO1xuICAgIG5vZGUuYWRkRGlzcG9zZXIoZGlzcG9zZXIpO1xuICAgIHJldHVybiBkaXNwb3Nlcjtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZW52aXJvbm1lbnQgb2YgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZS4gRm9yIG1vcmUgaW5mbyBvbiBlbnZpcm9ubWVudHMsXG4gKiBzZWUgW0RlcGVuZGVuY3kgaW5qZWN0aW9uXShodHRwczovL2dpdGh1Yi5jb20vbW9ieGpzL21vYngtc3RhdGUtdHJlZSNkZXBlbmRlbmN5LWluamVjdGlvbilcbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IGluIGNoaWxkIG5vZGVzIGFjY2VzcyB0byB0aGUgcm9vdCBpcyBvbmx5IHBvc3NpYmxlXG4gKiBvbmNlIHRoZSBgYWZ0ZXJBdHRhY2hgIGhvb2sgaGFzIGZpcmVkXG4gKlxuICogUmV0dXJucyBhbiBlbXB0eSBlbnZpcm9ubWVudCBpZiB0aGUgdHJlZSB3YXNuJ3QgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbnZpcm9ubWVudFxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldEVudih0YXJnZXQpIHtcbiAgICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gICAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCk7XG4gICAgdmFyIGVudiA9IG5vZGUucm9vdC5lbnZpcm9ubWVudDtcbiAgICBpZiAoIWVudilcbiAgICAgICAgcmV0dXJuIEVNUFRZX09CSkVDVDtcbiAgICByZXR1cm4gZW52O1xufVxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlcHRoIGZpcnN0IHdhbGsgdGhyb3VnaCBhIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHdhbGsodGFyZ2V0LCBwcm9jZXNzb3IpIHtcbiAgICAvLyBjaGVjayBhbGwgYXJndW1lbnRzXG4gICAgYXNzZXJ0SXNTdGF0ZVRyZWVOb2RlKHRhcmdldCwgMSk7XG4gICAgYXNzZXJ0SXNGdW5jdGlvbihwcm9jZXNzb3IsIDIpO1xuICAgIHZhciBub2RlID0gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpub191bnVzZWQtdmFyaWFibGVcbiAgICBub2RlLmdldENoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGVUcmVlTm9kZShjaGlsZC5zdG9yZWRWYWx1ZSkpXG4gICAgICAgICAgICB3YWxrKGNoaWxkLnN0b3JlZFZhbHVlLCBwcm9jZXNzb3IpO1xuICAgIH0pO1xuICAgIHByb2Nlc3Nvcihub2RlLnN0b3JlZFZhbHVlKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJlZmxlY3Rpb24gb2YgdGhlIG1vZGVsIHR5cGUgcHJvcGVydGllcyBhbmQgbmFtZSBmb3IgZWl0aGVyIGEgbW9kZWwgdHlwZSBvciBtb2RlbCBub2RlLlxuICpcbiAqIEBwYXJhbSB0eXBlT3JOb2RlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eU1lbWJlcnModHlwZU9yTm9kZSkge1xuICAgIHZhciB0eXBlO1xuICAgIGlmIChpc1N0YXRlVHJlZU5vZGUodHlwZU9yTm9kZSkpIHtcbiAgICAgICAgdHlwZSA9IGdldFR5cGUodHlwZU9yTm9kZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0eXBlID0gdHlwZU9yTm9kZTtcbiAgICB9XG4gICAgYXNzZXJ0QXJnKHR5cGUsIGZ1bmN0aW9uICh0KSB7IHJldHVybiBpc01vZGVsVHlwZSh0KTsgfSwgXCJtb2RlbCB0eXBlIG9yIG1vZGVsIGluc3RhbmNlXCIsIDEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IHR5cGUubmFtZSxcbiAgICAgICAgcHJvcGVydGllczogX19hc3NpZ24oe30sIHR5cGUucHJvcGVydGllcylcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcmVmbGVjdGlvbiBvZiB0aGUgbW9kZWwgbm9kZSwgaW5jbHVkaW5nIG5hbWUsIHByb3BlcnRpZXMsIHZpZXdzLCB2b2xhdGlsZSBhbmQgYWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRNZW1iZXJzKHRhcmdldCkge1xuICAgIHZhciB0eXBlID0gZ2V0U3RhdGVUcmVlTm9kZSh0YXJnZXQpLnR5cGU7XG4gICAgdmFyIHJlZmxlY3RlZCA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRQcm9wZXJ0eU1lbWJlcnModHlwZSkpLCB7IGFjdGlvbnM6IFtdLCB2b2xhdGlsZTogW10sIHZpZXdzOiBbXSB9KTtcbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHJlZmxlY3RlZC5wcm9wZXJ0aWVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvci5nZXQpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbXB1dGVkUHJvcCh0YXJnZXQsIGtleSkpXG4gICAgICAgICAgICAgICAgcmVmbGVjdGVkLnZpZXdzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZWZsZWN0ZWQudm9sYXRpbGUucHVzaChrZXkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLnZhbHVlLl9pc01TVEFjdGlvbiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIHJlZmxlY3RlZC5hY3Rpb25zLnB1c2goa2V5KTtcbiAgICAgICAgZWxzZSBpZiAoaXNPYnNlcnZhYmxlUHJvcCh0YXJnZXQsIGtleSkpXG4gICAgICAgICAgICByZWZsZWN0ZWQudm9sYXRpbGUucHVzaChrZXkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZWZsZWN0ZWQudmlld3MucHVzaChrZXkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZWZsZWN0ZWQ7XG59XG4vKipcbiAqIENhc3RzIGEgbm9kZSBzbmFwc2hvdCBvciBpbnN0YW5jZSB0eXBlIHRvIGFuIGluc3RhbmNlIHR5cGUgc28gaXQgY2FuIGJlIGFzc2lnbmVkIHRvIGEgdHlwZSBpbnN0YW5jZS5cbiAqIE5vdGUgdGhhdCB0aGlzIGlzIGp1c3QgYSBjYXN0IGZvciB0aGUgdHlwZSBzeXN0ZW0sIHRoaXMgaXMsIGl0IHdvbid0IGFjdHVhbGx5IGNvbnZlcnQgYSBzbmFwc2hvdCB0byBhbiBpbnN0YW5jZSxcbiAqIGJ1dCBqdXN0IGZvb2wgdHlwZXNjcmlwdCBpbnRvIHRoaW5raW5nIHNvLlxuICogRWl0aGVyIHdheSwgY2FzdGluZyB3aGVuIG91dHNpZGUgYW4gYXNzaWduYXRpb24gb3BlcmF0aW9uIHdvbid0IGNvbXBpbGUuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBNb2RlbEEgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIG46IHR5cGVzLm51bWJlclxuICogfSkuYWN0aW9ucyhzZWxmID0+ICh7XG4gKiAgIHNldE4oYU51bWJlcjogbnVtYmVyKSB7XG4gKiAgICAgc2VsZi5uID0gYU51bWJlclxuICogICB9XG4gKiB9KSlcbiAqXG4gKiBjb25zdCBNb2RlbEIgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIGlubmVyTW9kZWw6IE1vZGVsQVxuICogfSkuYWN0aW9ucyhzZWxmID0+ICh7XG4gKiAgIHNvbWVBY3Rpb24oKSB7XG4gKiAgICAgLy8gdGhpcyB3aWxsIGFsbG93IHRoZSBjb21waWxlciB0byBhc3NpZ24gYSBzbmFwc2hvdCB0byB0aGUgcHJvcGVydHlcbiAqICAgICBzZWxmLmlubmVyTW9kZWwgPSBjYXN0KHsgYTogNSB9KVxuICogICB9XG4gKiB9KSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzbmFwc2hvdE9ySW5zdGFuY2UgU25hcHNob3Qgb3IgaW5zdGFuY2VcbiAqIEByZXR1cm5zIFRoZSBzYW1lIG9iamVjdCBjYXN0ZWQgYXMgYW4gaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gY2FzdChzbmFwc2hvdE9ySW5zdGFuY2UpIHtcbiAgICByZXR1cm4gc25hcHNob3RPckluc3RhbmNlO1xufVxuLyoqXG4gKiBDYXN0cyBhIG5vZGUgaW5zdGFuY2UgdHlwZSB0byBhbiBzbmFwc2hvdCB0eXBlIHNvIGl0IGNhbiBiZSBhc3NpZ25lZCB0byBhIHR5cGUgc25hcHNob3QgKGUuZy4gdG8gYmUgdXNlZCBpbnNpZGUgYSBjcmVhdGUgY2FsbCkuXG4gKiBOb3RlIHRoYXQgdGhpcyBpcyBqdXN0IGEgY2FzdCBmb3IgdGhlIHR5cGUgc3lzdGVtLCB0aGlzIGlzLCBpdCB3b24ndCBhY3R1YWxseSBjb252ZXJ0IGFuIGluc3RhbmNlIHRvIGEgc25hcHNob3QsXG4gKiBidXQganVzdCBmb29sIHR5cGVzY3JpcHQgaW50byB0aGlua2luZyBzby5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IE1vZGVsQSA9IHR5cGVzLm1vZGVsKHtcbiAqICAgbjogdHlwZXMubnVtYmVyXG4gKiB9KS5hY3Rpb25zKHNlbGYgPT4gKHtcbiAqICAgc2V0TihhTnVtYmVyOiBudW1iZXIpIHtcbiAqICAgICBzZWxmLm4gPSBhTnVtYmVyXG4gKiAgIH1cbiAqIH0pKVxuICpcbiAqIGNvbnN0IE1vZGVsQiA9IHR5cGVzLm1vZGVsKHtcbiAqICAgaW5uZXJNb2RlbDogTW9kZWxBXG4gKiB9KVxuICpcbiAqIGNvbnN0IGEgPSBNb2RlbEEuY3JlYXRlKHsgbjogNSB9KTtcbiAqIC8vIHRoaXMgd2lsbCBhbGxvdyB0aGUgY29tcGlsZXIgdG8gdXNlIGEgbW9kZWwgYXMgaWYgaXQgd2VyZSBhIHNuYXBzaG90XG4gKiBjb25zdCBiID0gTW9kZWxCLmNyZWF0ZSh7IGlubmVyTW9kZWw6IGNhc3RUb1NuYXBzaG90KGEpfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzbmFwc2hvdE9ySW5zdGFuY2UgU25hcHNob3Qgb3IgaW5zdGFuY2VcbiAqIEByZXR1cm5zIFRoZSBzYW1lIG9iamVjdCBjYXN0ZWQgYXMgYW4gaW5wdXQgKGNyZWF0aW9uKSBzbmFwc2hvdFxuICovXG5mdW5jdGlvbiBjYXN0VG9TbmFwc2hvdChzbmFwc2hvdE9ySW5zdGFuY2UpIHtcbiAgICByZXR1cm4gc25hcHNob3RPckluc3RhbmNlO1xufVxuLyoqXG4gKiBDYXN0cyBhIG5vZGUgaW5zdGFuY2UgdHlwZSB0byBhIHJlZmVyZW5jZSBzbmFwc2hvdCB0eXBlIHNvIGl0IGNhbiBiZSBhc3NpZ25lZCB0byBhIHJlZmVybmVuY2Ugc25hcHNob3QgKGUuZy4gdG8gYmUgdXNlZCBpbnNpZGUgYSBjcmVhdGUgY2FsbCkuXG4gKiBOb3RlIHRoYXQgdGhpcyBpcyBqdXN0IGEgY2FzdCBmb3IgdGhlIHR5cGUgc3lzdGVtLCB0aGlzIGlzLCBpdCB3b24ndCBhY3R1YWxseSBjb252ZXJ0IGFuIGluc3RhbmNlIHRvIGEgcmVmZXJlcmVuY2Ugc25hcHNob3QsXG4gKiBidXQganVzdCBmb29sIHR5cGVzY3JpcHQgaW50byB0aGlua2luZyBzby5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IE1vZGVsQSA9IHR5cGVzLm1vZGVsKHtcbiAqICAgaWQ6IHR5cGVzLmlkZW50aWZpZXIsXG4gKiAgIG46IHR5cGVzLm51bWJlclxuICogfSkuYWN0aW9ucyhzZWxmID0+ICh7XG4gKiAgIHNldE4oYU51bWJlcjogbnVtYmVyKSB7XG4gKiAgICAgc2VsZi5uID0gYU51bWJlclxuICogICB9XG4gKiB9KSlcbiAqXG4gKiBjb25zdCBNb2RlbEIgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHJlZkE6IHR5cGVzLnJlZmVyZW5jZShNb2RlbEEpXG4gKiB9KVxuICpcbiAqIGNvbnN0IGEgPSBNb2RlbEEuY3JlYXRlKHsgaWQ6ICdzb21lSWQnLCBuOiA1IH0pO1xuICogLy8gdGhpcyB3aWxsIGFsbG93IHRoZSBjb21waWxlciB0byB1c2UgYSBtb2RlbCBhcyBpZiBpdCB3ZXJlIGEgcmVmZXJlbmNlIHNuYXBzaG90XG4gKiBjb25zdCBiID0gTW9kZWxCLmNyZWF0ZSh7IHJlZkE6IGNhc3RUb1JlZmVyZW5jZVNuYXBzaG90KGEpfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZSBJbnN0YW5jZVxuICogQHJldHVybnMgVGhlIHNhbWUgb2JqZWN0IGNhc3RlZCBhcyBhbiByZWZlcmVuY2Ugc25hcHNob3QgKHN0cmluZyBvciBudW1iZXIpXG4gKi9cbmZ1bmN0aW9uIGNhc3RUb1JlZmVyZW5jZVNuYXBzaG90KGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmlxdWUgbm9kZSBpZCAobm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggdGhlIGluc3RhbmNlIGlkZW50aWZpZXIpIGZvciBhXG4gKiBnaXZlbiBpbnN0YW5jZS5cbiAqIFRoaXMgaWQgaXMgYSBudW1iZXIgdGhhdCBpcyB1bmlxdWUgZm9yIGVhY2ggaW5zdGFuY2UuXG4gKlxuICogQGV4cG9ydFxuICogQHBhcmFtIHRhcmdldFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUlkKHRhcmdldCkge1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICAgIHJldHVybiBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCkubm9kZUlkO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG52YXIgQmFzZU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZU5vZGUodHlwZSwgcGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbnZpcm9ubWVudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZW52aXJvbm1lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9lc2NhcGVkU3VicGF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3VicGF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3VicGF0aFVwb25EZWF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcGF0aFVwb25EZWF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdG9yZWRWYWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pOyAvLyB1c3VhbGx5IHRoZSBzYW1lIHR5cGUgYXMgdGhlIHZhbHVlLCBidXQgbm90IGFsd2F5cyAoc3VjaCBhcyB3aXRoIHJlZmVyZW5jZXMpXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFsaXZlQXRvbVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3RhdGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE5vZGVMaWZlQ3ljbGUuSU5JVElBTElaSU5HXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaG9va1N1YnNjcmliZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9wYXJlbnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGF0aEF0b21cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbnZpcm9ubWVudCA9IGVudmlyb25tZW50O1xuICAgICAgICB0aGlzLmJhc2VTZXRQYXJlbnQocGFyZW50LCBzdWJwYXRoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJzdWJwYXRoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VicGF0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlTm9kZS5wcm90b3R5cGUsIFwic3VicGF0aFVwb25EZWF0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnBhdGhVcG9uRGVhdGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcInBhdGhVcG9uRGVhdGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXRoVXBvbkRlYXRoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5nZXRWYWx1ZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlTm9kZS5wcm90b3R5cGUsIFwic3RhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICB2YXIgd2FzQWxpdmUgPSB0aGlzLmlzQWxpdmU7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHZhbDtcbiAgICAgICAgICAgIHZhciBpc0FsaXZlID0gdGhpcy5pc0FsaXZlO1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxpdmVBdG9tICYmIHdhc0FsaXZlICE9PSBpc0FsaXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGl2ZUF0b20ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJmaXJlSW50ZXJuYWxIb29rXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hvb2tTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hvb2tTdWJzY3JpYmVycy5lbWl0KG5hbWUsIHRoaXMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJyZWdpc3Rlckhvb2tcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChob29rLCBob29rSGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ob29rU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ob29rU3Vic2NyaWJlcnMgPSBuZXcgRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hvb2tTdWJzY3JpYmVycy5yZWdpc3Rlcihob29rLCBob29rSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcInBhcmVudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlTm9kZS5wcm90b3R5cGUsIFwiZ2V0UmVjb25jaWxpYXRpb25UeXBlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJiYXNlU2V0UGFyZW50XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocGFyZW50LCBzdWJwYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl9zdWJwYXRoID0gc3VicGF0aDtcbiAgICAgICAgICAgIHRoaXMuX2VzY2FwZWRTdWJwYXRoID0gdW5kZWZpbmVkOyAvLyByZWdlbmVyYXRlIHdoZW4gbmVlZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5wYXRoQXRvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aEF0b20ucmVwb3J0Q2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgLypcbiAgICAgICAgICogUmV0dXJucyAoZXNjYXBlZCkgcGF0aCByZXByZXNlbnRhdGlvbiBhcyBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXNjYXBlZFBhdGgodHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZU5vZGUucHJvdG90eXBlLCBcImdldEVzY2FwZWRQYXRoXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocmVwb3J0T2JzZXJ2ZWQpIHtcbiAgICAgICAgICAgIGlmIChyZXBvcnRPYnNlcnZlZCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXRoQXRvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGhBdG9tID0gY3JlYXRlQXRvbShcInBhdGhcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGF0aEF0b20ucmVwb3J0T2JzZXJ2ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAvLyByZWdlbmVyYXRlIGVzY2FwZWQgc3VicGF0aCBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmICh0aGlzLl9lc2NhcGVkU3VicGF0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXNjYXBlZFN1YnBhdGggPSAhdGhpcy5fc3VicGF0aCA/IFwiXCIgOiBlc2NhcGVKc29uUGF0aCh0aGlzLl9zdWJwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRFc2NhcGVkUGF0aChyZXBvcnRPYnNlcnZlZCkgKyBcIi9cIiArIHRoaXMuX2VzY2FwZWRTdWJwYXRoO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJpc1Jvb3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudCA9PT0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlTm9kZS5wcm90b3R5cGUsIFwiaXNBbGl2ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgIT09IE5vZGVMaWZlQ3ljbGUuREVBRDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlTm9kZS5wcm90b3R5cGUsIFwiaXNEZXRhY2hpbmdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBOb2RlTGlmZUN5Y2xlLkRFVEFDSElORztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlTm9kZS5wcm90b3R5cGUsIFwib2JzZXJ2YWJsZUlzQWxpdmVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGl2ZUF0b20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsaXZlQXRvbSA9IGNyZWF0ZUF0b20oXCJhbGl2ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWxpdmVBdG9tLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0FsaXZlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VOb2RlLnByb3RvdHlwZSwgXCJiYXNlRmluYWxpemVDcmVhdGlvblwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHdoZW5GaW5hbGl6ZWQpIHtcbiAgICAgICAgICAgIGlmIChkZXZNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNBbGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWlsKFwiYXNzZXJ0aW9uIGZhaWxlZDogY2Fubm90IGZpbmFsaXplIHRoZSBjcmVhdGlvbiBvZiBhIG5vZGUgdGhhdCBpcyBhbHJlYWR5IGRlYWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ29hbDogYWZ0ZXJDcmVhdGUgaG9va3MgcnVucyBkZXB0aC1maXJzdC4gQWZ0ZXIgYXR0YWNoIHJ1bnMgcGFyZW50IGZpcnN0LCBzbyBvbiBhZnRlckF0dGFjaCB0aGUgcGFyZW50IGhhcyBjb21wbGV0ZWQgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IE5vZGVMaWZlQ3ljbGUuQ1JFQVRFRCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuc3RhdGUgIT09IE5vZGVMaWZlQ3ljbGUuRklOQUxJWkVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJlbnQgbm90IHJlYWR5IHlldCwgcG9zdHBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVIb29rKEhvb2suYWZ0ZXJBdHRhY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gTm9kZUxpZmVDeWNsZS5GSU5BTElaRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHdoZW5GaW5hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hlbkZpbmFsaXplZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlTm9kZS5wcm90b3R5cGUsIFwiYmFzZUZpbmFsaXplRGVhdGhcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ob29rU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ob29rU3Vic2NyaWJlcnMuY2xlYXJBbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N1YnBhdGhVcG9uRGVhdGggPSB0aGlzLl9zdWJwYXRoO1xuICAgICAgICAgICAgdGhpcy5fcGF0aFVwb25EZWF0aCA9IHRoaXMuZ2V0RXNjYXBlZFBhdGgoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5iYXNlU2V0UGFyZW50KG51bGwsIFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IE5vZGVMaWZlQ3ljbGUuREVBRDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlTm9kZS5wcm90b3R5cGUsIFwiYmFzZUFib3V0VG9EaWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUhvb2soSG9vay5iZWZvcmVEZXN0cm95KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBCYXNlTm9kZTtcbn0oKSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBTY2FsYXJOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FsYXJOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjYWxhck5vZGUoc2ltcGxlVHlwZSwgcGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFNuYXBzaG90KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNpbXBsZVR5cGUsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQpIHx8IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfdGhpcy5zdG9yZWRWYWx1ZSA9IHNpbXBsZVR5cGUuY3JlYXRlTmV3SW5zdGFuY2UoaW5pdGlhbFNuYXBzaG90KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gc2hvcnQtY3V0IHRvIGRpZSB0aGUgaW5zdGFuY2UsIHRvIGF2b2lkIHRoZSBzbmFwc2hvdCBjb21wdXRlZCBzdGFydGluZyB0byB0aHJvdy4uLlxuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBOb2RlTGlmZUN5Y2xlLkRFQUQ7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLnN0YXRlID0gTm9kZUxpZmVDeWNsZS5DUkVBVEVEO1xuICAgICAgICAvLyBmb3Igc2NhbGFyIG5vZGVzIHRoZXJlJ3Mgbm8gcG9pbnQgaW4gZmlyaW5nIHRoaXMgZXZlbnQgc2luY2UgaXQgd291bGQgZmlyZSBvbiB0aGUgY29uc3RydWN0b3IsIGJlZm9yZVxuICAgICAgICAvLyBhbnlib2R5IGNhbiBhY3R1YWxseSByZWdpc3RlciBmb3IvbGlzdGVuIHRvIGl0XG4gICAgICAgIC8vIHRoaXMuZmlyZUhvb2soSG9vay5BZnRlckNyZWF0ZSlcbiAgICAgICAgX3RoaXMuZmluYWxpemVDcmVhdGlvbigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FsYXJOb2RlLnByb3RvdHlwZSwgXCJyb290XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBmdXR1cmUgb3B0aW1pemF0aW9uOiBzdG9yZSByb290IHJlZiBpbiB0aGUgbm9kZSBhbmQgbWFpbnRhaW4gaXRcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiVGhpcyBzY2FsYXIgbm9kZSBpcyBub3QgcGFydCBvZiBhIHRyZWVcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucm9vdDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FsYXJOb2RlLnByb3RvdHlwZSwgXCJzZXRQYXJlbnRcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChuZXdQYXJlbnQsIHN1YnBhdGgpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDaGFuZ2VkID0gdGhpcy5wYXJlbnQgIT09IG5ld1BhcmVudDtcbiAgICAgICAgICAgIHZhciBzdWJwYXRoQ2hhbmdlZCA9IHRoaXMuc3VicGF0aCAhPT0gc3VicGF0aDtcbiAgICAgICAgICAgIGlmICghcGFyZW50Q2hhbmdlZCAmJiAhc3VicGF0aENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcImFzc2VydGlvbiBmYWlsZWQ6IHN1YnBhdGggZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbmV3UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcImFzc2VydGlvbiBmYWlsZWQ6IHBhcmVudCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiYXNzZXJ0aW9uIGZhaWxlZDogc2NhbGFyIG5vZGVzIGNhbm5vdCBjaGFuZ2UgdGhlaXIgcGFyZW50XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW52aXJvbm1lbnQgPSB1bmRlZmluZWQ7IC8vIHVzZSBwYXJlbnQnc1xuICAgICAgICAgICAgdGhpcy5iYXNlU2V0UGFyZW50KHRoaXMucGFyZW50LCBzdWJwYXRoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FsYXJOb2RlLnByb3RvdHlwZSwgXCJzbmFwc2hvdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyZWV6ZSh0aGlzLmdldFNuYXBzaG90KCkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjYWxhck5vZGUucHJvdG90eXBlLCBcImdldFNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmdldFNuYXBzaG90KHRoaXMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjYWxhck5vZGUucHJvdG90eXBlLCBcInRvU3RyaW5nXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9ICh0aGlzLmlzQWxpdmUgPyB0aGlzLnBhdGggOiB0aGlzLnBhdGhVcG9uRGVhdGgpIHx8IFwiPHJvb3Q+XCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLm5hbWUgKyBcIkBcIiArIHBhdGggKyAodGhpcy5pc0FsaXZlID8gXCJcIiA6IFwiIFtkZWFkXVwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FsYXJOb2RlLnByb3RvdHlwZSwgXCJkaWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FsaXZlIHx8IHRoaXMuc3RhdGUgPT09IE5vZGVMaWZlQ3ljbGUuREVUQUNISU5HKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuYWJvdXRUb0RpZSgpO1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZURlYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NhbGFyTm9kZS5wcm90b3R5cGUsIFwiZmluYWxpemVDcmVhdGlvblwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5iYXNlRmluYWxpemVDcmVhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjYWxhck5vZGUucHJvdG90eXBlLCBcImFib3V0VG9EaWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZUFib3V0VG9EaWUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FsYXJOb2RlLnByb3RvdHlwZSwgXCJmaW5hbGl6ZURlYXRoXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VGaW5hbGl6ZURlYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NhbGFyTm9kZS5wcm90b3R5cGUsIFwiZmlyZUhvb2tcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVJbnRlcm5hbEhvb2sobmFtZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gU2NhbGFyTm9kZTtcbn0oQmFzZU5vZGUpKTtcblNjYWxhck5vZGUucHJvdG90eXBlLmRpZSA9IGFjdGlvbihTY2FsYXJOb2RlLnByb3RvdHlwZS5kaWUpO1xuXG52YXIgbmV4dE5vZGVJZCA9IDE7XG52YXIgc25hcHNob3RSZWFjdGlvbk9wdGlvbnMgPSB7XG4gICAgb25FcnJvcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIE9iamVjdE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9iamVjdE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JqZWN0Tm9kZShjb21wbGV4VHlwZSwgcGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBsZXhUeXBlLCBwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50KSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9kZUlkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiArK25leHROb2RlSWRcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZGVudGlmaWVyQXR0cmlidXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZGVudGlmaWVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7IC8vIElkZW50aWZpZXIgaXMgYWx3YXlzIG5vcm1hbGl6ZWQgdG8gc3RyaW5nLCBldmVuIGlmIHRoZSBpZGVudGlmaWVyIHByb3BlcnR5IGlzbid0XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ1bm5vcm1hbGl6ZWRJZGVudGlmaWVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpZGVudGlmaWVyQ2FjaGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImlzUHJvdGVjdGlvbkVuYWJsZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtaWRkbGV3YXJlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX2FwcGx5UGF0Y2hlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX2FwcGx5U25hcHNob3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9hdXRvVW5ib3hcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7IC8vIHVuYm94aW5nIGlzIGRpc2FibGVkIHdoZW4gcmVhZGluZyBjaGlsZCBub2Rlc1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX2lzUnVubmluZ0FjdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7IC8vIG9ubHkgcmVsZXZhbnQgZm9yIHJvb3RcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9oYXNTbmFwc2hvdFJlYWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9vYnNlcnZhYmxlSW5zdGFuY2VTdGF0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMCAvKiBVTklOSVRJQUxJWkVEICovXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX2NoaWxkTm9kZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9pbml0aWFsU25hcHNob3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9jYWNoZWRJbml0aWFsU25hcHNob3RcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9jYWNoZWRJbml0aWFsU25hcHNob3RDcmVhdGVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9zbmFwc2hvdENvbXB1dGVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfc25hcHNob3RVcG9uRGVhdGhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gI3JlZ2lvbiBpbnRlcm5hbCBldmVudCBoYW5kbGluZ1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX2ludGVybmFsRXZlbnRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLl9zbmFwc2hvdENvbXB1dGVkID0gY29tcHV0ZWQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZnJlZXplKF90aGlzLmdldFNuYXBzaG90KCkpOyB9KTtcbiAgICAgICAgX3RoaXMudW5ib3ggPSBfdGhpcy51bmJveC5iaW5kKF90aGlzKTtcbiAgICAgICAgX3RoaXMuX2luaXRpYWxTbmFwc2hvdCA9IGZyZWV6ZShpbml0aWFsVmFsdWUpO1xuICAgICAgICBfdGhpcy5pZGVudGlmaWVyQXR0cmlidXRlID0gY29tcGxleFR5cGUuaWRlbnRpZmllckF0dHJpYnV0ZTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLmlkZW50aWZpZXJDYWNoZSA9IG5ldyBJZGVudGlmaWVyQ2FjaGUoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fY2hpbGROb2RlcyA9IGNvbXBsZXhUeXBlLmluaXRpYWxpemVDaGlsZE5vZGVzKF90aGlzLCBfdGhpcy5faW5pdGlhbFNuYXBzaG90KTtcbiAgICAgICAgLy8gaWRlbnRpZmllciBjYW4gbm90IGJlIGNoYW5nZWQgZHVyaW5nIGxpZmVjeWNsZSBvZiBhIG5vZGVcbiAgICAgICAgLy8gc28gd2Ugc2FmZWx5IGNhbiByZWFkIGl0IGZyb20gaW5pdGlhbCBzbmFwc2hvdFxuICAgICAgICBfdGhpcy5pZGVudGlmaWVyID0gbnVsbDtcbiAgICAgICAgX3RoaXMudW5ub3JtYWxpemVkSWRlbnRpZmllciA9IG51bGw7XG4gICAgICAgIGlmIChfdGhpcy5pZGVudGlmaWVyQXR0cmlidXRlICYmIF90aGlzLl9pbml0aWFsU25hcHNob3QpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF90aGlzLl9pbml0aWFsU25hcHNob3RbX3RoaXMuaWRlbnRpZmllckF0dHJpYnV0ZV07XG4gICAgICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB3aXRoIHRoZSBhY3R1YWwgbm9kZSBpZiBub3QgKGZvciBvcHRpb25hbCBpZGVudGlmaWVycylcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gX3RoaXMuX2NoaWxkTm9kZXNbX3RoaXMuaWRlbnRpZmllckF0dHJpYnV0ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZCA9IGNoaWxkTm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpZCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkluc3RhbmNlIGlkZW50aWZpZXIgJ1wiICsgX3RoaXMuaWRlbnRpZmllckF0dHJpYnV0ZSArIFwiJyBmb3IgdHlwZSAnXCIgKyBfdGhpcy50eXBlLm5hbWUgKyBcIicgbXVzdCBiZSBhIHN0cmluZyBvciBhIG51bWJlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBpbnRlcm5hbCBpZGVudGlmaWVyIHRvIHN0cmluZ1xuICAgICAgICAgICAgX3RoaXMuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoaWQpO1xuICAgICAgICAgICAgX3RoaXMudW5ub3JtYWxpemVkSWRlbnRpZmllciA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICBfdGhpcy5pZGVudGlmaWVyQ2FjaGUuYWRkTm9kZVRvQ2FjaGUoX3RoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50LnJvb3QuaWRlbnRpZmllckNhY2hlLmFkZE5vZGVUb0NhY2hlKF90aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJhcHBseVBhdGNoZXNcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChwYXRjaGVzKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU9ic2VydmFibGVJbnN0YW5jZUlmTmVlZGVkKCk7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVBhdGNoZXMocGF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiYXBwbHlTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU9ic2VydmFibGVJbnN0YW5jZUlmTmVlZGVkKCk7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVNuYXBzaG90KHNuYXBzaG90KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJjcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2VJZk5lZWRlZFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29ic2VydmFibGVJbnN0YW5jZVN0YXRlID09PSAwIC8qIFVOSU5JVElBTElaRUQgKi8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZU9ic2VydmFibGVJbnN0YW5jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImNyZWF0ZU9ic2VydmFibGVJbnN0YW5jZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IE5vZGVMaWZlQ3ljbGUuSU5JVElBTElaSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcImFzc2VydGlvbiBmYWlsZWQ6IHRoZSBjcmVhdGlvbiBvZiB0aGUgb2JzZXJ2YWJsZSBpbnN0YW5jZSBtdXN0IGJlIGRvbmUgb24gdGhlIGluaXRpYWxpemluZyBwaGFzZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZhYmxlSW5zdGFuY2VTdGF0ZSA9IDEgLyogQ1JFQVRJTkcgKi87XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHBhcmVudCBjaGFpbiBpcyBjcmVhdGVkIGFzIHdlbGxcbiAgICAgICAgICAgIC8vIGFycmF5IHdpdGggcGFyZW50IGNoYWluIGZyb20gcGFyZW50IHRvIGNoaWxkXG4gICAgICAgICAgICB2YXIgcGFyZW50Q2hhaW4gPSBbXTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIC8vIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIHdlIG5ldmVyIGdvIGJhY2sgZnVydGhlciB0aGFuIHRoZSBtb3N0IGRpcmVjdFxuICAgICAgICAgICAgLy8gdW5pbml0aWFsaXplZCBwYXJlbnRcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgZG9uZSB0byBhdm9pZCB0cmF2ZXJzaW5nIHRoZSB3aG9sZSB0cmVlIHRvIHRoZSByb290IHdoZW4gdXNpbmdcbiAgICAgICAgICAgIC8vIHRoZSBzYW1lIHJlZmVyZW5jZSBhZ2FpblxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudCAmJlxuICAgICAgICAgICAgICAgIHBhcmVudC5fb2JzZXJ2YWJsZUluc3RhbmNlU3RhdGUgPT09IDAgLyogVU5JTklUSUFMSVpFRCAqLykge1xuICAgICAgICAgICAgICAgIHBhcmVudENoYWluLnVuc2hpZnQocGFyZW50KTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSB1bmluaXRpYWxpemVkIHBhcmVudCBjaGFpbiBmcm9tIHBhcmVudCB0byBjaGlsZFxuICAgICAgICAgICAgICAgIGZvciAodmFyIHBhcmVudENoYWluXzEgPSBfX3ZhbHVlcyhwYXJlbnRDaGFpbiksIHBhcmVudENoYWluXzFfMSA9IHBhcmVudENoYWluXzEubmV4dCgpOyAhcGFyZW50Q2hhaW5fMV8xLmRvbmU7IHBhcmVudENoYWluXzFfMSA9IHBhcmVudENoYWluXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwID0gcGFyZW50Q2hhaW5fMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBwLmNyZWF0ZU9ic2VydmFibGVJbnN0YW5jZUlmTmVlZGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRDaGFpbl8xXzEgJiYgIXBhcmVudENoYWluXzFfMS5kb25lICYmIChfYSA9IHBhcmVudENoYWluXzEucmV0dXJuKSkgX2EuY2FsbChwYXJlbnRDaGFpbl8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVkVmFsdWUgPSB0eXBlLmNyZWF0ZU5ld0luc3RhbmNlKHRoaXMuX2NoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJlYm9vdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzUnVubmluZ0FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHlwZS5maW5hbGl6ZU5ld0luc3RhbmNlKHRoaXMsIHRoaXMuc3RvcmVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBzaG9ydC1jdXQgdG8gZGllIHRoZSBpbnN0YW5jZSwgdG8gYXZvaWQgdGhlIHNuYXBzaG90IGNvbXB1dGVkIHN0YXJ0aW5nIHRvIHRocm93Li4uXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IE5vZGVMaWZlQ3ljbGUuREVBRDtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXNSdW5uaW5nQWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZhYmxlSW5zdGFuY2VTdGF0ZSA9IDIgLyogQ1JFQVRFRCAqLztcbiAgICAgICAgICAgIHRoaXMuX3NuYXBzaG90Q29tcHV0ZWQudHJhY2tBbmRDb21wdXRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Jvb3QpXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkU25hcHNob3RSZWFjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fY2hpbGROb2RlcyA9IEVNUFRZX09CSkVDVDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBOb2RlTGlmZUN5Y2xlLkNSRUFURUQ7XG4gICAgICAgICAgICB0aGlzLmZpcmVIb29rKEhvb2suYWZ0ZXJDcmVhdGUpO1xuICAgICAgICAgICAgdGhpcy5maW5hbGl6ZUNyZWF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwicm9vdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5yb290IDogdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJjbGVhclBhcmVudFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBkZXRhY2ggaWYgYXR0YWNoZWRcbiAgICAgICAgICAgIHRoaXMuZmlyZUhvb2soSG9vay5iZWZvcmVEZXRhY2gpO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IE5vZGVMaWZlQ3ljbGUuREVUQUNISU5HO1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICB2YXIgbmV3RW52ID0gcm9vdC5lbnZpcm9ubWVudDtcbiAgICAgICAgICAgIHZhciBuZXdJZENhY2hlID0gcm9vdC5pZGVudGlmaWVyQ2FjaGUuc3BsaXRDYWNoZSh0aGlzKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5zdWJwYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VTZXRQYXJlbnQobnVsbCwgXCJcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnZpcm9ubWVudCA9IG5ld0VudjtcbiAgICAgICAgICAgICAgICB0aGlzLmlkZW50aWZpZXJDYWNoZSA9IG5ld0lkQ2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJzZXRQYXJlbnRcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChuZXdQYXJlbnQsIHN1YnBhdGgpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDaGFuZ2VkID0gbmV3UGFyZW50ICE9PSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBzdWJwYXRoQ2hhbmdlZCA9IHN1YnBhdGggIT09IHRoaXMuc3VicGF0aDtcbiAgICAgICAgICAgIGlmICghcGFyZW50Q2hhbmdlZCAmJiAhc3VicGF0aENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWJwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcImFzc2VydGlvbiBmYWlsZWQ6IHN1YnBhdGggZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbmV3UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcImFzc2VydGlvbiBmYWlsZWQ6IG5ldyBwYXJlbnQgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiBwYXJlbnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkEgbm9kZSBjYW5ub3QgZXhpc3RzIHR3aWNlIGluIHRoZSBzdGF0ZSB0cmVlLiBGYWlsZWQgdG8gYWRkIFwiICsgdGhpcyArIFwiIHRvIHBhdGggJ1wiICsgbmV3UGFyZW50LnBhdGggKyBcIi9cIiArIHN1YnBhdGggKyBcIicuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50ICYmIG5ld1BhcmVudC5yb290ID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkEgc3RhdGUgdHJlZSBpcyBub3QgYWxsb3dlZCB0byBjb250YWluIGl0c2VsZi4gQ2Fubm90IGFzc2lnbiBcIiArIHRoaXMgKyBcIiB0byBwYXRoICdcIiArIG5ld1BhcmVudC5wYXRoICsgXCIvXCIgKyBzdWJwYXRoICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICEhdGhpcy5lbnZpcm9ubWVudCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVudmlyb25tZW50ICE9PSBuZXdQYXJlbnQucm9vdC5lbnZpcm9ubWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJBIHN0YXRlIHRyZWUgY2Fubm90IGJlIG1hZGUgcGFydCBvZiBhbm90aGVyIHN0YXRlIHRyZWUgYXMgbG9uZyBhcyB0aGVpciBlbnZpcm9ubWVudHMgYXJlIGRpZmZlcmVudC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggdG8gbmV3IHBhcmVudFxuICAgICAgICAgICAgICAgIHRoaXMuZW52aXJvbm1lbnQgPSB1bmRlZmluZWQ7IC8vIHdpbGwgdXNlIHJvb3Qnc1xuICAgICAgICAgICAgICAgIG5ld1BhcmVudC5yb290LmlkZW50aWZpZXJDYWNoZS5tZXJnZUNhY2hlKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVNldFBhcmVudChuZXdQYXJlbnQsIHN1YnBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUhvb2soSG9vay5hZnRlckF0dGFjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJwYXRoQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIG1vdmluZyB0byBhIG5ldyBzdWJwYXRoIG9uIHRoZSBzYW1lIHBhcmVudFxuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVNldFBhcmVudCh0aGlzLnBhcmVudCwgc3VicGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiZmlyZUhvb2tcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5maXJlSW50ZXJuYWxIb29rKG5hbWUpO1xuICAgICAgICAgICAgdmFyIGZuID0gdGhpcy5zdG9yZWRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzLnN0b3JlZFZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZWRWYWx1ZVtuYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIHdlIGNoZWNrIGZvciBpdCB0byBhbGxvdyBvbGQgbW9ieCBwZWVyIGRlcGVuZGVuY2llcyB0aGF0IGRvbid0IGhhdmUgdGhlIG1ldGhvZCB0byB3b3JrIChldmVuIHdoZW4gc3RpbGwgYnVnZ2VkKVxuICAgICAgICAgICAgICAgIGlmIChfYWxsb3dTdGF0ZUNoYW5nZXNJbnNpZGVDb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBfYWxsb3dTdGF0ZUNoYW5nZXNJbnNpZGVDb21wdXRlZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShfdGhpcy5zdG9yZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkodGhpcy5zdG9yZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcInNuYXBzaG90XCIsIHtcbiAgICAgICAgLy8gYWR2YW50YWdlIG9mIHVzaW5nIGNvbXB1dGVkIGZvciBhIHNuYXBzaG90IGlzIHRoYXQgbmljZWx5IHJlc3BlY3RzIHRyYW5zYWN0aW9ucyBldGMuXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NuYXBzaG90Q29tcHV0ZWQuZ2V0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvLyBOT1RFOiB3ZSB1c2UgdGhpcyBtZXRob2QgdG8gZ2V0IHNuYXBzaG90IHdpdGhvdXQgY3JlYXRpbmcgQGNvbXB1dGVkIG92ZXJoZWFkXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImdldFNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBbGl2ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc25hcHNob3RVcG9uRGVhdGg7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb2JzZXJ2YWJsZUluc3RhbmNlU3RhdGUgPT09IDIgLyogQ1JFQVRFRCAqL1xuICAgICAgICAgICAgICAgID8gdGhpcy5fZ2V0QWN0dWFsU25hcHNob3QoKVxuICAgICAgICAgICAgICAgIDogdGhpcy5fZ2V0Q2FjaGVkSW5pdGlhbFNuYXBzaG90KCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiX2dldEFjdHVhbFNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmdldFNuYXBzaG90KHRoaXMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcIl9nZXRDYWNoZWRJbml0aWFsU25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FjaGVkSW5pdGlhbFNuYXBzaG90Q3JlYXRlZCkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpcy5fY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICB2YXIgc25hcHNob3QgPSB0aGlzLl9pbml0aWFsU25hcHNob3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkSW5pdGlhbFNuYXBzaG90ID0gdHlwZS5wcm9jZXNzSW5pdGlhbFNuYXBzaG90KGNoaWxkTm9kZXMsIHNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRJbml0aWFsU25hcHNob3RDcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRJbml0aWFsU25hcHNob3Q7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiaXNSdW5uaW5nQWN0aW9uXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNSdW5uaW5nQWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSb290KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5pc1J1bm5pbmdBY3Rpb24oKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJhc3NlcnRBbGl2ZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBsaXZlbGluZXNzQ2hlY2tpbmcgPSBnZXRMaXZlbGluZXNzQ2hlY2tpbmcoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FsaXZlICYmIGxpdmVsaW5lc3NDaGVja2luZyAhPT0gXCJpZ25vcmVcIikge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IHRoaXMuX2dldEFzc2VydEFsaXZlRXJyb3IoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChsaXZlbGluZXNzQ2hlY2tpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwid2FyblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiX2dldEFzc2VydEFsaXZlRXJyb3JcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgZXNjYXBlZFBhdGggPSB0aGlzLmdldEVzY2FwZWRQYXRoKGZhbHNlKSB8fCB0aGlzLnBhdGhVcG9uRGVhdGggfHwgXCJcIjtcbiAgICAgICAgICAgIHZhciBzdWJwYXRoID0gKGNvbnRleHQuc3VicGF0aCAmJiBlc2NhcGVKc29uUGF0aChjb250ZXh0LnN1YnBhdGgpKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIGFjdGlvbkNvbnRleHQgPSBjb250ZXh0LmFjdGlvbkNvbnRleHQgfHwgZ2V0Q3VycmVudEFjdGlvbkNvbnRleHQoKTtcbiAgICAgICAgICAgIC8vIHRyeSB0byB1c2UgYSByZWFsIGFjdGlvbiBjb250ZXh0IGlmIHBvc3NpYmxlIHNpbmNlIGl0IGluY2x1ZGVzIHRoZSBhY3Rpb24gbmFtZVxuICAgICAgICAgICAgaWYgKGFjdGlvbkNvbnRleHQgJiYgYWN0aW9uQ29udGV4dC50eXBlICE9PSBcImFjdGlvblwiICYmIGFjdGlvbkNvbnRleHQucGFyZW50QWN0aW9uRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25Db250ZXh0ID0gYWN0aW9uQ29udGV4dC5wYXJlbnRBY3Rpb25FdmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhY3Rpb25GdWxsUGF0aCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoYWN0aW9uQ29udGV4dCAmJiBhY3Rpb25Db250ZXh0Lm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0byB1c2UgdGhlIGNvbnRleHQsIGFuZCBpZiBpdCBub3QgYXZhaWxhYmxlIHVzZSB0aGUgbm9kZSBvbmVcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uUGF0aCA9IChhY3Rpb25Db250ZXh0ICYmIGFjdGlvbkNvbnRleHQuY29udGV4dCAmJiBnZXRQYXRoKGFjdGlvbkNvbnRleHQuY29udGV4dCkpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXRoO1xuICAgICAgICAgICAgICAgIGFjdGlvbkZ1bGxQYXRoID0gYWN0aW9uUGF0aCArIFwiLlwiICsgYWN0aW9uQ29udGV4dC5uYW1lICsgXCIoKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiWW91IGFyZSB0cnlpbmcgdG8gcmVhZCBvciB3cml0ZSB0byBhbiBvYmplY3QgdGhhdCBpcyBubyBsb25nZXIgcGFydCBvZiBhIHN0YXRlIHRyZWUuIChPYmplY3QgdHlwZTogJ1wiICsgdGhpcy50eXBlLm5hbWUgKyBcIicsIFBhdGggdXBvbiBkZWF0aDogJ1wiICsgZXNjYXBlZFBhdGggKyBcIicsIFN1YnBhdGg6ICdcIiArIHN1YnBhdGggKyBcIicsIEFjdGlvbjogJ1wiICsgYWN0aW9uRnVsbFBhdGggKyBcIicpLiBFaXRoZXIgZGV0YWNoIG5vZGVzIGZpcnN0LCBvciBkb24ndCB1c2Ugb2JqZWN0cyBhZnRlciByZW1vdmluZyAvIHJlcGxhY2luZyB0aGVtIGluIHRoZSB0cmVlLlwiO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImdldENoaWxkTm9kZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHN1YnBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0QWxpdmUoe1xuICAgICAgICAgICAgICAgIHN1YnBhdGg6IHN1YnBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fYXV0b1VuYm94ID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZhYmxlSW5zdGFuY2VTdGF0ZSA9PT0gMiAvKiBDUkVBVEVEICovXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy50eXBlLmdldENoaWxkTm9kZSh0aGlzLCBzdWJwYXRoKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2NoaWxkTm9kZXNbc3VicGF0aF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRvVW5ib3ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImdldENoaWxkcmVuXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydEFsaXZlKEVNUFRZX09CSkVDVCk7XG4gICAgICAgICAgICB0aGlzLl9hdXRvVW5ib3ggPSBmYWxzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29ic2VydmFibGVJbnN0YW5jZVN0YXRlID09PSAyIC8qIENSRUFURUQgKi9cbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnR5cGUuZ2V0Q2hpbGRyZW4odGhpcylcbiAgICAgICAgICAgICAgICAgICAgOiBjb252ZXJ0Q2hpbGROb2Rlc1RvQXJyYXkodGhpcy5fY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRvVW5ib3ggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImdldENoaWxkVHlwZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHByb3BlcnR5TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5nZXRDaGlsZFR5cGUocHJvcGVydHlOYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJpc1Byb3RlY3RlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5pc1Byb3RlY3Rpb25FbmFibGVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImFzc2VydFdyaXRhYmxlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRBbGl2ZShjb250ZXh0KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmdBY3Rpb24oKSAmJiB0aGlzLmlzUHJvdGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiQ2Fubm90IG1vZGlmeSAnXCIgKyB0aGlzICsgXCInLCB0aGUgb2JqZWN0IGlzIHByb3RlY3RlZCBhbmQgY2FuIG9ubHkgYmUgbW9kaWZpZWQgYnkgdXNpbmcgYW4gYWN0aW9uLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJyZW1vdmVDaGlsZFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHN1YnBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMudHlwZS5yZW1vdmVDaGlsZCh0aGlzLCBzdWJwYXRoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGJvdW5kIG9uIHRoZSBjb25zdHJ1Y3RvclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJ1bmJveFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0QWxpdmUoe1xuICAgICAgICAgICAgICAgIHN1YnBhdGg6IGNoaWxkTm9kZS5zdWJwYXRoIHx8IGNoaWxkTm9kZS5zdWJwYXRoVXBvbkRlYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRvVW5ib3ggPyBjaGlsZE5vZGUudmFsdWUgOiBjaGlsZE5vZGU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gKHRoaXMuaXNBbGl2ZSA/IHRoaXMucGF0aCA6IHRoaXMucGF0aFVwb25EZWF0aCkgfHwgXCI8cm9vdD5cIjtcbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gdGhpcy5pZGVudGlmaWVyID8gXCIoaWQ6IFwiICsgdGhpcy5pZGVudGlmaWVyICsgXCIpXCIgOiBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5uYW1lICsgXCJAXCIgKyBwYXRoICsgaWRlbnRpZmllciArICh0aGlzLmlzQWxpdmUgPyBcIlwiIDogXCIgW2RlYWRdXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImZpbmFsaXplQ3JlYXRpb25cIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmJhc2VGaW5hbGl6ZUNyZWF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKF90aGlzLmdldENoaWxkcmVuKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmZpbmFsaXplQ3JlYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyZUludGVybmFsSG9vayhIb29rLmFmdGVyQ3JlYXRpb25GaW5hbGl6YXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiZGV0YWNoXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBbGl2ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJFcnJvciB3aGlsZSBkZXRhY2hpbmcsIG5vZGUgaXMgbm90IGFsaXZlLlwiKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJQYXJlbnQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJwcmVib290XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVBhdGNoZXMgPSBjcmVhdGVBY3Rpb25JbnZva2VyKHRoaXMuc3RvcmVkVmFsdWUsIFwiQEFQUExZX1BBVENIRVNcIiwgZnVuY3Rpb24gKHBhdGNoZXMpIHtcbiAgICAgICAgICAgICAgICBwYXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKHBhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF0Y2gucGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50eXBlLmFwcGx5U25hcHNob3Qoc2VsZiwgcGF0Y2gudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHNwbGl0SnNvblBhdGgocGF0Y2gucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gcmVzb2x2ZU5vZGVCeVBhdGhQYXJ0cyhzZWxmLCBwYXJ0cy5zbGljZSgwLCAtMSkpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmFwcGx5UGF0Y2hMb2NhbGx5KHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLCBwYXRjaCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5U25hcHNob3QgPSBjcmVhdGVBY3Rpb25JbnZva2VyKHRoaXMuc3RvcmVkVmFsdWUsIFwiQEFQUExZX1NOQVBTSE9UXCIsIGZ1bmN0aW9uIChzbmFwc2hvdCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzbmFwc2hvdCBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBvbmUsIGF2b2lkIHBlcmZvcm1pbmcgYSByZWNvbmNpbGVcbiAgICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHNlbGYuc25hcHNob3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBlbHNlLCBhcHBseSBpdCBieSBjYWxsaW5nIHRoZSB0eXBlIGxvZ2ljXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYudHlwZS5hcHBseVNuYXBzaG90KHNlbGYsIHNuYXBzaG90KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYWRkSGlkZGVuRmluYWxQcm9wKHRoaXMuc3RvcmVkVmFsdWUsIFwiJHRyZWVub2RlXCIsIHRoaXMpO1xuICAgICAgICAgICAgYWRkSGlkZGVuRmluYWxQcm9wKHRoaXMuc3RvcmVkVmFsdWUsIFwidG9KU09OXCIsIHRvSlNPTik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiZGllXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBbGl2ZSB8fCB0aGlzLnN0YXRlID09PSBOb2RlTGlmZUN5Y2xlLkRFVEFDSElORylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmFib3V0VG9EaWUoKTtcbiAgICAgICAgICAgIHRoaXMuZmluYWxpemVEZWF0aCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImFib3V0VG9EaWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vYnNlcnZhYmxlSW5zdGFuY2VTdGF0ZSA9PT0gMCAvKiBVTklOSVRJQUxJWkVEICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nZXRDaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFib3V0VG9EaWUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYmVmb3JlRGVzdHJveSBzaG91bGQgcnVuIGJlZm9yZSB0aGUgZGlzcG9zZXJzIHNpbmNlIGVsc2Ugd2UgY291bGQgZW5kIHVwIGluIGEgc2l0dWF0aW9uIHdoZXJlXG4gICAgICAgICAgICAvLyBhIGRpc3Bvc2VyIGFkZGVkIHdpdGggYWRkRGlzcG9zZXIgYXQgdGhpcyBzdGFnZSAoYmVmb3JlRGVzdHJveSkgaXMgYWN0dWFsbHkgbmV2ZXIgcmVsZWFzZWRcbiAgICAgICAgICAgIHRoaXMuYmFzZUFib3V0VG9EaWUoKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsRXZlbnRzRW1pdChcImRpc3Bvc2VcIiAvKiBEaXNwb3NlICovKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsRXZlbnRzQ2xlYXIoXCJkaXNwb3NlXCIgLyogRGlzcG9zZSAqLyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiZmluYWxpemVEZWF0aFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gaW52YXJpYW50OiBub3QgY2FsbGVkIGRpcmVjdGx5IGJ1dCBmcm9tIFwiZGllXCJcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5maW5hbGl6ZURlYXRoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5pZGVudGlmaWVyQ2FjaGUubm90aWZ5RGllZCh0aGlzKTtcbiAgICAgICAgICAgIC8vIFwia2lsbFwiIHRoZSBjb21wdXRlZCBwcm9wIGFuZCBqdXN0IHN0b3JlIHRoZSBsYXN0IHNuYXBzaG90XG4gICAgICAgICAgICB2YXIgc25hcHNob3QgPSB0aGlzLnNuYXBzaG90O1xuICAgICAgICAgICAgdGhpcy5fc25hcHNob3RVcG9uRGVhdGggPSBzbmFwc2hvdDtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsRXZlbnRzQ2xlYXJBbGwoKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZUZpbmFsaXplRGVhdGgoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJvblNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAob25DaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFNuYXBzaG90UmVhY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEV2ZW50c1JlZ2lzdGVyKFwic25hcHNob3RcIiAvKiBTbmFwc2hvdCAqLywgb25DaGFuZ2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImVtaXRTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEV2ZW50c0VtaXQoXCJzbmFwc2hvdFwiIC8qIFNuYXBzaG90ICovLCBzbmFwc2hvdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwib25QYXRjaFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEV2ZW50c1JlZ2lzdGVyKFwicGF0Y2hcIiAvKiBQYXRjaCAqLywgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiZW1pdFBhdGNoXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoYmFzZVBhdGNoLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbEV2ZW50c0hhc1N1YnNjcmliZXJzKFwicGF0Y2hcIiAvKiBQYXRjaCAqLykpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxpemVkUGF0Y2ggPSBleHRlbmQoe30sIGJhc2VQYXRjaCwge1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiBzb3VyY2UucGF0aC5zdWJzdHIodGhpcy5wYXRoLmxlbmd0aCkgKyBcIi9cIiArIGJhc2VQYXRjaC5wYXRoIC8vIGNhbGN1bGF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBvZiB0aGUgcGF0Y2hcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoc3BsaXRQYXRjaChsb2NhbGl6ZWRQYXRjaCksIDIpLCBwYXRjaCA9IF9hWzBdLCByZXZlcnNlUGF0Y2ggPSBfYVsxXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEV2ZW50c0VtaXQoXCJwYXRjaFwiIC8qIFBhdGNoICovLCBwYXRjaCwgcmV2ZXJzZVBhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5lbWl0UGF0Y2goYmFzZVBhdGNoLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImhhc0Rpc3Bvc2VyXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZGlzcG9zZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEV2ZW50c0hhcyhcImRpc3Bvc2VcIiAvKiBEaXNwb3NlICovLCBkaXNwb3Nlcik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiYWRkRGlzcG9zZXJcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChkaXNwb3Nlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0Rpc3Bvc2VyKGRpc3Bvc2VyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsRXZlbnRzUmVnaXN0ZXIoXCJkaXNwb3NlXCIgLyogRGlzcG9zZSAqLywgZGlzcG9zZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGZhaWwkMShcImNhbm5vdCBhZGQgYSBkaXNwb3NlciB3aGVuIGl0IGlzIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgZXhlY3V0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcInJlbW92ZURpc3Bvc2VyXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZGlzcG9zZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW50ZXJuYWxFdmVudHNIYXMoXCJkaXNwb3NlXCIgLyogRGlzcG9zZSAqLywgZGlzcG9zZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiY2Fubm90IHJlbW92ZSBhIGRpc3Bvc2VyIHdoaWNoIHdhcyBuZXZlciByZWdpc3RlcmVkIGZvciBleGVjdXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEV2ZW50c1VucmVnaXN0ZXIoXCJkaXNwb3NlXCIgLyogRGlzcG9zZSAqLywgZGlzcG9zZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcInJlbW92ZU1pZGRsZXdhcmVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5taWRkbGV3YXJlcykge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMubWlkZGxld2FyZXMuaW5kZXhPZihtaWRkbGV3YXJlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pZGRsZXdhcmVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImFkZE1pZGRsZVdhcmVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChoYW5kbGVyLCBpbmNsdWRlSG9va3MpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZUhvb2tzID09PSB2b2lkIDApIHsgaW5jbHVkZUhvb2tzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgdmFyIG1pZGRsZXdhcmUgPSB7IGhhbmRsZXI6IGhhbmRsZXIsIGluY2x1ZGVIb29rczogaW5jbHVkZUhvb2tzIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMubWlkZGxld2FyZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5taWRkbGV3YXJlcyA9IFttaWRkbGV3YXJlXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm1pZGRsZXdhcmVzLnB1c2gobWlkZGxld2FyZSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZU1pZGRsZXdhcmUobWlkZGxld2FyZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcImFwcGx5UGF0Y2hMb2NhbGx5XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoc3VicGF0aCwgcGF0Y2gpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0V3JpdGFibGUoe1xuICAgICAgICAgICAgICAgIHN1YnBhdGg6IHN1YnBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2VJZk5lZWRlZCgpO1xuICAgICAgICAgICAgdGhpcy50eXBlLmFwcGx5UGF0Y2hMb2NhbGx5KHRoaXMsIHN1YnBhdGgsIHBhdGNoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJfYWRkU25hcHNob3RSZWFjdGlvblwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICghdGhpcy5faGFzU25hcHNob3RSZWFjdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBzbmFwc2hvdERpc3Bvc2VyID0gcmVhY3Rpb24oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuc25hcHNob3Q7IH0sIGZ1bmN0aW9uIChzbmFwc2hvdCkgeyByZXR1cm4gX3RoaXMuZW1pdFNuYXBzaG90KHNuYXBzaG90KTsgfSwgc25hcHNob3RSZWFjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRGlzcG9zZXIoc25hcHNob3REaXNwb3Nlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzU25hcHNob3RSZWFjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyB3ZSBwcm94eSB0aGUgbWV0aG9kcyB0byBhdm9pZCBjcmVhdGluZyBhbiBFdmVudEhhbmRsZXJzIGluc3RhbmNlIHdoZW4gaXQgaXMgbm90IG5lZWRlZFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3ROb2RlLnByb3RvdHlwZSwgXCJfaW50ZXJuYWxFdmVudHNIYXNTdWJzY3JpYmVyc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLl9pbnRlcm5hbEV2ZW50cyAmJiB0aGlzLl9pbnRlcm5hbEV2ZW50cy5oYXNTdWJzY3JpYmVycyhldmVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiX2ludGVybmFsRXZlbnRzUmVnaXN0ZXJcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChldmVudCwgZXZlbnRIYW5kbGVyLCBhdFRoZUJlZ2lubmluZykge1xuICAgICAgICAgICAgaWYgKGF0VGhlQmVnaW5uaW5nID09PSB2b2lkIDApIHsgYXRUaGVCZWdpbm5pbmcgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbnRlcm5hbEV2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsRXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEV2ZW50cy5yZWdpc3RlcihldmVudCwgZXZlbnRIYW5kbGVyLCBhdFRoZUJlZ2lubmluZyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiX2ludGVybmFsRXZlbnRzSGFzXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZlbnQsIGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5faW50ZXJuYWxFdmVudHMgJiYgdGhpcy5faW50ZXJuYWxFdmVudHMuaGFzKGV2ZW50LCBldmVudEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcIl9pbnRlcm5hbEV2ZW50c1VucmVnaXN0ZXJcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChldmVudCwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxFdmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEV2ZW50cy51bnJlZ2lzdGVyKGV2ZW50LCBldmVudEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcIl9pbnRlcm5hbEV2ZW50c0VtaXRcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbEV2ZW50cykge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuX2ludGVybmFsRXZlbnRzKS5lbWl0LmFwcGx5KF9hLCBfX3NwcmVhZChbZXZlbnRdLCBhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0Tm9kZS5wcm90b3R5cGUsIFwiX2ludGVybmFsRXZlbnRzQ2xlYXJcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxFdmVudHMuY2xlYXIoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdE5vZGUucHJvdG90eXBlLCBcIl9pbnRlcm5hbEV2ZW50c0NsZWFyQWxsXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxFdmVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEV2ZW50cy5jbGVhckFsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdE5vZGU7XG59KEJhc2VOb2RlKSk7XG5PYmplY3ROb2RlLnByb3RvdHlwZS5jcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2UgPSBhY3Rpb24oT2JqZWN0Tm9kZS5wcm90b3R5cGUuY3JlYXRlT2JzZXJ2YWJsZUluc3RhbmNlKTtcbk9iamVjdE5vZGUucHJvdG90eXBlLmRldGFjaCA9IGFjdGlvbihPYmplY3ROb2RlLnByb3RvdHlwZS5kZXRhY2gpO1xuT2JqZWN0Tm9kZS5wcm90b3R5cGUuZGllID0gYWN0aW9uKE9iamVjdE5vZGUucHJvdG90eXBlLmRpZSk7XG5cbnZhciBfYTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBUeXBlRmxhZ3M7XG4oZnVuY3Rpb24gKFR5cGVGbGFncykge1xuICAgIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJTdHJpbmdcIl0gPSAxXSA9IFwiU3RyaW5nXCI7XG4gICAgVHlwZUZsYWdzW1R5cGVGbGFnc1tcIk51bWJlclwiXSA9IDJdID0gXCJOdW1iZXJcIjtcbiAgICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiQm9vbGVhblwiXSA9IDRdID0gXCJCb29sZWFuXCI7XG4gICAgVHlwZUZsYWdzW1R5cGVGbGFnc1tcIkRhdGVcIl0gPSA4XSA9IFwiRGF0ZVwiO1xuICAgIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJMaXRlcmFsXCJdID0gMTZdID0gXCJMaXRlcmFsXCI7XG4gICAgVHlwZUZsYWdzW1R5cGVGbGFnc1tcIkFycmF5XCJdID0gMzJdID0gXCJBcnJheVwiO1xuICAgIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJNYXBcIl0gPSA2NF0gPSBcIk1hcFwiO1xuICAgIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJPYmplY3RcIl0gPSAxMjhdID0gXCJPYmplY3RcIjtcbiAgICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiRnJvemVuXCJdID0gMjU2XSA9IFwiRnJvemVuXCI7XG4gICAgVHlwZUZsYWdzW1R5cGVGbGFnc1tcIk9wdGlvbmFsXCJdID0gNTEyXSA9IFwiT3B0aW9uYWxcIjtcbiAgICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiUmVmZXJlbmNlXCJdID0gMTAyNF0gPSBcIlJlZmVyZW5jZVwiO1xuICAgIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJJZGVudGlmaWVyXCJdID0gMjA0OF0gPSBcIklkZW50aWZpZXJcIjtcbiAgICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiTGF0ZVwiXSA9IDQwOTZdID0gXCJMYXRlXCI7XG4gICAgVHlwZUZsYWdzW1R5cGVGbGFnc1tcIlJlZmluZW1lbnRcIl0gPSA4MTkyXSA9IFwiUmVmaW5lbWVudFwiO1xuICAgIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJVbmlvblwiXSA9IDE2Mzg0XSA9IFwiVW5pb25cIjtcbiAgICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiTnVsbFwiXSA9IDMyNzY4XSA9IFwiTnVsbFwiO1xuICAgIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJVbmRlZmluZWRcIl0gPSA2NTUzNl0gPSBcIlVuZGVmaW5lZFwiO1xuICAgIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJJbnRlZ2VyXCJdID0gMTMxMDcyXSA9IFwiSW50ZWdlclwiO1xuICAgIFR5cGVGbGFnc1tUeXBlRmxhZ3NbXCJDdXN0b21cIl0gPSAyNjIxNDRdID0gXCJDdXN0b21cIjtcbiAgICBUeXBlRmxhZ3NbVHlwZUZsYWdzW1wiU25hcHNob3RQcm9jZXNzb3JcIl0gPSA1MjQyODhdID0gXCJTbmFwc2hvdFByb2Nlc3NvclwiO1xufSkoVHlwZUZsYWdzIHx8IChUeXBlRmxhZ3MgPSB7fSkpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIGNhbm5vdERldGVybWluZVN1YnR5cGUgPSBcImNhbm5vdERldGVybWluZVwiO1xuLyoqIEBoaWRkZW4gKi9cbnZhciAkdHlwZSA9IFN5bWJvbChcIiR0eXBlXCIpO1xuLyoqXG4gKiBBIGJhc2UgdHlwZSBwcm9kdWNlcyBhIE1TVCBub2RlIChOb2RlIGluIHRoZSBzdGF0ZSB0cmVlKVxuICpcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG52YXIgQmFzZVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmFzZVR5cGUobmFtZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2EsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoZXNlIGFyZSBqdXN0IHRvIG1ha2UgaW5uZXIgdHlwZXMgYXZhaWFsYWJsZSB0byBpbmhlcml0ZWQgY2xhc3Nlc1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJDXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIlNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiVFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJOXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzVHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVR5cGUucHJvdG90eXBlLCBcImNyZWF0ZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNuYXBzaG90LCBlbnZpcm9ubWVudCkge1xuICAgICAgICAgICAgdHlwZWNoZWNrSW50ZXJuYWwodGhpcywgc25hcHNob3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFudGlhdGUobnVsbCwgXCJcIiwgZW52aXJvbm1lbnQsIHNuYXBzaG90KS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlVHlwZS5wcm90b3R5cGUsIFwiZ2V0U25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCBhcHBseVBvc3RQcm9jZXNzKSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwidW5pbXBsZW1lbnRlZCBtZXRob2RcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVR5cGUucHJvdG90eXBlLCBcImlzQXNzaWduYWJsZUZyb21cIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gdGhpcztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlVHlwZS5wcm90b3R5cGUsIFwidmFsaWRhdGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlU2FmZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGVGcm9tKHZhbHVlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgPyB0eXBlQ2hlY2tTdWNjZXNzKClcbiAgICAgICAgICAgICAgICAgICAgOiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyB0ZW1wdGluZyB0byBjb21wYXJlIHNuYXBzaG90cywgYnV0IGluIHRoYXQgY2FzZSB3ZSBzaG91bGQgYWx3YXlzIGNsb25lIG9uIGFzc2lnbm1lbnRzLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkU25hcHNob3QodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VUeXBlLnByb3RvdHlwZSwgXCJpc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHRoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZSh0aGluZywgW3sgcGF0aDogXCJcIiwgdHlwZTogdGhpcyB9XSkubGVuZ3RoID09PSAwO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VUeXBlLnByb3RvdHlwZSwgXCJUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiRmFjdG9yeS5UeXBlIHNob3VsZCBub3QgYmUgYWN0dWFsbHkgY2FsbGVkLiBJdCBpcyBqdXN0IGEgVHlwZSBzaWduYXR1cmUgdGhhdCBjYW4gYmUgdXNlZCBhdCBjb21waWxlIHRpbWUgd2l0aCBUeXBlc2NyaXB0LCBieSB1c2luZyBgdHlwZW9mIHR5cGUuVHlwZWBcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVR5cGUucHJvdG90eXBlLCBcIlR5cGVXaXRob3V0U1ROXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiRmFjdG9yeS5UeXBlV2l0aG91dFNUTiBzaG91bGQgbm90IGJlIGFjdHVhbGx5IGNhbGxlZC4gSXQgaXMganVzdCBhIFR5cGUgc2lnbmF0dXJlIHRoYXQgY2FuIGJlIHVzZWQgYXQgY29tcGlsZSB0aW1lIHdpdGggVHlwZXNjcmlwdCwgYnkgdXNpbmcgYHR5cGVvZiB0eXBlLlR5cGVXaXRob3V0U1ROYFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlVHlwZS5wcm90b3R5cGUsIFwiU25hcHNob3RUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiRmFjdG9yeS5TbmFwc2hvdFR5cGUgc2hvdWxkIG5vdCBiZSBhY3R1YWxseSBjYWxsZWQuIEl0IGlzIGp1c3QgYSBUeXBlIHNpZ25hdHVyZSB0aGF0IGNhbiBiZSB1c2VkIGF0IGNvbXBpbGUgdGltZSB3aXRoIFR5cGVzY3JpcHQsIGJ5IHVzaW5nIGB0eXBlb2YgdHlwZS5TbmFwc2hvdFR5cGVgXCIpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VUeXBlLnByb3RvdHlwZSwgXCJDcmVhdGlvblR5cGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJGYWN0b3J5LkNyZWF0aW9uVHlwZSBzaG91bGQgbm90IGJlIGFjdHVhbGx5IGNhbGxlZC4gSXQgaXMganVzdCBhIFR5cGUgc2lnbmF0dXJlIHRoYXQgY2FuIGJlIHVzZWQgYXQgY29tcGlsZSB0aW1lIHdpdGggVHlwZXNjcmlwdCwgYnkgdXNpbmcgYHR5cGVvZiB0eXBlLkNyZWF0aW9uVHlwZWBcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gQmFzZVR5cGU7XG59KCkpO1xuX2EgPSAkdHlwZTtcbkJhc2VUeXBlLnByb3RvdHlwZS5jcmVhdGUgPSBhY3Rpb24oQmFzZVR5cGUucHJvdG90eXBlLmNyZWF0ZSk7XG4vKipcbiAqIEEgY29tcGxleCB0eXBlIHByb2R1Y2VzIGEgTVNUIG5vZGUgKE5vZGUgaW4gdGhlIHN0YXRlIHRyZWUpXG4gKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBDb21wbGV4VHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tcGxleFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29tcGxleFR5cGUobmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaWRlbnRpZmllckF0dHJpYnV0ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wbGV4VHlwZS5wcm90b3R5cGUsIFwiY3JlYXRlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoc25hcHNob3QsIGVudmlyb25tZW50KSB7XG4gICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHZvaWQgMCkgeyBzbmFwc2hvdCA9IHRoaXMuZ2V0RGVmYXVsdFNuYXBzaG90KCk7IH1cbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmNyZWF0ZS5jYWxsKHRoaXMsIHNuYXBzaG90LCBlbnZpcm9ubWVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGxleFR5cGUucHJvdG90eXBlLCBcImdldFZhbHVlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS5jcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2VJZk5lZWRlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3RvcmVkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGxleFR5cGUucHJvdG90eXBlLCBcImlzTWF0Y2hpbmdTbmFwc2hvdElkXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgc25hcHNob3QpIHtcbiAgICAgICAgICAgIHJldHVybiAoIWN1cnJlbnQuaWRlbnRpZmllckF0dHJpYnV0ZSB8fFxuICAgICAgICAgICAgICAgIGN1cnJlbnQuaWRlbnRpZmllciA9PT1cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplSWRlbnRpZmllcihzbmFwc2hvdFtjdXJyZW50LmlkZW50aWZpZXJBdHRyaWJ1dGVdKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGxleFR5cGUucHJvdG90eXBlLCBcInRyeVRvUmVjb25jaWxlTm9kZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGN1cnJlbnQsIG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5pc0RldGFjaGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5zbmFwc2hvdCA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBuZXdWYWx1ZSBpcyB0aGUgY3VycmVudCBzbmFwc2hvdCBvZiB0aGUgbm9kZSwgbm9vcFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RhdGVUcmVlTm9kZShuZXdWYWx1ZSkgJiYgZ2V0U3RhdGVUcmVlTm9kZShuZXdWYWx1ZSkgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBub2RlIGlzIHRoZSBzYW1lIGFzIHRoZSBuZXcgb25lXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudC50eXBlID09PSB0aGlzICYmXG4gICAgICAgICAgICAgICAgaXNNdXRhYmxlKG5ld1ZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICFpc1N0YXRlVHJlZU5vZGUobmV3VmFsdWUpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5pc01hdGNoaW5nU25hcHNob3RJZChjdXJyZW50LCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgbmV3VmFsdWUgaGFzIG5vIG5vZGUsIHNvIGNhbiBiZSB0cmVhdGVkIGxpa2UgYSBzbmFwc2hvdFxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiByZWNvbmNpbGVcbiAgICAgICAgICAgICAgICBjdXJyZW50LmFwcGx5U25hcHNob3QobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBsZXhUeXBlLnByb3RvdHlwZSwgXCJyZWNvbmNpbGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjdXJyZW50LCBuZXdWYWx1ZSwgcGFyZW50LCBzdWJwYXRoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZVJlY29uY2lsZWQgPSB0aGlzLnRyeVRvUmVjb25jaWxlTm9kZShjdXJyZW50LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAobm9kZVJlY29uY2lsZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnNldFBhcmVudChwYXJlbnQsIHN1YnBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY3VycmVudCBub2RlIGNhbm5vdCBiZSByZWN5Y2xlZCBpbiBhbnkgd2F5XG4gICAgICAgICAgICBjdXJyZW50LmRpZSgpOyAvLyBub29wIGlmIGRldGFjaGluZ1xuICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byByZXVzZSB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgaWYgKGlzU3RhdGVUcmVlTm9kZShuZXdWYWx1ZSkgJiYgdGhpcy5pc0Fzc2lnbmFibGVGcm9tKGdldFR5cGUobmV3VmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIC8vIG5ld1ZhbHVlIGlzIGEgTm9kZSBhcyB3ZWxsLCBtb3ZlIGl0IGhlcmUuLlxuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gZ2V0U3RhdGVUcmVlTm9kZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5zZXRQYXJlbnQocGFyZW50LCBzdWJwYXRoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG8sIHdlIGhhdmUgdG8gY3JlYXRlIGEgbmV3IG5vZGVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbnRpYXRlKHBhcmVudCwgc3VicGF0aCwgdW5kZWZpbmVkLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcGxleFR5cGUucHJvdG90eXBlLCBcImdldFN1YlR5cGVzXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDb21wbGV4VHlwZTtcbn0oQmFzZVR5cGUpKTtcbkNvbXBsZXhUeXBlLnByb3RvdHlwZS5jcmVhdGUgPSBhY3Rpb24oQ29tcGxleFR5cGUucHJvdG90eXBlLmNyZWF0ZSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG52YXIgU2ltcGxlVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2ltcGxlVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaW1wbGVUeXBlKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVUeXBlLnByb3RvdHlwZSwgXCJjcmVhdGVOZXdJbnN0YW5jZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlVHlwZS5wcm90b3R5cGUsIFwiZ2V0VmFsdWVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBldmVyIGZpbmQgYSBjYXNlIHdoZXJlIHNjYWxhciBub2RlcyBjYW4gYmUgYWNjZXNzZWQgd2l0aG91dCBpdGVyYXRpbmcgdGhyb3VnaCBpdHMgcGFyZW50XG4gICAgICAgICAgICAvLyB1bmNvbW1lbnQgdGhpcyB0byBtYWtlIHN1cmUgdGhlIHBhcmVudCBjaGFpbiBpcyBjcmVhdGVkIHdoZW4gdGhpcyBpcyBhY2Nlc3NlZFxuICAgICAgICAgICAgLy8gaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICAvLyAgICAgbm9kZS5wYXJlbnQuY3JlYXRlT2JzZXJ2YWJsZUluc3RhbmNlSWZOZWVkZWQoKVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3RvcmVkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2ltcGxlVHlwZS5wcm90b3R5cGUsIFwiZ2V0U25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zdG9yZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVUeXBlLnByb3RvdHlwZSwgXCJyZWNvbmNpbGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjdXJyZW50LCBuZXdWYWx1ZSwgcGFyZW50LCBzdWJwYXRoKSB7XG4gICAgICAgICAgICAvLyByZWNvbmNpbGUgb25seSBpZiB0eXBlIGFuZCB2YWx1ZSBhcmUgc3RpbGwgdGhlIHNhbWUsIGFuZCBvbmx5IGlmIHRoZSBub2RlIGlzIG5vdCBkZXRhY2hpbmdcbiAgICAgICAgICAgIGlmICghY3VycmVudC5pc0RldGFjaGluZyAmJiBjdXJyZW50LnR5cGUgPT09IHRoaXMgJiYgY3VycmVudC5zdG9yZWRWYWx1ZSA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLmluc3RhbnRpYXRlKHBhcmVudCwgc3VicGF0aCwgdW5kZWZpbmVkLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICBjdXJyZW50LmRpZSgpOyAvLyBub29wIGlmIGRldGFjaGluZ1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVUeXBlLnByb3RvdHlwZSwgXCJnZXRTdWJUeXBlc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gU2ltcGxlVHlwZTtcbn0oQmFzZVR5cGUpKTtcbi8qKlxuICogUmV0dXJucyBpZiBhIGdpdmVuIHZhbHVlIHJlcHJlc2VudHMgYSB0eXBlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSB0eXBlLlxuICovXG5mdW5jdGlvbiBpc1R5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICYmIHZhbHVlLmlzVHlwZSA9PT0gdHJ1ZTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzVHlwZSh0eXBlLCBhcmdOdW1iZXIpIHtcbiAgICBhc3NlcnRBcmcodHlwZSwgaXNUeXBlLCBcIm1vYngtc3RhdGUtdHJlZSB0eXBlXCIsIGFyZ051bWJlcik7XG59XG5cbnZhciBydW5uaW5nQWN0aW9ucyA9IG5ldyBNYXAoKTtcbi8qKlxuICogTm90ZTogQ29uc2lkZXIgbWlncmF0aW5nIHRvIGBjcmVhdGVBY3Rpb25UcmFja2luZ01pZGRsZXdhcmUyYCwgaXQgaXMgZWFzaWVyIHRvIHVzZS5cbiAqXG4gKiBDb252ZW5pZW5jZSB1dGlsaXR5IHRvIGNyZWF0ZSBhY3Rpb24gYmFzZWQgbWlkZGxld2FyZSB0aGF0IHN1cHBvcnRzIGFzeW5jIHByb2Nlc3NlcyBtb3JlIGVhc2lseS5cbiAqIEFsbCBob29rcyBhcmUgY2FsbGVkIGZvciBib3RoIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXMgYWN0aW9ucy4gRXhjZXB0IHRoYXQgZWl0aGVyIGBvblN1Y2Nlc3NgIG9yIGBvbkZhaWxgIGlzIGNhbGxlZFxuICpcbiAqIFRoZSBjcmVhdGUgbWlkZGxld2FyZSB0cmFja3MgdGhlIHByb2Nlc3Mgb2YgYW4gYWN0aW9uIChhc3N1bWluZyBpdCBwYXNzZXMgdGhlIGBmaWx0ZXJgKS5cbiAqIGBvblJlc3VtZWAgY2FuIHJldHVybiBhbnkgdmFsdWUsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGFzIHNlY29uZCBhcmd1bWVudCB0byBhbnkgb3RoZXIgaG9vay4gVGhpcyBtYWtlcyBpdCBwb3NzaWJsZSB0byBrZWVwIHN0YXRlIGR1cmluZyBhIHByb2Nlc3MuXG4gKlxuICogU2VlIHRoZSBgYXRvbWljYCBtaWRkbGV3YXJlIGZvciBhbiBleGFtcGxlXG4gKlxuICogQHBhcmFtIGhvb2tzXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25UcmFja2luZ01pZGRsZXdhcmUoaG9va3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYWN0aW9uVHJhY2tpbmdNaWRkbGV3YXJlKGNhbGwsIG5leHQsIGFib3J0KSB7XG4gICAgICAgIHN3aXRjaCAoY2FsbC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAoIWhvb2tzLmZpbHRlciB8fCBob29rcy5maWx0ZXIoY2FsbCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBob29rcy5vblN0YXJ0KGNhbGwpO1xuICAgICAgICAgICAgICAgICAgICBob29rcy5vblJlc3VtZShjYWxsLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ0FjdGlvbnMuc2V0KGNhbGwuaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGw6IGNhbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IG5leHQoY2FsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rcy5vblN1c3BlbmQoY2FsbCwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZ0FjdGlvbnMuZ2V0KGNhbGwuaWQpLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdBY3Rpb25zLmRlbGV0ZShjYWxsLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob29rcy5vblN1Y2Nlc3MoY2FsbCwgY29udGV4dCwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdBY3Rpb25zLmRlbGV0ZShjYWxsLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvb2tzLm9uRmFpbChjYWxsLCBjb250ZXh0LCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KGNhbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmbG93X3NwYXduXCI6IHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHJ1bm5pbmdBY3Rpb25zLmdldChjYWxsLnJvb3RJZCk7XG4gICAgICAgICAgICAgICAgcm9vdC5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoY2FsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmxvd19yZXN1bWVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmbG93X3Jlc3VtZV9lcnJvclwiOiB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBydW5uaW5nQWN0aW9ucy5nZXQoY2FsbC5yb290SWQpO1xuICAgICAgICAgICAgICAgIGhvb2tzLm9uUmVzdW1lKGNhbGwsIHJvb3QuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoY2FsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBob29rcy5vblN1c3BlbmQoY2FsbCwgcm9vdC5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmxvd190aHJvd1wiOiB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBydW5uaW5nQWN0aW9ucy5nZXQoY2FsbC5yb290SWQpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdBY3Rpb25zLmRlbGV0ZShjYWxsLnJvb3RJZCk7XG4gICAgICAgICAgICAgICAgaG9va3Mub25GYWlsKGNhbGwsIHJvb3QuY29udGV4dCwgY2FsbC5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChjYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmbG93X3JldHVyblwiOiB7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBydW5uaW5nQWN0aW9ucy5nZXQoY2FsbC5yb290SWQpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdBY3Rpb25zLmRlbGV0ZShjYWxsLnJvb3RJZCk7XG4gICAgICAgICAgICAgICAgaG9va3Mub25TdWNjZXNzKGNhbGwsIHJvb3QuY29udGV4dCwgY2FsbC5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChjYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbnZhciBSdW5uaW5nQWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJ1bm5pbmdBY3Rpb24oaG9va3MsIGNhbGwpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaG9va3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGhvb2tzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBjYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmbG93c1BlbmRpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJ1bm5pbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChob29rcykge1xuICAgICAgICAgICAgaG9va3Mub25TdGFydChjYWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVubmluZ0FjdGlvbi5wcm90b3R5cGUsIFwiZmluaXNoXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhvb2tzLm9uRmluaXNoKHRoaXMuY2FsbCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5uaW5nQWN0aW9uLnByb3RvdHlwZSwgXCJpbmNGbG93c1BlbmRpbmdcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmxvd3NQZW5kaW5nKys7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnVubmluZ0FjdGlvbi5wcm90b3R5cGUsIFwiZGVjRmxvd3NQZW5kaW5nXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZsb3dzUGVuZGluZy0tO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bm5pbmdBY3Rpb24ucHJvdG90eXBlLCBcImhhc0Zsb3dzUGVuZGluZ1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd3NQZW5kaW5nID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBSdW5uaW5nQWN0aW9uO1xufSgpKTtcbi8qKlxuICogQ29udmVuaWVuY2UgdXRpbGl0eSB0byBjcmVhdGUgYWN0aW9uIGJhc2VkIG1pZGRsZXdhcmUgdGhhdCBzdXBwb3J0cyBhc3luYyBwcm9jZXNzZXMgbW9yZSBlYXNpbHkuXG4gKiBUaGUgZmxvdyBpcyBsaWtlIHRoaXM6XG4gKiAtIGZvciBlYWNoIGFjdGlvbjogaWYgZmlsdGVyIHBhc3NlcyAtPiBgb25TdGFydGAgLT4gKGlubmVyIGFjdGlvbnMgcmVjdXJzaXZlbHkpIC0+IGBvbkZpbmlzaGBcbiAqXG4gKiBFeGFtcGxlOiBpZiB3ZSBoYWQgYW4gYWN0aW9uIGBhYCB0aGF0IGNhbGxlZCBpbnNpZGUgYW4gYWN0aW9uIGBiMWAsIHRoZW4gYGIyYCB0aGUgZmxvdyB3b3VsZCBiZTpcbiAqIC0gYGZpbHRlcihhKWBcbiAqIC0gYG9uU3RhcnQoYSlgXG4gKiAgIC0gYGZpbHRlcihiMSlgXG4gKiAgIC0gYG9uU3RhcnQoYjEpYFxuICogICAtIGBvbkZpbmlzaChiMSlgXG4gKiAgIC0gYGZpbHRlcihiMilgXG4gKiAgIC0gYG9uU3RhcnQoYjIpYFxuICogICAtIGBvbkZpbmlzaChiMilgXG4gKiAtIGBvbkZpbmlzaChhKWBcbiAqXG4gKiBUaGUgZmxvdyBpcyB0aGUgc2FtZSBubyBtYXR0ZXIgaWYgdGhlIGFjdGlvbnMgYXJlIHN5bmMgb3IgYXN5bmMuXG4gKlxuICogU2VlIHRoZSBgYXRvbWljYCBtaWRkbGV3YXJlIGZvciBhbiBleGFtcGxlXG4gKlxuICogQHBhcmFtIGhvb2tzXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25UcmFja2luZ01pZGRsZXdhcmUyKG1pZGRsZXdhcmVIb29rcykge1xuICAgIHZhciBydW5uaW5nQWN0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFjdGlvblRyYWNraW5nTWlkZGxld2FyZShjYWxsLCBuZXh0KSB7XG4gICAgICAgIC8vIGZpbmQgcGFyZW50UnVubmluZ0FjdGlvblxuICAgICAgICB2YXIgcGFyZW50UnVubmluZ0FjdGlvbiA9IGNhbGwucGFyZW50QWN0aW9uRXZlbnRcbiAgICAgICAgICAgID8gcnVubmluZ0FjdGlvbnMuZ2V0KGNhbGwucGFyZW50QWN0aW9uRXZlbnQpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNhbGwudHlwZSA9PT0gXCJhY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIG5ld0NhbGwgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY2FsbCksIHsgXG4gICAgICAgICAgICAgICAgLy8gbWFrZSBhIHNoYWxsb3cgY29weSBvZiB0aGUgcGFyZW50IGFjdGlvbiBlbnZcbiAgICAgICAgICAgICAgICBlbnY6IHBhcmVudFJ1bm5pbmdBY3Rpb24gJiYgcGFyZW50UnVubmluZ0FjdGlvbi5jYWxsLmVudiwgcGFyZW50Q2FsbDogcGFyZW50UnVubmluZ0FjdGlvbiAmJiBwYXJlbnRSdW5uaW5nQWN0aW9uLmNhbGwgfSk7XG4gICAgICAgICAgICB2YXIgcGFzc2VzRmlsdGVyID0gIW1pZGRsZXdhcmVIb29rcy5maWx0ZXIgfHwgbWlkZGxld2FyZUhvb2tzLmZpbHRlcihuZXdDYWxsKTtcbiAgICAgICAgICAgIHZhciBob29rcyA9IHBhc3Nlc0ZpbHRlciA/IG1pZGRsZXdhcmVIb29rcyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBydW5uaW5nQWN0aW9uID0gbmV3IFJ1bm5pbmdBY3Rpb24oaG9va3MsIG5ld0NhbGwpO1xuICAgICAgICAgICAgcnVubmluZ0FjdGlvbnMuc2V0KGNhbGwsIHJ1bm5pbmdBY3Rpb24pO1xuICAgICAgICAgICAgdmFyIHJlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbmV4dChjYWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcnVubmluZ0FjdGlvbi5maW5pc2goZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVubmluZ0FjdGlvbi5oYXNGbG93c1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBzeW5jIGFjdGlvbiBmaW5pc2hlZFxuICAgICAgICAgICAgICAgIHJ1bm5pbmdBY3Rpb24uZmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRSdW5uaW5nQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoY2FsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNhbGwudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmbG93X3NwYXduXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50UnVubmluZ0FjdGlvbi5pbmNGbG93c1BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoY2FsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJmbG93X3Jlc3VtZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmbG93X3Jlc3VtZV9lcnJvclwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KGNhbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZmxvd190aHJvd1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IGNhbGwuYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KGNhbGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UnVubmluZ0FjdGlvbi5kZWNGbG93c1BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50UnVubmluZ0FjdGlvbi5oYXNGbG93c1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSdW5uaW5nQWN0aW9uLmZpbmlzaChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImZsb3dfcmV0dXJuXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KGNhbGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50UnVubmluZ0FjdGlvbi5kZWNGbG93c1BlbmRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50UnVubmluZ0FjdGlvbi5oYXNGbG93c1BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRSdW5uaW5nQWN0aW9uLmZpbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplQXJndW1lbnQobm9kZSwgYWN0aW9uTmFtZSwgaW5kZXgsIGFyZykge1xuICAgIGlmIChhcmcgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICByZXR1cm4geyAkTVNUX0RBVEU6IGFyZy5nZXRUaW1lKCkgfTtcbiAgICBpZiAoaXNQcmltaXRpdmUoYXJnKSlcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICAvLyBXZSBzaG91bGQgbm90IHNlcmlhbGl6ZSBNU1Qgbm9kZXMsIGV2ZW4gaWYgd2UgY2FuLCBiZWNhdXNlIHdlIGRvbid0IGtub3cgaWYgdGhlIHJlY2VpdmluZyBwYXJ0eSBjYW4gaGFuZGxlIGEgcmF3IHNuYXBzaG90IGluc3RlYWQgb2YgYW5cbiAgICAvLyBNU1QgdHlwZSBpbnN0YW5jZS4gU28gaWYgb25lIHdhbnRzIHRvIHNlcmlhbGl6ZSBhIE1TVCBub2RlIHRoYXQgd2FzIHBhc3MgaW4sIGVpdGhlciBleHBsaXRseSBwYXNzOiAxOiBhbiBpZCwgMjogYSAocmVsYXRpdmUpIHBhdGgsIDM6IGEgc25hcHNob3RcbiAgICBpZiAoaXNTdGF0ZVRyZWVOb2RlKGFyZykpXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVUaGVVbnNlcmlhbGl6YWJsZShcIltNU1ROb2RlOiBcIiArIGdldFR5cGUoYXJnKS5uYW1lICsgXCJdXCIpO1xuICAgIGlmICh0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVUaGVVbnNlcmlhbGl6YWJsZShcIltmdW5jdGlvbl1cIik7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIgJiYgIWlzUGxhaW5PYmplY3QoYXJnKSAmJiAhaXNBcnJheShhcmcpKVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplVGhlVW5zZXJpYWxpemFibGUoXCJbb2JqZWN0IFwiICsgKChhcmcgJiYgYXJnLmNvbnN0cnVjdG9yICYmIGFyZy5jb25zdHJ1Y3Rvci5uYW1lKSB8fFxuICAgICAgICAgICAgXCJDb21wbGV4IE9iamVjdFwiKSArIFwiXVwiKTtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBpZiBzZXJpYWxpemFibGUsIGN5Y2xlIGZyZWUgZXRjLi4uXG4gICAgICAgIC8vIE1XRTogdGhlcmUgbXVzdCBiZSBhIGJldHRlciB3YXkuLi4uXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGFyZyk7IC8vIG9yIHRocm93c1xuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplVGhlVW5zZXJpYWxpemFibGUoXCJcIiArIGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplQXJndW1lbnQoYWRtLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCIkTVNUX0RBVEVcIiBpbiB2YWx1ZSlcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlW1wiJE1TVF9EQVRFXCJdKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUaGVVbnNlcmlhbGl6YWJsZShiYXNlVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgICRNU1RfVU5TRVJJQUxJWkFCTEU6IHRydWUsXG4gICAgICAgIHR5cGU6IGJhc2VUeXBlXG4gICAgfTtcbn1cbi8qKlxuICogQXBwbGllcyBhbiBhY3Rpb24gb3IgYSBzZXJpZXMgb2YgYWN0aW9ucyBpbiBhIHNpbmdsZSBNb2JYIHRyYW5zYWN0aW9uLlxuICogRG9lcyBub3QgcmV0dXJuIGFueSB2YWx1ZVxuICogVGFrZXMgYW4gYWN0aW9uIGRlc2NyaXB0aW9uIGFzIHByb2R1Y2VkIGJ5IHRoZSBgb25BY3Rpb25gIG1pZGRsZXdhcmUuXG4gKlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIGFjdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlBY3Rpb24odGFyZ2V0LCBhY3Rpb25zKSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZSh0YXJnZXQsIDEpO1xuICAgIGFzc2VydEFyZyhhY3Rpb25zLCBmdW5jdGlvbiAoYSkgeyByZXR1cm4gdHlwZW9mIGEgPT09IFwib2JqZWN0XCI7IH0sIFwib2JqZWN0IG9yIGFycmF5XCIsIDIpO1xuICAgIHJ1bkluQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXNBcnJheShhY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGJhc2VBcHBseUFjdGlvbih0YXJnZXQsIGFjdGlvbik7IH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYmFzZUFwcGx5QWN0aW9uKHRhcmdldCwgYWN0aW9uKSB7XG4gICAgdmFyIHJlc29sdmVkVGFyZ2V0ID0gdHJ5UmVzb2x2ZSh0YXJnZXQsIGFjdGlvbi5wYXRoIHx8IFwiXCIpO1xuICAgIGlmICghcmVzb2x2ZWRUYXJnZXQpXG4gICAgICAgIHRocm93IGZhaWwkMShcIkludmFsaWQgYWN0aW9uIHBhdGg6IFwiICsgKGFjdGlvbi5wYXRoIHx8IFwiXCIpKTtcbiAgICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUocmVzb2x2ZWRUYXJnZXQpO1xuICAgIC8vIFJlc2VydmVkIGZ1bmN0aW9uc1xuICAgIGlmIChhY3Rpb24ubmFtZSA9PT0gXCJAQVBQTFlfUEFUQ0hFU1wiKSB7XG4gICAgICAgIHJldHVybiBhcHBseVBhdGNoLmNhbGwobnVsbCwgcmVzb2x2ZWRUYXJnZXQsIGFjdGlvbi5hcmdzWzBdKTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbi5uYW1lID09PSBcIkBBUFBMWV9TTkFQU0hPVFwiKSB7XG4gICAgICAgIHJldHVybiBhcHBseVNuYXBzaG90LmNhbGwobnVsbCwgcmVzb2x2ZWRUYXJnZXQsIGFjdGlvbi5hcmdzWzBdKTtcbiAgICB9XG4gICAgaWYgKCEodHlwZW9mIHJlc29sdmVkVGFyZ2V0W2FjdGlvbi5uYW1lXSA9PT0gXCJmdW5jdGlvblwiKSlcbiAgICAgICAgdGhyb3cgZmFpbCQxKFwiQWN0aW9uICdcIiArIGFjdGlvbi5uYW1lICsgXCInIGRvZXMgbm90IGV4aXN0IGluICdcIiArIG5vZGUucGF0aCArIFwiJ1wiKTtcbiAgICByZXR1cm4gcmVzb2x2ZWRUYXJnZXRbYWN0aW9uLm5hbWVdLmFwcGx5KHJlc29sdmVkVGFyZ2V0LCBhY3Rpb24uYXJncyA/IGFjdGlvbi5hcmdzLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gZGVzZXJpYWxpemVBcmd1bWVudChub2RlLCB2KTsgfSkgOiBbXSk7XG59XG4vKipcbiAqIFNtYWxsIGFic3RyYWN0aW9uIGFyb3VuZCBgb25BY3Rpb25gIGFuZCBgYXBwbHlBY3Rpb25gLCBhdHRhY2hlcyBhbiBhY3Rpb24gbGlzdGVuZXIgdG8gYSB0cmVlIGFuZCByZWNvcmRzIGFsbCB0aGUgYWN0aW9ucyBlbWl0dGVkLlxuICogUmV0dXJucyBhbiByZWNvcmRlciBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGV4cG9ydCBpbnRlcmZhY2UgSUFjdGlvblJlY29yZGVyIHtcbiAqICAgICAgLy8gdGhlIHJlY29yZGVkIGFjdGlvbnNcbiAqICAgICAgYWN0aW9uczogSVNlcmlhbGl6ZWRBY3Rpb25DYWxsW11cbiAqICAgICAgLy8gdHJ1ZSBpZiBjdXJyZW50bHkgcmVjb3JkaW5nXG4gKiAgICAgIHJlY29yZGluZzogYm9vbGVhblxuICogICAgICAvLyBzdG9wIHJlY29yZGluZyBhY3Rpb25zXG4gKiAgICAgIHN0b3AoKTogdm9pZFxuICogICAgICAvLyByZXN1bWUgcmVjb3JkaW5nIGFjdGlvbnNcbiAqICAgICAgcmVzdW1lKCk6IHZvaWRcbiAqICAgICAgLy8gYXBwbHkgYWxsIHRoZSByZWNvcmRlZCBhY3Rpb25zIG9uIHRoZSBnaXZlbiBvYmplY3RcbiAqICAgICAgcmVwbGF5KHRhcmdldDogSUFueVN0YXRlVHJlZU5vZGUpOiB2b2lkXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGUgb3B0aW9uYWwgZmlsdGVyIGZ1bmN0aW9uIGFsbG93cyB0byBza2lwIHJlY29yZGluZyBjZXJ0YWluIGFjdGlvbnMuXG4gKlxuICogQHBhcmFtIHN1YmplY3RcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHJlY29yZEFjdGlvbnMoc3ViamVjdCwgZmlsdGVyKSB7XG4gICAgLy8gY2hlY2sgYWxsIGFyZ3VtZW50c1xuICAgIGFzc2VydElzU3RhdGVUcmVlTm9kZShzdWJqZWN0LCAxKTtcbiAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChjYWxsKSB7XG4gICAgICAgIHZhciByZWNvcmRUaGlzID0gZmlsdGVyID8gZmlsdGVyKGNhbGwsIGdldFJ1bm5pbmdBY3Rpb25Db250ZXh0KCkpIDogdHJ1ZTtcbiAgICAgICAgaWYgKHJlY29yZFRoaXMpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChjYWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGRpc3Bvc2VyO1xuICAgIHZhciByZWNvcmRlciA9IHtcbiAgICAgICAgYWN0aW9uczogYWN0aW9ucyxcbiAgICAgICAgZ2V0IHJlY29yZGluZygpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWRpc3Bvc2VyO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZGlzcG9zZXIpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlcigpO1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkaXNwb3NlcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBkaXNwb3NlciA9IG9uQWN0aW9uKHN1YmplY3QsIGxpc3RlbmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVwbGF5OiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBhcHBseUFjdGlvbih0YXJnZXQsIGFjdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZWNvcmRlci5yZXN1bWUoKTtcbiAgICByZXR1cm4gcmVjb3JkZXI7XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBpbnZva2VkIGZvciBlYWNoIGFjdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiB0aGUgcHJvdmlkZWQgbW9kZWwgaW5zdGFuY2UsIG9yIHRvIGFueSBvZiBpdHMgY2hpbGRyZW4uXG4gKiBTZWUgW2FjdGlvbnNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1zdGF0ZS10cmVlI2FjdGlvbnMpIGZvciBtb3JlIGRldGFpbHMuIG9uQWN0aW9uIGV2ZW50cyBhcmUgZW1pdHRlZCBvbmx5IGZvciB0aGUgb3V0ZXJtb3N0IGNhbGxlZCBhY3Rpb24gaW4gdGhlIHN0YWNrLlxuICogQWN0aW9uIGNhbiBhbHNvIGJlIGludGVyY2VwdGVkIGJ5IG1pZGRsZXdhcmUgdXNpbmcgYWRkTWlkZGxld2FyZSB0byBjaGFuZ2UgdGhlIGZ1bmN0aW9uIGNhbGwgYmVmb3JlIGl0IHdpbGwgYmUgcnVuLlxuICpcbiAqIE5vdCBhbGwgYWN0aW9uIGFyZ3VtZW50cyBtaWdodCBiZSBzZXJpYWxpemFibGUuIEZvciB1bnNlcmlhbGl6YWJsZSBhcmd1bWVudHMsIGEgc3RydWN0IGxpa2UgYHsgJE1TVF9VTlNFUklBTElaQUJMRTogdHJ1ZSwgdHlwZTogXCJzb21lVHlwZVwiIH1gIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICogTVNUIE5vZGVzIGFyZSBjb25zaWRlcmVkIG5vbi1zZXJpYWxpemFibGUgYXMgd2VsbCAodGhleSBjb3VsZCBiZSBzZXJpYWxpemVkIGFzIHRoZXJlIHNuYXBzaG90LCBidXQgaXQgaXMgdW5jZXJ0YWluIHdoZXRoZXIgYW4gcmVwbGF5aW5nIHBhcnR5IHdpbGwgYmUgYWJsZSB0byBoYW5kbGUgc3VjaCBhIG5vbi1pbnN0YW50aWF0ZWQgc25hcHNob3QpLlxuICogUmF0aGVyLCB3aGVuIHVzaW5nIGBvbkFjdGlvbmAgbWlkZGxld2FyZSwgb25lIHNob3VsZCBjb25zaWRlciBpbiBwYXNzaW5nIGFyZ3VtZW50cyB3aGljaCBhcmUgMTogYW4gaWQsIDI6IGEgKHJlbGF0aXZlKSBwYXRoLCBvciAzOiBhIHNuYXBzaG90LiBJbnN0ZWFkIG9mIGEgcmVhbCBNU1Qgbm9kZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IFRvZG8gPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHRhc2s6IHR5cGVzLnN0cmluZ1xuICogfSlcbiAqXG4gKiBjb25zdCBUb2RvU3RvcmUgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHRvZG9zOiB0eXBlcy5hcnJheShUb2RvKVxuICogfSkuYWN0aW9ucyhzZWxmID0+ICh7XG4gKiAgIGFkZCh0b2RvKSB7XG4gKiAgICAgc2VsZi50b2Rvcy5wdXNoKHRvZG8pO1xuICogICB9XG4gKiB9KSlcbiAqXG4gKiBjb25zdCBzID0gVG9kb1N0b3JlLmNyZWF0ZSh7IHRvZG9zOiBbXSB9KVxuICpcbiAqIGxldCBkaXNwb3NlciA9IG9uQWN0aW9uKHMsIChjYWxsKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKGNhbGwpO1xuICogfSlcbiAqXG4gKiBzLmFkZCh7IHRhc2s6IFwiR3JhYiBhIGNvZmZlZVwiIH0pXG4gKiAvLyBMb2dzOiB7IG5hbWU6IFwiYWRkXCIsIHBhdGg6IFwiXCIsIGFyZ3M6IFt7IHRhc2s6IFwiR3JhYiBhIGNvZmZlZVwiIH1dIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSBsaXN0ZW5lclxuICogQHBhcmFtIGF0dGFjaEFmdGVyIChkZWZhdWx0IGZhbHNlKSBmaXJlcyB0aGUgbGlzdGVuZXIgKmFmdGVyKiB0aGUgYWN0aW9uIGhhcyBleGVjdXRlZCBpbnN0ZWFkIG9mIGJlZm9yZS5cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIG9uQWN0aW9uKHRhcmdldCwgbGlzdGVuZXIsIGF0dGFjaEFmdGVyKSB7XG4gICAgaWYgKGF0dGFjaEFmdGVyID09PSB2b2lkIDApIHsgYXR0YWNoQWZ0ZXIgPSBmYWxzZTsgfVxuICAgIC8vIGNoZWNrIGFsbCBhcmd1bWVudHNcbiAgICBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodGFyZ2V0LCAxKTtcbiAgICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgICAgIGlmICghaXNSb290KHRhcmdldCkpXG4gICAgICAgICAgICB3YXJuRXJyb3IoXCJXYXJuaW5nOiBBdHRhY2hpbmcgb25BY3Rpb24gbGlzdGVuZXJzIHRvIG5vbiByb290IG5vZGVzIGlzIGRhbmdlcm91czogTm8gZXZlbnRzIHdpbGwgYmUgZW1pdHRlZCBmb3IgYWN0aW9ucyBpbml0aWF0ZWQgaGlnaGVyIHVwIGluIHRoZSB0cmVlLlwiKTtcbiAgICAgICAgaWYgKCFpc1Byb3RlY3RlZCh0YXJnZXQpKVxuICAgICAgICAgICAgd2FybkVycm9yKFwiV2FybmluZzogQXR0YWNoaW5nIG9uQWN0aW9uIGxpc3RlbmVycyB0byBub24gcHJvdGVjdGVkIG5vZGVzIGlzIGRhbmdlcm91czogTm8gZXZlbnRzIHdpbGwgYmUgZW1pdHRlZCBmb3IgZGlyZWN0IG1vZGlmaWNhdGlvbnMgd2l0aG91dCBhY3Rpb24uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkTWlkZGxld2FyZSh0YXJnZXQsIGZ1bmN0aW9uIGhhbmRsZXIocmF3Q2FsbCwgbmV4dCkge1xuICAgICAgICBpZiAocmF3Q2FsbC50eXBlID09PSBcImFjdGlvblwiICYmIHJhd0NhbGwuaWQgPT09IHJhd0NhbGwucm9vdElkKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlTm9kZV8xID0gZ2V0U3RhdGVUcmVlTm9kZShyYXdDYWxsLmNvbnRleHQpO1xuICAgICAgICAgICAgdmFyIGluZm8gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogcmF3Q2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgIHBhdGg6IGdldFJlbGF0aXZlUGF0aEJldHdlZW5Ob2RlcyhnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCksIHNvdXJjZU5vZGVfMSksXG4gICAgICAgICAgICAgICAgYXJnczogcmF3Q2FsbC5hcmdzLm1hcChmdW5jdGlvbiAoYXJnLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplQXJndW1lbnQoc291cmNlTm9kZV8xLCByYXdDYWxsLm5hbWUsIGluZGV4LCBhcmcpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGF0dGFjaEFmdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IG5leHQocmF3Q2FsbCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoaW5mbyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGluZm8pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KHJhd0NhbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQocmF3Q2FsbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxudmFyIG5leHRBY3Rpb25JZCA9IDE7XG52YXIgY3VycmVudEFjdGlvbkNvbnRleHQ7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50QWN0aW9uQ29udGV4dCgpIHtcbiAgICByZXR1cm4gY3VycmVudEFjdGlvbkNvbnRleHQ7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBnZXROZXh0QWN0aW9uSWQoKSB7XG4gICAgcmV0dXJuIG5leHRBY3Rpb25JZCsrO1xufVxuLy8gVE9ETzogb3B0aW1pemUgYXdheSBlbnRpcmUgYWN0aW9uIGNvbnRleHQgaWYgdGhlcmUgaXMgbm8gbWlkZGxld2FyZSBpbiB0cmVlP1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gcnVuV2l0aEFjdGlvbkNvbnRleHQoY29udGV4dCwgZm4pIHtcbiAgICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUoY29udGV4dC5jb250ZXh0KTtcbiAgICBpZiAoY29udGV4dC50eXBlID09PSBcImFjdGlvblwiKSB7XG4gICAgICAgIG5vZGUuYXNzZXJ0QWxpdmUoe1xuICAgICAgICAgICAgYWN0aW9uQ29udGV4dDogY29udGV4dFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGJhc2VJc1J1bm5pbmdBY3Rpb24gPSBub2RlLl9pc1J1bm5pbmdBY3Rpb247XG4gICAgbm9kZS5faXNSdW5uaW5nQWN0aW9uID0gdHJ1ZTtcbiAgICB2YXIgcHJldmlvdXNDb250ZXh0ID0gY3VycmVudEFjdGlvbkNvbnRleHQ7XG4gICAgY3VycmVudEFjdGlvbkNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBydW5NaWRkbGVXYXJlcyhub2RlLCBjb250ZXh0LCBmbik7XG4gICAgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50QWN0aW9uQ29udGV4dCA9IHByZXZpb3VzQ29udGV4dDtcbiAgICAgICAgbm9kZS5faXNSdW5uaW5nQWN0aW9uID0gYmFzZUlzUnVubmluZ0FjdGlvbjtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRBY3Rpb25Db250ZXh0KHBhcmVudENvbnRleHQpIHtcbiAgICBpZiAoIXBhcmVudENvbnRleHQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudENvbnRleHQudHlwZSA9PT0gXCJhY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQucGFyZW50QWN0aW9uRXZlbnQ7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25JbnZva2VyKHRhcmdldCwgbmFtZSwgZm4pIHtcbiAgICB2YXIgcmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSBnZXROZXh0QWN0aW9uSWQoKTtcbiAgICAgICAgdmFyIHBhcmVudENvbnRleHQgPSBjdXJyZW50QWN0aW9uQ29udGV4dDtcbiAgICAgICAgdmFyIHBhcmVudEFjdGlvbkNvbnRleHQgPSBnZXRQYXJlbnRBY3Rpb25Db250ZXh0KHBhcmVudENvbnRleHQpO1xuICAgICAgICByZXR1cm4gcnVuV2l0aEFjdGlvbkNvbnRleHQoe1xuICAgICAgICAgICAgdHlwZTogXCJhY3Rpb25cIixcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBhcmdzOiBhcmdzVG9BcnJheShhcmd1bWVudHMpLFxuICAgICAgICAgICAgY29udGV4dDogdGFyZ2V0LFxuICAgICAgICAgICAgdHJlZTogZ2V0Um9vdCh0YXJnZXQpLFxuICAgICAgICAgICAgcm9vdElkOiBwYXJlbnRDb250ZXh0ID8gcGFyZW50Q29udGV4dC5yb290SWQgOiBpZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBwYXJlbnRDb250ZXh0ID8gcGFyZW50Q29udGV4dC5pZCA6IDAsXG4gICAgICAgICAgICBhbGxQYXJlbnRJZHM6IHBhcmVudENvbnRleHRcbiAgICAgICAgICAgICAgICA/IF9fc3ByZWFkKHBhcmVudENvbnRleHQuYWxsUGFyZW50SWRzLCBbcGFyZW50Q29udGV4dC5pZF0pIDogW10sXG4gICAgICAgICAgICBwYXJlbnRFdmVudDogcGFyZW50Q29udGV4dCxcbiAgICAgICAgICAgIHBhcmVudEFjdGlvbkV2ZW50OiBwYXJlbnRBY3Rpb25Db250ZXh0XG4gICAgICAgIH0sIGZuKTtcbiAgICB9O1xuICAgIHJlcy5faXNNU1RBY3Rpb24gPSB0cnVlO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIE1pZGRsZXdhcmUgY2FuIGJlIHVzZWQgdG8gaW50ZXJjZXB0IGFueSBhY3Rpb24gaXMgaW52b2tlZCBvbiB0aGUgc3VidHJlZSB3aGVyZSBpdCBpcyBhdHRhY2hlZC5cbiAqIElmIGEgdHJlZSBpcyBwcm90ZWN0ZWQgKGJ5IGRlZmF1bHQpLCB0aGlzIG1lYW5zIHRoYXQgYW55IG11dGF0aW9uIG9mIHRoZSB0cmVlIHdpbGwgcGFzcyB0aHJvdWdoIHlvdXIgbWlkZGxld2FyZS5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIFttaWRkbGV3YXJlIGRvY3NdKGNvbmNlcHRzL21pZGRsZXdhcmUubWQpXG4gKlxuICogQHBhcmFtIHRhcmdldCBOb2RlIHRvIGFwcGx5IHRoZSBtaWRkbGV3YXJlIHRvLlxuICogQHBhcmFtIG1pZGRsZXdhcmUgTWlkZGxld2FyZSB0byBhcHBseS5cbiAqIEByZXR1cm5zIEEgY2FsbGFibGUgZnVuY3Rpb24gdG8gZGlzcG9zZSB0aGUgbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gYWRkTWlkZGxld2FyZSh0YXJnZXQsIGhhbmRsZXIsIGluY2x1ZGVIb29rcykge1xuICAgIGlmIChpbmNsdWRlSG9va3MgPT09IHZvaWQgMCkgeyBpbmNsdWRlSG9va3MgPSB0cnVlOyB9XG4gICAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKHRhcmdldCk7XG4gICAgaWYgKGRldk1vZGUoKSkge1xuICAgICAgICBpZiAoIW5vZGUuaXNQcm90ZWN0aW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgd2FybkVycm9yKFwiSXQgaXMgcmVjb21tZW5kZWQgdG8gcHJvdGVjdCB0aGUgc3RhdGUgdHJlZSBiZWZvcmUgYXR0YWNoaW5nIGFjdGlvbiBtaWRkbGV3YXJlLCBhcyBvdGhlcndpc2UgaXQgY2Fubm90IGJlIGd1YXJhbnRlZWQgdGhhdCBhbGwgY2hhbmdlcyBhcmUgcGFzc2VkIHRocm91Z2ggbWlkZGxld2FyZS4gU2VlIGBwcm90ZWN0YFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZS5hZGRNaWRkbGVXYXJlKGhhbmRsZXIsIGluY2x1ZGVIb29rcyk7XG59XG4vKipcbiAqIEJpbmRzIG1pZGRsZXdhcmUgdG8gYSBzcGVjaWZpYyBhY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiB0eXBlLmFjdGlvbnMoc2VsZiA9PiB7XG4gKiAgIGZ1bmN0aW9uIHRha2VBX19fXygpIHtcbiAqICAgICAgIHNlbGYudG9pbGV0LmRvbmF0ZSgpXG4gKiAgICAgICBzZWxmLndpcGUoKVxuICogICAgICAgc2VsZi53aXBlKClcbiAqICAgICAgIHNlbGYudG9pbGV0LmZsdXNoKClcbiAqICAgfVxuICogICByZXR1cm4ge1xuICogICAgIHRha2VBX19fXzogZGVjb3JhdGUoYXRvbWljLCB0YWtlQV9fX18pXG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGFuZGxlclxuICogQHBhcmFtIGZuXG4gKiBAcGFyYW0gaW5jbHVkZUhvb2tzXG4gKiBAcmV0dXJucyBUaGUgb3JpZ2luYWwgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGVjb3JhdGUoaGFuZGxlciwgZm4sIGluY2x1ZGVIb29rcykge1xuICAgIGlmIChpbmNsdWRlSG9va3MgPT09IHZvaWQgMCkgeyBpbmNsdWRlSG9va3MgPSB0cnVlOyB9XG4gICAgdmFyIG1pZGRsZXdhcmUgPSB7IGhhbmRsZXI6IGhhbmRsZXIsIGluY2x1ZGVIb29rczogaW5jbHVkZUhvb2tzIH07XG4gICAgZm4uJG1zdF9taWRkbGV3YXJlID0gZm4uJG1zdF9taWRkbGV3YXJlIHx8IFtdO1xuICAgIGZuLiRtc3RfbWlkZGxld2FyZS5wdXNoKG1pZGRsZXdhcmUpO1xuICAgIHJldHVybiBmbjtcbn1cbnZhciBDb2xsZWN0ZWRNaWRkbGV3YXJlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2xsZWN0ZWRNaWRkbGV3YXJlcyhub2RlLCBmbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcnJheUluZGV4XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpbkFycmF5SW5kZXhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1pZGRsZXdhcmVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBbXVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gd2UganVzdCBwdXNoIG1pZGRsZXdhcmUgYXJyYXlzIGludG8gYW4gYXJyYXkgb2YgYXJyYXlzIHRvIGF2b2lkIG1ha2luZyBjb3BpZXNcbiAgICAgICAgaWYgKGZuLiRtc3RfbWlkZGxld2FyZSkge1xuICAgICAgICAgICAgdGhpcy5taWRkbGV3YXJlcy5wdXNoKGZuLiRtc3RfbWlkZGxld2FyZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBub2RlO1xuICAgICAgICAvLyBGaW5kIGFsbCBtaWRkbGV3YXJlcy4gT3B0aW1pemF0aW9uOiBjYWNoZSB0aGlzP1xuICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgICAgaWYgKG4ubWlkZGxld2FyZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5taWRkbGV3YXJlcy5wdXNoKG4ubWlkZGxld2FyZXMpO1xuICAgICAgICAgICAgbiA9IG4ucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xsZWN0ZWRNaWRkbGV3YXJlcy5wcm90b3R5cGUsIFwiaXNFbXB0eVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlkZGxld2FyZXMubGVuZ3RoIDw9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sbGVjdGVkTWlkZGxld2FyZXMucHJvdG90eXBlLCBcImdldE5leHRNaWRkbGV3YXJlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLm1pZGRsZXdhcmVzW3RoaXMuYXJyYXlJbmRleF07XG4gICAgICAgICAgICBpZiAoIWFycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGFycmF5W3RoaXMuaW5BcnJheUluZGV4KytdO1xuICAgICAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJheUluZGV4Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5pbkFycmF5SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE5leHRNaWRkbGV3YXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDb2xsZWN0ZWRNaWRkbGV3YXJlcztcbn0oKSk7XG5mdW5jdGlvbiBydW5NaWRkbGVXYXJlcyhub2RlLCBiYXNlQ2FsbCwgb3JpZ2luYWxGbikge1xuICAgIHZhciBtaWRkbGV3YXJlcyA9IG5ldyBDb2xsZWN0ZWRNaWRkbGV3YXJlcyhub2RlLCBvcmlnaW5hbEZuKTtcbiAgICAvLyBTaG9ydCBjaXJjdWl0XG4gICAgaWYgKG1pZGRsZXdhcmVzLmlzRW1wdHkpXG4gICAgICAgIHJldHVybiBhY3Rpb24ob3JpZ2luYWxGbikuYXBwbHkobnVsbCwgYmFzZUNhbGwuYXJncyk7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgZnVuY3Rpb24gcnVuTmV4dE1pZGRsZXdhcmUoY2FsbCkge1xuICAgICAgICB2YXIgbWlkZGxld2FyZSA9IG1pZGRsZXdhcmVzLmdldE5leHRNaWRkbGV3YXJlKCk7XG4gICAgICAgIHZhciBoYW5kbGVyID0gbWlkZGxld2FyZSAmJiBtaWRkbGV3YXJlLmhhbmRsZXI7XG4gICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbihvcmlnaW5hbEZuKS5hcHBseShudWxsLCBjYWxsLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaG9va3MgaWYgYXNrZWQgdG9cbiAgICAgICAgaWYgKCFtaWRkbGV3YXJlLmluY2x1ZGVIb29rcyAmJiBIb29rW2NhbGwubmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBydW5OZXh0TWlkZGxld2FyZShjYWxsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dEludm9rZWQgPSBmYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gbmV4dChjYWxsMiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIG5leHRJbnZva2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHRoZSByZXN1bHQgY2FuIGNvbnRhaW5cbiAgICAgICAgICAgIC8vIC0gdGhlIG5vbiBtYW5pcHVsYXRlZCByZXR1cm4gdmFsdWUgZnJvbSBhbiBhY3Rpb25cbiAgICAgICAgICAgIC8vIC0gdGhlIG5vbiBtYW5pcHVsYXRlZCBhYm9ydCB2YWx1ZVxuICAgICAgICAgICAgLy8gLSBvbmUgb2YgdGhlIGFib3ZlIGJ1dCBtYW5pcHVsYXRlZCB0aHJvdWdoIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICAgICAgcmVzdWx0ID0gcnVuTmV4dE1pZGRsZXdhcmUoY2FsbDIpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYWJvcnRJbnZva2VkID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0KHZhbHVlKSB7XG4gICAgICAgICAgICBhYm9ydEludm9rZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gb3ZlcndyaXRlIHRoZSByZXN1bHRcbiAgICAgICAgICAgIC8vIGNhbiBiZSBtYW5pcHVsYXRlZCB0aHJvdWdoIG1pZGRsZXdhcmVzIGVhcmxpZXIgaW4gdGhlIHF1ZXVlIHVzaW5nIHRoZSBjYWxsYmFjayBmblxuICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcihjYWxsLCBuZXh0LCBhYm9ydCk7XG4gICAgICAgIGlmIChkZXZNb2RlKCkpIHtcbiAgICAgICAgICAgIGlmICghbmV4dEludm9rZWQgJiYgIWFib3J0SW52b2tlZCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IGdldFN0YXRlVHJlZU5vZGUoY2FsbC50cmVlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJOZWl0aGVyIHRoZSBuZXh0KCkgbm9yIHRoZSBhYm9ydCgpIGNhbGxiYWNrIHdpdGhpbiB0aGUgbWlkZGxld2FyZSBcIiArIGhhbmRsZXIubmFtZSArIFwiIGZvciB0aGUgYWN0aW9uOiBcXFwiXCIgKyBjYWxsLm5hbWUgKyBcIlxcXCIgb24gdGhlIG5vZGU6IFwiICsgbm9kZTIudHlwZS5uYW1lICsgXCIgd2FzIGludm9rZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV4dEludm9rZWQgJiYgYWJvcnRJbnZva2VkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gZ2V0U3RhdGVUcmVlTm9kZShjYWxsLnRyZWUpO1xuICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIlRoZSBuZXh0KCkgYW5kIGFib3J0KCkgY2FsbGJhY2sgd2l0aGluIHRoZSBtaWRkbGV3YXJlIFwiICsgaGFuZGxlci5uYW1lICsgXCIgZm9yIHRoZSBhY3Rpb246IFxcXCJcIiArIGNhbGwubmFtZSArIFwiXFxcIiBvbiB0aGUgbm9kZTogXCIgKyBub2RlMi50eXBlLm5hbWUgKyBcIiB3ZXJlIGludm9rZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBydW5OZXh0TWlkZGxld2FyZShiYXNlQ2FsbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBNU1QgYWN0aW9uIGNvbnRleHQsIG9yIHVuZGVmaW5lZCBpZiBub25lLlxuICovXG5mdW5jdGlvbiBnZXRSdW5uaW5nQWN0aW9uQ29udGV4dCgpIHtcbiAgICB2YXIgY3VycmVudCA9IGdldEN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC50eXBlICE9PSBcImFjdGlvblwiKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEFjdGlvbkV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIF9pc0FjdGlvbkNvbnRleHRUaGlzT3JDaGlsZE9mKGFjdGlvbkNvbnRleHQsIHNhbWVPclBhcmVudCwgaW5jbHVkZVNhbWUpIHtcbiAgICB2YXIgcGFyZW50SWQgPSB0eXBlb2Ygc2FtZU9yUGFyZW50ID09PSBcIm51bWJlclwiID8gc2FtZU9yUGFyZW50IDogc2FtZU9yUGFyZW50LmlkO1xuICAgIHZhciBjdXJyZW50ID0gaW5jbHVkZVNhbWVcbiAgICAgICAgPyBhY3Rpb25Db250ZXh0XG4gICAgICAgIDogYWN0aW9uQ29udGV4dC5wYXJlbnRBY3Rpb25FdmVudDtcbiAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBpZiAoY3VycmVudC5pZCA9PT0gcGFyZW50SWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEFjdGlvbkV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFJldHVybnMgaWYgdGhlIGdpdmVuIGFjdGlvbiBjb250ZXh0IGlzIGEgcGFyZW50IG9mIHRoaXMgYWN0aW9uIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGlzQWN0aW9uQ29udGV4dENoaWxkT2YoYWN0aW9uQ29udGV4dCwgcGFyZW50KSB7XG4gICAgcmV0dXJuIF9pc0FjdGlvbkNvbnRleHRUaGlzT3JDaGlsZE9mKGFjdGlvbkNvbnRleHQsIHBhcmVudCwgZmFsc2UpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIHRoZSBnaXZlbiBhY3Rpb24gY29udGV4dCBpcyB0aGlzIG9yIGEgcGFyZW50IG9mIHRoaXMgYWN0aW9uIGNvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGlzQWN0aW9uQ29udGV4dFRoaXNPckNoaWxkT2YoYWN0aW9uQ29udGV4dCwgcGFyZW50T3JUaGlzKSB7XG4gICAgcmV0dXJuIF9pc0FjdGlvbkNvbnRleHRUaGlzT3JDaGlsZE9mKGFjdGlvbkNvbnRleHQsIHBhcmVudE9yVGhpcywgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICByZXR1cm4gXCI8VW5zZXJpYWxpemFibGU6IFwiICsgZSArIFwiPlwiO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIHByZXR0eVByaW50VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBcIjxmdW5jdGlvblwiICsgKHZhbHVlLm5hbWUgPyBcIiBcIiArIHZhbHVlLm5hbWUgOiBcIlwiKSArIFwiPlwiXG4gICAgICAgIDogaXNTdGF0ZVRyZWVOb2RlKHZhbHVlKVxuICAgICAgICAgICAgPyBcIjxcIiArIHZhbHVlICsgXCI+XCJcbiAgICAgICAgICAgIDogXCJgXCIgKyBzYWZlU3RyaW5naWZ5KHZhbHVlKSArIFwiYFwiO1xufVxuZnVuY3Rpb24gc2hvcnRlblByaW50VmFsdWUodmFsdWVJblN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZUluU3RyaW5nLmxlbmd0aCA8IDI4MFxuICAgICAgICA/IHZhbHVlSW5TdHJpbmdcbiAgICAgICAgOiB2YWx1ZUluU3RyaW5nLnN1YnN0cmluZygwLCAyNzIpICsgXCIuLi4uLi5cIiArIHZhbHVlSW5TdHJpbmcuc3Vic3RyaW5nKHZhbHVlSW5TdHJpbmcubGVuZ3RoIC0gOCk7XG59XG5mdW5jdGlvbiB0b0Vycm9yU3RyaW5nKGVycm9yKSB7XG4gICAgdmFyIHZhbHVlID0gZXJyb3IudmFsdWU7XG4gICAgdmFyIHR5cGUgPSBlcnJvci5jb250ZXh0W2Vycm9yLmNvbnRleHQubGVuZ3RoIC0gMV0udHlwZTtcbiAgICB2YXIgZnVsbFBhdGggPSBlcnJvci5jb250ZXh0XG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBwYXRoID0gX2EucGF0aDtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aC5sZW5ndGggPiAwOyB9KVxuICAgICAgICAuam9pbihcIi9cIik7XG4gICAgdmFyIHBhdGhQcmVmaXggPSBmdWxsUGF0aC5sZW5ndGggPiAwID8gXCJhdCBwYXRoIFxcXCIvXCIgKyBmdWxsUGF0aCArIFwiXFxcIiBcIiA6IFwiXCI7XG4gICAgdmFyIGN1cnJlbnRUeXBlbmFtZSA9IGlzU3RhdGVUcmVlTm9kZSh2YWx1ZSlcbiAgICAgICAgPyBcInZhbHVlIG9mIHR5cGUgXCIgKyBnZXRTdGF0ZVRyZWVOb2RlKHZhbHVlKS50eXBlLm5hbWUgKyBcIjpcIlxuICAgICAgICA6IGlzUHJpbWl0aXZlKHZhbHVlKVxuICAgICAgICAgICAgPyBcInZhbHVlXCJcbiAgICAgICAgICAgIDogXCJzbmFwc2hvdFwiO1xuICAgIHZhciBpc1NuYXBzaG90Q29tcGF0aWJsZSA9IHR5cGUgJiYgaXNTdGF0ZVRyZWVOb2RlKHZhbHVlKSAmJiB0eXBlLmlzKGdldFN0YXRlVHJlZU5vZGUodmFsdWUpLnNuYXBzaG90KTtcbiAgICByZXR1cm4gKFwiXCIgKyBwYXRoUHJlZml4ICsgY3VycmVudFR5cGVuYW1lICsgXCIgXCIgKyBwcmV0dHlQcmludFZhbHVlKHZhbHVlKSArIFwiIGlzIG5vdCBhc3NpZ25hYmxlIFwiICsgKHR5cGUgPyBcInRvIHR5cGU6IGBcIiArIHR5cGUubmFtZSArIFwiYFwiIDogXCJcIikgK1xuICAgICAgICAoZXJyb3IubWVzc2FnZSA/IFwiIChcIiArIGVycm9yLm1lc3NhZ2UgKyBcIilcIiA6IFwiXCIpICtcbiAgICAgICAgKHR5cGVcbiAgICAgICAgICAgID8gaXNQcmltaXRpdmVUeXBlKHR5cGUpIHx8IGlzUHJpbWl0aXZlKHZhbHVlKVxuICAgICAgICAgICAgICAgID8gXCIuXCJcbiAgICAgICAgICAgICAgICA6IFwiLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBgXCIgKyB0eXBlLm5hbWUgKyBcImAgb3IgYSBzbmFwc2hvdCBsaWtlIGBcIiArIHR5cGUuZGVzY3JpYmUoKSArIFwiYCBpbnN0ZWFkLlwiICtcbiAgICAgICAgICAgICAgICAgICAgKGlzU25hcHNob3RDb21wYXRpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiIChOb3RlIHRoYXQgYSBzbmFwc2hvdCBvZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSB0YXJnZXRlZCB0eXBlKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIpXG4gICAgICAgICAgICA6IFwiLlwiKSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yUGF0aChjb250ZXh0LCBwYXRoLCB0eXBlKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuY29uY2F0KFt7IHBhdGg6IHBhdGgsIHR5cGU6IHR5cGUgfV0pO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gdHlwZUNoZWNrU3VjY2VzcygpIHtcbiAgICByZXR1cm4gRU1QVFlfQVJSQVk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIFt7IGNvbnRleHQ6IGNvbnRleHQsIHZhbHVlOiB2YWx1ZSwgbWVzc2FnZTogbWVzc2FnZSB9XTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5UeXBlRXJyb3JzKGVycm9ycykge1xuICAgIHJldHVybiBlcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChhLCBpKSB7IHJldHVybiBhLmNvbmNhdChpKTsgfSwgW10pO1xufVxuLy8gVE9ETzsgZG91YmxlY2hlY2s6IHR5cGVjaGVjayBzaG91bGQgb25seSBuZWVkZWQgdG8gYmUgaW52b2tlZCBmcm9tOiB0eXBlLmNyZWF0ZSBhbmQgYXJyYXkgLyBtYXAgLyB2YWx1ZS5wcm9wZXJ0eSB3aWxsIGNoYW5nZVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gdHlwZWNoZWNrSW50ZXJuYWwodHlwZSwgdmFsdWUpIHtcbiAgICAvLyBydW5zIHR5cGVDaGVja2luZyBpZiBpdCBpcyBpbiBkZXYtbW9kZSBvciB0aHJvdWdoIGEgcHJvY2Vzcy5lbnYuRU5BQkxFX1RZUEVfQ0hFQ0sgZmxhZ1xuICAgIGlmIChpc1R5cGVDaGVja2luZ0VuYWJsZWQoKSkge1xuICAgICAgICB0eXBlY2hlY2sodHlwZSwgdmFsdWUpO1xuICAgIH1cbn1cbi8qKlxuICogUnVuJ3MgdGhlIHR5cGVjaGVja2VyIGZvciB0aGUgZ2l2ZW4gdHlwZSBvbiB0aGUgZ2l2ZW4gdmFsdWUsIHdoaWNoIGNhbiBiZSBhIHNuYXBzaG90IG9yIGFuIGluc3RhbmNlLlxuICogVGhyb3dzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYWNjb3JkaW5nIHRoZSBwcm92aWRlZCB0eXBlIHNwZWNpZmljYXRpb24uXG4gKiBVc2UgdGhpcyBpZiB5b3UgbmVlZCB0eXBlY2hlY2tzIGV2ZW4gaW4gYSBwcm9kdWN0aW9uIGJ1aWxkIChieSBkZWZhdWx0IGFsbCBhdXRvbWF0aWMgcnVudGltZSB0eXBlIGNoZWNrcyB3aWxsIGJlIHNraXBwZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMpXG4gKlxuICogQHBhcmFtIHR5cGUgVHlwZSB0byBjaGVjayBhZ2FpbnN0LlxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGJlIGNoZWNrZWQsIGVpdGhlciBhIHNuYXBzaG90IG9yIGFuIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiB0eXBlY2hlY2sodHlwZSwgdmFsdWUpIHtcbiAgICB2YXIgZXJyb3JzID0gdHlwZS52YWxpZGF0ZSh2YWx1ZSwgW3sgcGF0aDogXCJcIiwgdHlwZTogdHlwZSB9XSk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IGZhaWwkMSh2YWxpZGF0aW9uRXJyb3JzVG9TdHJpbmcodHlwZSwgdmFsdWUsIGVycm9ycykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRpb25FcnJvcnNUb1N0cmluZyh0eXBlLCB2YWx1ZSwgZXJyb3JzKSB7XG4gICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIChcIkVycm9yIHdoaWxlIGNvbnZlcnRpbmcgXCIgKyBzaG9ydGVuUHJpbnRWYWx1ZShwcmV0dHlQcmludFZhbHVlKHZhbHVlKSkgKyBcIiB0byBgXCIgKyB0eXBlLm5hbWUgKyBcImA6XFxuXFxuICAgIFwiICsgZXJyb3JzLm1hcCh0b0Vycm9yU3RyaW5nKS5qb2luKFwiXFxuICAgIFwiKSk7XG59XG5cbnZhciBpZGVudGlmaWVyQ2FjaGVJZCA9IDA7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG52YXIgSWRlbnRpZmllckNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIElkZW50aWZpZXJDYWNoZSgpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FjaGVJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaWRlbnRpZmllckNhY2hlSWQrK1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbi5iLiBpbiBjYWNoZSBhbGwgaWRlbnRpZmllcnMgYXJlIG5vcm1hbGl6ZWQgdG8gc3RyaW5nc1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWNoZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogb2JzZXJ2YWJsZS5tYXAoKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gbGFzdCB0aW1lIHRoZSBjYWNoZSAoYXJyYXkpIGZvciBhIGdpdmVuIHRpbWUgY2hhbmdlZFxuICAgICAgICAvLyBuLmIuIGl0IGlzIG5vdCByZWFsbHkgdGhlIHRpbWUsIGJ1dCBqdXN0IGFuIGludGVnZXIgdGhhdCBnZXRzIGluY3JlYXNlZCBhZnRlciBlYWNoIG1vZGlmaWNhdGlvbiB0byB0aGUgYXJyYXlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibGFzdENhY2hlTW9kaWZpY2F0aW9uUGVySWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG9ic2VydmFibGUubWFwKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJZGVudGlmaWVyQ2FjaGUucHJvdG90eXBlLCBcInVwZGF0ZUxhc3RDYWNoZU1vZGlmaWNhdGlvblBlcklkXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoaWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIGxjbSA9IHRoaXMubGFzdENhY2hlTW9kaWZpY2F0aW9uUGVySWQuZ2V0KGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgLy8gd2Ugc3RhcnQgYXQgMSBzaW5jZSAwIG1lYW5zIG5vIHVwZGF0ZSBzaW5jZSBjYWNoZSBjcmVhdGlvblxuICAgICAgICAgICAgdGhpcy5sYXN0Q2FjaGVNb2RpZmljYXRpb25QZXJJZC5zZXQoaWRlbnRpZmllciwgbGNtID09PSB1bmRlZmluZWQgPyAxIDogbGNtICsgMSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSWRlbnRpZmllckNhY2hlLnByb3RvdHlwZSwgXCJnZXRMYXN0Q2FjaGVNb2RpZmljYXRpb25QZXJJZFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHZhciBtb2RpZmljYXRpb25JZCA9IHRoaXMubGFzdENhY2hlTW9kaWZpY2F0aW9uUGVySWQuZ2V0KGlkZW50aWZpZXIpIHx8IDA7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZUlkICsgXCItXCIgKyBtb2RpZmljYXRpb25JZDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJZGVudGlmaWVyQ2FjaGUucHJvdG90eXBlLCBcImFkZE5vZGVUb0NhY2hlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgbGFzdENhY2hlVXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAobGFzdENhY2hlVXBkYXRlID09PSB2b2lkIDApIHsgbGFzdENhY2hlVXBkYXRlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKG5vZGUuaWRlbnRpZmllckF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gbm9kZS5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5oYXMoaWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoaWRlbnRpZmllciwgb2JzZXJ2YWJsZS5hcnJheShbXSwgbW9ieFNoYWxsb3cpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IHRoaXMuY2FjaGUuZ2V0KGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgIGlmIChzZXQuaW5kZXhPZihub2RlKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkFscmVhZHkgcmVnaXN0ZXJlZFwiKTtcbiAgICAgICAgICAgICAgICBzZXQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdENhY2hlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFzdENhY2hlTW9kaWZpY2F0aW9uUGVySWQoaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJDYWNoZS5wcm90b3R5cGUsIFwibWVyZ2VDYWNoZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YWx1ZXMobm9kZS5pZGVudGlmaWVyQ2FjaGUuY2FjaGUpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFkZE5vZGVUb0NhY2hlKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJDYWNoZS5wcm90b3R5cGUsIFwibm90aWZ5RGllZFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlkZW50aWZpZXJBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBub2RlLmlkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgdmFyIHNldCA9IHRoaXMuY2FjaGUuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSBzZXRzIGZyb20gY2FjaGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0Q2FjaGVNb2RpZmljYXRpb25QZXJJZChub2RlLmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJZGVudGlmaWVyQ2FjaGUucHJvdG90eXBlLCBcInNwbGl0Q2FjaGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHJlcyA9IG5ldyBJZGVudGlmaWVyQ2FjaGUoKTtcbiAgICAgICAgICAgIHZhciBiYXNlUGF0aCA9IG5vZGUucGF0aDtcbiAgICAgICAgICAgIGVudHJpZXModGhpcy5jYWNoZSkuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBpZCA9IF9iWzBdLCBub2RlcyA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBub2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXNbaV0ucGF0aC5pbmRleE9mKGJhc2VQYXRoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmFkZE5vZGVUb0NhY2hlKG5vZGVzW2ldLCBmYWxzZSk7IC8vIG5vIG5lZWQgdG8gdXBkYXRlIGxhc3RVcGRhdGVkIHNpbmNlIGl0IGlzIGEgd2hvbGUgbmV3IGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUxhc3RDYWNoZU1vZGlmaWNhdGlvblBlcklkKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSWRlbnRpZmllckNhY2hlLnByb3RvdHlwZSwgXCJoYXNcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0eXBlLCBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB2YXIgc2V0ID0gdGhpcy5jYWNoZS5nZXQoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAoIXNldClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gc2V0LnNvbWUoZnVuY3Rpb24gKGNhbmRpZGF0ZSkgeyByZXR1cm4gdHlwZS5pc0Fzc2lnbmFibGVGcm9tKGNhbmRpZGF0ZS50eXBlKTsgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSWRlbnRpZmllckNhY2hlLnByb3RvdHlwZSwgXCJyZXNvbHZlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodHlwZSwgaWRlbnRpZmllcikge1xuICAgICAgICAgICAgdmFyIHNldCA9IHRoaXMuY2FjaGUuZ2V0KGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgaWYgKCFzZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHNldC5maWx0ZXIoZnVuY3Rpb24gKGNhbmRpZGF0ZSkgeyByZXR1cm4gdHlwZS5pc0Fzc2lnbmFibGVGcm9tKGNhbmRpZGF0ZS50eXBlKTsgfSk7XG4gICAgICAgICAgICBzd2l0Y2ggKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzBdO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkNhbm5vdCByZXNvbHZlIGEgcmVmZXJlbmNlIHRvIHR5cGUgJ1wiICsgdHlwZS5uYW1lICsgXCInIHdpdGggaWQ6ICdcIiArIGlkZW50aWZpZXIgKyBcIicgdW5hbWJpZ291c2x5LCB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlczogXCIgKyBtYXRjaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChuKSB7IHJldHVybiBuLnBhdGg7IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBJZGVudGlmaWVyQ2FjaGU7XG59KCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBjcmVhdGVPYmplY3ROb2RlKHR5cGUsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBleGlzdGluZ05vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlU2FmZShpbml0aWFsVmFsdWUpO1xuICAgIGlmIChleGlzdGluZ05vZGUpIHtcbiAgICAgICAgaWYgKGV4aXN0aW5nTm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJDYW5ub3QgYWRkIGFuIG9iamVjdCB0byBhIHN0YXRlIHRyZWUgaWYgaXQgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzYW1lIG9yIGFub3RoZXIgc3RhdGUgdHJlZS4gVHJpZWQgdG8gYXNzaWduIGFuIG9iamVjdCB0byAnXCIgKyAocGFyZW50ID8gcGFyZW50LnBhdGggOiBcIlwiKSArIFwiL1wiICsgc3VicGF0aCArIFwiJywgYnV0IGl0IGxpdmVzIGFscmVhZHkgYXQgJ1wiICsgZXhpc3RpbmdOb2RlLnBhdGggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgZXhpc3RpbmdOb2RlLnNldFBhcmVudChwYXJlbnQsIHN1YnBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgaXQgYWxyZWFkeSBoYXMgbm8gcGFyZW50IHNpbmNlIGl0IGlzIGEgcHJlLXJlcXVpc2l0ZVxuICAgICAgICByZXR1cm4gZXhpc3RpbmdOb2RlO1xuICAgIH1cbiAgICAvLyBub3QgYSBub2RlLCBhIHNuYXBzaG90XG4gICAgcmV0dXJuIG5ldyBPYmplY3ROb2RlKHR5cGUsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBjcmVhdGVTY2FsYXJOb2RlKHR5cGUsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgU2NhbGFyTm9kZSh0eXBlLCBwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2NhbGFyTm9kZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdE5vZGU7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBOb2RlTGlmZUN5Y2xlO1xuKGZ1bmN0aW9uIChOb2RlTGlmZUN5Y2xlKSB7XG4gICAgTm9kZUxpZmVDeWNsZVtOb2RlTGlmZUN5Y2xlW1wiSU5JVElBTElaSU5HXCJdID0gMF0gPSBcIklOSVRJQUxJWklOR1wiO1xuICAgIE5vZGVMaWZlQ3ljbGVbTm9kZUxpZmVDeWNsZVtcIkNSRUFURURcIl0gPSAxXSA9IFwiQ1JFQVRFRFwiO1xuICAgIE5vZGVMaWZlQ3ljbGVbTm9kZUxpZmVDeWNsZVtcIkZJTkFMSVpFRFwiXSA9IDJdID0gXCJGSU5BTElaRURcIjtcbiAgICBOb2RlTGlmZUN5Y2xlW05vZGVMaWZlQ3ljbGVbXCJERVRBQ0hJTkdcIl0gPSAzXSA9IFwiREVUQUNISU5HXCI7XG4gICAgTm9kZUxpZmVDeWNsZVtOb2RlTGlmZUN5Y2xlW1wiREVBRFwiXSA9IDRdID0gXCJERUFEXCI7IC8vIG5vIGNvbWluZyBiYWNrIGZyb20gdGhpcyBvbmVcbn0pKE5vZGVMaWZlQ3ljbGUgfHwgKE5vZGVMaWZlQ3ljbGUgPSB7fSkpO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgbm9kZSBpbiBhIHN0YXRlIHRyZWUuXG4gKiBNb3JlIHByZWNpc2VseSwgdGhhdCBpcywgaWYgdGhlIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGFcbiAqIGB0eXBlcy5tb2RlbGAsIGB0eXBlcy5hcnJheWAgb3IgYHR5cGVzLm1hcGAuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBhIHN0YXRlIHRyZWUgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNTdGF0ZVRyZWVOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLiR0cmVlbm9kZSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1N0YXRlVHJlZU5vZGUodmFsdWUsIGFyZ051bWJlcikge1xuICAgIGFzc2VydEFyZyh2YWx1ZSwgaXNTdGF0ZVRyZWVOb2RlLCBcIm1vYngtc3RhdGUtdHJlZSBub2RlXCIsIGFyZ051bWJlcik7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBnZXRTdGF0ZVRyZWVOb2RlKHZhbHVlKSB7XG4gICAgaWYgKCFpc1N0YXRlVHJlZU5vZGUodmFsdWUpKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHRocm93IGZhaWwkMShcIlZhbHVlIFwiICsgdmFsdWUgKyBcIiBpcyBubyBNU1QgTm9kZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLiR0cmVlbm9kZTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlVHJlZU5vZGVTYWZlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS4kdHJlZW5vZGUpIHx8IG51bGw7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIGdldFN0YXRlVHJlZU5vZGUodGhpcykuc25hcHNob3Q7XG59XG52YXIgZG91YmxlRG90ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIFwiLi5cIjsgfTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbGF0aXZlUGF0aEJldHdlZW5Ob2RlcyhiYXNlLCB0YXJnZXQpIHtcbiAgICAvLyBQUkUgY29uZGl0aW9uIHRhcmdldCBpcyAoYSBjaGlsZCBvZikgYmFzZSFcbiAgICBpZiAoYmFzZS5yb290ICE9PSB0YXJnZXQucm9vdCkge1xuICAgICAgICB0aHJvdyBmYWlsJDEoXCJDYW5ub3QgY2FsY3VsYXRlIHJlbGF0aXZlIHBhdGg6IG9iamVjdHMgJ1wiICsgYmFzZSArIFwiJyBhbmQgJ1wiICsgdGFyZ2V0ICsgXCInIGFyZSBub3QgcGFydCBvZiB0aGUgc2FtZSBvYmplY3QgdHJlZVwiKTtcbiAgICB9XG4gICAgdmFyIGJhc2VQYXJ0cyA9IHNwbGl0SnNvblBhdGgoYmFzZS5wYXRoKTtcbiAgICB2YXIgdGFyZ2V0UGFydHMgPSBzcGxpdEpzb25QYXRoKHRhcmdldC5wYXRoKTtcbiAgICB2YXIgY29tbW9uID0gMDtcbiAgICBmb3IgKDsgY29tbW9uIDwgYmFzZVBhcnRzLmxlbmd0aDsgY29tbW9uKyspIHtcbiAgICAgICAgaWYgKGJhc2VQYXJ0c1tjb21tb25dICE9PSB0YXJnZXRQYXJ0c1tjb21tb25dKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFRPRE86IGFzc2VydCB0aGF0IG5vIHRhcmdldFBhcnRzIHBhdGhzIGFyZSBcIi4uXCIsIFwiLlwiIG9yIFwiXCIhXG4gICAgcmV0dXJuIChiYXNlUGFydHMuc2xpY2UoY29tbW9uKS5tYXAoZG91YmxlRG90KS5qb2luKFwiL1wiKSArIGpvaW5Kc29uUGF0aCh0YXJnZXRQYXJ0cy5zbGljZShjb21tb24pKSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiByZXNvbHZlTm9kZUJ5UGF0aChiYXNlLCBwYXRoLCBmYWlsSWZSZXNvbHZlRmFpbHMpIHtcbiAgICBpZiAoZmFpbElmUmVzb2x2ZUZhaWxzID09PSB2b2lkIDApIHsgZmFpbElmUmVzb2x2ZUZhaWxzID0gdHJ1ZTsgfVxuICAgIHJldHVybiByZXNvbHZlTm9kZUJ5UGF0aFBhcnRzKGJhc2UsIHNwbGl0SnNvblBhdGgocGF0aCksIGZhaWxJZlJlc29sdmVGYWlscyk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiByZXNvbHZlTm9kZUJ5UGF0aFBhcnRzKGJhc2UsIHBhdGhQYXJ0cywgZmFpbElmUmVzb2x2ZUZhaWxzKSB7XG4gICAgaWYgKGZhaWxJZlJlc29sdmVGYWlscyA9PT0gdm9pZCAwKSB7IGZhaWxJZlJlc29sdmVGYWlscyA9IHRydWU7IH1cbiAgICB2YXIgY3VycmVudCA9IGJhc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXRoUGFydHNbaV07XG4gICAgICAgIGlmIChwYXJ0ID09PSBcIi4uXCIpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBub3QgZXZlcnl0aGluZyBoYXMgYSBwYXJlbnRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0ID09PSBcIi5cIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBTY2FsYXJOb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIG9mIGEgc2NhbGFyIHJlc29sdmVzIHRvIGEgc3RhdGUgdHJlZSBub2RlIChlLmcuIHJlZmVyZW5jZXMpXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBjYW4gY29udGludWUgcmVzb2x2aW5nLi4uXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY3VycmVudC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RhdGVUcmVlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBnZXRTdGF0ZVRyZWVOb2RlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmFpbElmUmVzb2x2ZUZhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBPYmplY3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YlR5cGUgPSBjdXJyZW50LmdldENoaWxkVHlwZShwYXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5nZXRDaGlsZE5vZGUocGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmYWlsSWZSZXNvbHZlRmFpbHMpXG4gICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJDb3VsZCBub3QgcmVzb2x2ZSAnXCIgKyBwYXJ0ICsgXCInIGluIHBhdGggJ1wiICsgKGpvaW5Kc29uUGF0aChwYXRoUGFydHMuc2xpY2UoMCwgaSkpIHx8IFwiL1wiKSArIFwiJyB3aGlsZSByZXNvbHZpbmcgJ1wiICsgam9pbkpzb25QYXRoKHBhdGhQYXJ0cykgKyBcIidcIik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY29udmVydENoaWxkTm9kZXNUb0FycmF5KGNoaWxkTm9kZXMpIHtcbiAgICBpZiAoIWNoaWxkTm9kZXMpXG4gICAgICAgIHJldHVybiBFTVBUWV9BUlJBWTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNoaWxkTm9kZXMpO1xuICAgIGlmICgha2V5cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBFTVBUWV9BUlJBWTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGNoaWxkTm9kZXNba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBiYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4LXV0aWxzL2Jsb2IvbWFzdGVyL3NyYy9hc3luYy1hY3Rpb24udHNcbi8qXG4gICAgQWxsIGNvbnRlbnRzIG9mIHRoaXMgZmlsZSBhcmUgZGVwcmVjYXRlZC5cblxuICAgIFRoZSB0ZXJtIGBwcm9jZXNzYCBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGBmbG93YCB0byBhdm9pZCBjb25mbGljdHMgd2l0aCB0aGVcbiAgICBnbG9iYWwgYHByb2Nlc3NgIG9iamVjdC5cblxuICAgIFJlZmVyIHRvIGBmbG93LnRzYCBmb3IgYW55IGZ1cnRoZXIgY2hhbmdlcyB0byB0aGlzIGltcGxlbWVudGF0aW9uLlxuKi9cbnZhciBERVBSRUNBVElPTl9NRVNTQUdFID0gXCJTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4LXN0YXRlLXRyZWUvaXNzdWVzLzM5OSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gXCIgK1xuICAgIFwiTm90ZSB0aGF0IHRoZSBtaWRkbGV3YXJlIGV2ZW50IHR5cGVzIHN0YXJ0aW5nIHdpdGggYHByb2Nlc3NgIG5vdyBzdGFydCB3aXRoIGBmbG93YC5cIjtcbi8qKlxuICogQGhpZGRlblxuICpcbiAqIEBkZXByZWNhdGVkIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGZsb3coKWAuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4LXN0YXRlLXRyZWUvaXNzdWVzLzM5OSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqIE5vdGUgdGhhdCB0aGUgbWlkZGxld2FyZSBldmVudCB0eXBlcyBzdGFydGluZyB3aXRoIGBwcm9jZXNzYCBub3cgc3RhcnQgd2l0aCBgZmxvd2AuXG4gKlxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3MkMShhc3luY0FjdGlvbikge1xuICAgIGRlcHJlY2F0ZWQoXCJwcm9jZXNzXCIsIFwiYHByb2Nlc3MoKWAgaGFzIGJlZW4gcmVuYW1lZCB0byBgZmxvdygpYC4gXCIgKyBERVBSRUNBVElPTl9NRVNTQUdFKTtcbiAgICByZXR1cm4gZmxvdyhhc3luY0FjdGlvbik7XG59XG5cbnZhciBwbGFpbk9iamVjdFN0cmluZyA9IE9iamVjdC50b1N0cmluZygpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIEVNUFRZX0FSUkFZID0gT2JqZWN0LmZyZWV6ZShbXSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG52YXIgRU1QVFlfT0JKRUNUID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG52YXIgbW9ieFNoYWxsb3cgPSBfZ2V0R2xvYmFsU3RhdGUoKS51c2VQcm94aWVzXG4gICAgPyB7IGRlZXA6IGZhbHNlIH1cbiAgICA6IHsgZGVlcDogZmFsc2UsIHByb3h5OiBmYWxzZSB9O1xuT2JqZWN0LmZyZWV6ZShtb2J4U2hhbGxvdyk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBmYWlsJDEobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IFwiSWxsZWdhbCBzdGF0ZVwiOyB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIlttb2J4LXN0YXRlLXRyZWVdIFwiICsgbWVzc2FnZSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBpZGVudGl0eShfKSB7XG4gICAgcmV0dXJuIF87XG59XG4vKipcbiAqIHBvbGx5ZmlsbCAoZm9yIElFKSBzdWdnZXN0ZWQgaW4gTUROOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL2lzSW50ZWdlclxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBpc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8XG4gICAgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbiAgICB9O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHZhbCk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhc0FycmF5KHZhbCkge1xuICAgIGlmICghdmFsKVxuICAgICAgICByZXR1cm4gRU1QVFlfQVJSQVk7XG4gICAgaWYgKGlzQXJyYXkodmFsKSlcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICByZXR1cm4gW3ZhbF07XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBleHRlbmQoYSkge1xuICAgIHZhciBiID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYltfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gYltpXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnQpXG4gICAgICAgICAgICBhW2tleV0gPSBjdXJyZW50W2tleV07XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICBpZiAocHJvdG8gPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuICgoX2EgPSBwcm90by5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpID09PSBwbGFpbk9iamVjdFN0cmluZztcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGlzTXV0YWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJlxuICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSwgaW5jbHVkZURhdGUpIHtcbiAgICBpZiAoaW5jbHVkZURhdGUgPT09IHZvaWQgMCkgeyBpbmNsdWRlRGF0ZSA9IHRydWU7IH1cbiAgICByZXR1cm4gKHZhbHVlID09PSBudWxsIHx8XG4gICAgICAgIHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8XG4gICAgICAgIChpbmNsdWRlRGF0ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKiBGcmVlemUgYSB2YWx1ZSBhbmQgcmV0dXJuIGl0IChpZiBub3QgaW4gcHJvZHVjdGlvbilcbiAqL1xuZnVuY3Rpb24gZnJlZXplKHZhbHVlKSB7XG4gICAgaWYgKCFkZXZNb2RlKCkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gaXNQcmltaXRpdmUodmFsdWUpIHx8IGlzT2JzZXJ2YWJsZUFycmF5KHZhbHVlKSA/IHZhbHVlIDogT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICogUmVjdXJzaXZlbHkgZnJlZXplIGEgdmFsdWUgKGlmIG5vdCBpbiBwcm9kdWN0aW9uKVxuICovXG5mdW5jdGlvbiBkZWVwRnJlZXplKHZhbHVlKSB7XG4gICAgaWYgKCFkZXZNb2RlKCkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBmcmVlemUodmFsdWUpO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcEtleSkge1xuICAgICAgICAgICAgaWYgKCFpc1ByaW1pdGl2ZSh2YWx1ZVtwcm9wS2V5XSkgJiZcbiAgICAgICAgICAgICAgICAhT2JqZWN0LmlzRnJvemVuKHZhbHVlW3Byb3BLZXldKSkge1xuICAgICAgICAgICAgICAgIGRlZXBGcmVlemUodmFsdWVbcHJvcEtleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gaXNTZXJpYWxpemFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCI7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwgZGVzY3JpcHRvcikge1xuICAgIGlzT2JzZXJ2YWJsZU9iamVjdChvYmplY3QpXG4gICAgICAgID8gZGVmaW5lUHJvcGVydHkkMShvYmplY3QsIGtleSwgZGVzY3JpcHRvcilcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIGRlc2NyaXB0b3IpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYWRkSGlkZGVuRmluYWxQcm9wKG9iamVjdCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wTmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYWRkSGlkZGVuV3JpdGFibGVQcm9wKG9iamVjdCwgcHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wTmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG52YXIgRXZlbnRIYW5kbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50SGFuZGxlcigpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFuZGxlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRIYW5kbGVyLnByb3RvdHlwZSwgXCJoYXNTdWJzY3JpYmVyc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoID4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEhhbmRsZXIucHJvdG90eXBlLCBcInJlZ2lzdGVyXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZm4sIGF0VGhlQmVnaW5uaW5nKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKGF0VGhlQmVnaW5uaW5nID09PSB2b2lkIDApIHsgYXRUaGVCZWdpbm5pbmcgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKGF0VGhlQmVnaW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycy51bnNoaWZ0KGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnVucmVnaXN0ZXIoZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEhhbmRsZXIucHJvdG90eXBlLCBcImhhc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5pbmRleE9mKGZuKSA+PSAwO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50SGFuZGxlci5wcm90b3R5cGUsIFwidW5yZWdpc3RlclwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmhhbmRsZXJzLmluZGV4T2YoZm4pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRIYW5kbGVyLnByb3RvdHlwZSwgXCJjbGVhclwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50SGFuZGxlci5wcm90b3R5cGUsIFwiZW1pdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFrZSBhIGNvcHkganVzdCBpbiBjYXNlIGl0IGNoYW5nZXNcbiAgICAgICAgICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuYXBwbHkodm9pZCAwLCBfX3NwcmVhZChhcmdzKSk7IH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEV2ZW50SGFuZGxlcjtcbn0oKSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG52YXIgRXZlbnRIYW5kbGVycyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEhhbmRsZXJzKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJldmVudEhhbmRsZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEhhbmRsZXJzLnByb3RvdHlwZSwgXCJoYXNTdWJzY3JpYmVyc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuZXZlbnRIYW5kbGVycyAmJiB0aGlzLmV2ZW50SGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgICAgcmV0dXJuICEhaGFuZGxlciAmJiBoYW5kbGVyLmhhc1N1YnNjcmliZXJzO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50SGFuZGxlcnMucHJvdG90eXBlLCBcInJlZ2lzdGVyXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZlbnQsIGZuLCBhdFRoZUJlZ2lubmluZykge1xuICAgICAgICAgICAgaWYgKGF0VGhlQmVnaW5uaW5nID09PSB2b2lkIDApIHsgYXRUaGVCZWdpbm5pbmcgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5ldmVudEhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzLmV2ZW50SGFuZGxlcnNbZXZlbnRdID0gbmV3IEV2ZW50SGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIucmVnaXN0ZXIoZm4sIGF0VGhlQmVnaW5uaW5nKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEhhbmRsZXJzLnByb3RvdHlwZSwgXCJoYXNcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5ldmVudEhhbmRsZXJzICYmIHRoaXMuZXZlbnRIYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICByZXR1cm4gISFoYW5kbGVyICYmIGhhbmRsZXIuaGFzKGZuKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEhhbmRsZXJzLnByb3RvdHlwZSwgXCJ1bnJlZ2lzdGVyXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuZXZlbnRIYW5kbGVycyAmJiB0aGlzLmV2ZW50SGFuZGxlcnNbZXZlbnRdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLnVucmVnaXN0ZXIoZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50SGFuZGxlcnMucHJvdG90eXBlLCBcImNsZWFyXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudEhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEhhbmRsZXJzLnByb3RvdHlwZSwgXCJjbGVhckFsbFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50SGFuZGxlcnMucHJvdG90eXBlLCBcImVtaXRcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5ldmVudEhhbmRsZXJzICYmIHRoaXMuZXZlbnRIYW5kbGVyc1tldmVudF07XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIChfYSA9IGhhbmRsZXIpLmVtaXQuYXBwbHkoX2EsIF9fc3ByZWFkKGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBFdmVudEhhbmRsZXJzO1xufSgpKTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGFyZ3NUb0FycmF5KGFyZ3MpIHtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlc1tpXSA9IGFyZ3NbaV07XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1N0YXJ0c1dpdGgoc3RyLCBiZWdpbm5pbmcpIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2YoYmVnaW5uaW5nKSA9PT0gMDtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBkZXByZWNhdGVkID0gZnVuY3Rpb24gKGlkLCBtZXNzYWdlKSB7XG4gICAgLy8gc2tpcCBpZiBydW5uaW5nIHByb2R1Y3Rpb25cbiAgICBpZiAoIWRldk1vZGUoKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIHdhcm4gaWYgaGFzbid0IGJlZW4gd2FybmVkIGJlZm9yZVxuICAgIGlmIChkZXByZWNhdGVkLmlkcyAmJiAhZGVwcmVjYXRlZC5pZHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIHdhcm5FcnJvcihcIkRlcHJlY2F0aW9uIHdhcm5pbmc6IFwiICsgbWVzc2FnZSk7XG4gICAgfVxuICAgIC8vIG1hcmsgYXMgd2FybmVkIHRvIGF2b2lkIGR1cGxpY2F0ZSB3YXJuIG1lc3NhZ2VcbiAgICBpZiAoZGVwcmVjYXRlZC5pZHMpXG4gICAgICAgIGRlcHJlY2F0ZWQuaWRzW2lkXSA9IHRydWU7XG59O1xuZGVwcmVjYXRlZC5pZHMgPSB7fTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIHdhcm5FcnJvcihtc2cpIHtcbiAgICBjb25zb2xlLndhcm4obmV3IEVycm9yKFwiW21vYngtc3RhdGUtdHJlZV0gXCIgKyBtc2cpKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGlzVHlwZUNoZWNraW5nRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gKGRldk1vZGUoKSB8fFxuICAgICAgICAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuRU5BQkxFX1RZUEVfQ0hFQ0sgPT09IFwidHJ1ZVwiKSk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBkZXZNb2RlKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCI7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhc3NlcnRBcmcodmFsdWUsIGZuLCB0eXBlTmFtZSwgYXJnTnVtYmVyKSB7XG4gICAgaWYgKGRldk1vZGUoKSkge1xuICAgICAgICBpZiAoIWZuKHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIHRocm93IGZhaWwkMShcImV4cGVjdGVkIFwiICsgdHlwZU5hbWUgKyBcIiBhcyBhcmd1bWVudCBcIiArIGFzQXJyYXkoYXJnTnVtYmVyKS5qb2luKFwiIG9yIFwiKSArIFwiLCBnb3QgXCIgKyB2YWx1ZSArIFwiIGluc3RlYWRcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0Z1bmN0aW9uKHZhbHVlLCBhcmdOdW1iZXIpIHtcbiAgICBhc3NlcnRBcmcodmFsdWUsIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCI7IH0sIFwiZnVuY3Rpb25cIiwgYXJnTnVtYmVyKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzTnVtYmVyKHZhbHVlLCBhcmdOdW1iZXIsIG1pbiwgbWF4KSB7XG4gICAgYXNzZXJ0QXJnKHZhbHVlLCBmdW5jdGlvbiAobikgeyByZXR1cm4gdHlwZW9mIG4gPT09IFwibnVtYmVyXCI7IH0sIFwibnVtYmVyXCIsIGFyZ051bWJlcik7XG4gICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydEFyZyh2YWx1ZSwgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gPj0gbWluOyB9LCBcIm51bWJlciBncmVhdGVyIHRoYW4gXCIgKyBtaW4sIGFyZ051bWJlcik7XG4gICAgfVxuICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnRBcmcodmFsdWUsIGZ1bmN0aW9uIChuKSB7IHJldHVybiBuIDw9IG1heDsgfSwgXCJudW1iZXIgbGVzc2VyIHRoYW4gXCIgKyBtYXgsIGFyZ051bWJlcik7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SXNTdHJpbmcodmFsdWUsIGFyZ051bWJlciwgY2FuQmVFbXB0eSkge1xuICAgIGlmIChjYW5CZUVtcHR5ID09PSB2b2lkIDApIHsgY2FuQmVFbXB0eSA9IHRydWU7IH1cbiAgICBhc3NlcnRBcmcodmFsdWUsIGZ1bmN0aW9uIChzKSB7IHJldHVybiB0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIjsgfSwgXCJzdHJpbmdcIiwgYXJnTnVtYmVyKTtcbiAgICBpZiAoIWNhbkJlRW1wdHkpIHtcbiAgICAgICAgYXNzZXJ0QXJnKHZhbHVlLCBmdW5jdGlvbiAocykgeyByZXR1cm4gcyAhPT0gXCJcIjsgfSwgXCJub3QgZW1wdHkgc3RyaW5nXCIsIGFyZ051bWJlcik7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gc2V0SW1tZWRpYXRlV2l0aEZhbGxiYWNrKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGZuKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZShmbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAxKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2VlIFthc3luY2hyb25vdXMgYWN0aW9uc10oY29uY2VwdHMvYXN5bmMtYWN0aW9ucy5tZCkuXG4gKlxuICogQHJldHVybnMgVGhlIGZsb3cgYXMgYSBwcm9taXNlLlxuICovXG5mdW5jdGlvbiBmbG93KGdlbmVyYXRvcikge1xuICAgIHJldHVybiBjcmVhdGVGbG93U3Bhd25lcihnZW5lcmF0b3IubmFtZSwgZ2VuZXJhdG9yKTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgTm90IG5lZWRlZCBzaW5jZSBUUzMuNi5cbiAqIFVzZWQgZm9yIFR5cGVTY3JpcHQgdG8gbWFrZSBmbG93cyB0aGF0IHJldHVybiBhIHByb21pc2UgcmV0dXJuIHRoZSBhY3R1YWwgcHJvbWlzZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHZhbFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gY2FzdEZsb3dSZXR1cm4odmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbn1cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICogZXhwZXJpbWVudGFsIGFwaSAtIG1pZ2h0IGNoYW5nZSBvbiBtaW5vci9wYXRjaCByZWxlYXNlc1xuICpcbiAqIENvbnZlcnQgYSBwcm9taXNlLXJldHVybmluZyBmdW5jdGlvbiB0byBhIGdlbmVyYXRvci1yZXR1cm5pbmcgb25lLlxuICogVGhpcyBpcyBpbnRlbmRlZCB0byBhbGxvdyBmb3IgdXNhZ2Ugb2YgYHlpZWxkKmAgaW4gYXN5bmMgYWN0aW9ucyB0b1xuICogcmV0YWluIHRoZSBwcm9taXNlIHJldHVybiB0eXBlLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogZnVuY3Rpb24gZ2V0RGF0YUFzeW5jKGlucHV0OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4geyAuLi4gfVxuICogY29uc3QgZ2V0RGF0YUdlbiA9IHRvR2VuZXJhdG9yRnVuY3Rpb24oZ2V0RGF0YUFzeW5jKTtcbiAqXG4gKiBjb25zdCBzb21lTW9kZWwuYWN0aW9ucyhzZWxmID0+ICh7XG4gKiAgIHNvbWVBY3Rpb246IGZsb3coZnVuY3Rpb24qKCkge1xuICogICAgIC8vIHZhbHVlIGlzIHR5cGVkIGFzIG51bWJlclxuICogICAgIGNvbnN0IHZhbHVlID0geWllbGQqIGdldERhdGFHZW4oXCJpbnB1dCB2YWx1ZVwiKTtcbiAqICAgICAuLi5cbiAqICAgfSlcbiAqIH0pKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHRvR2VuZXJhdG9yRnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfaTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHAuYXBwbHkodm9pZCAwLCBfX3NwcmVhZChhcmdzKSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICogZXhwZXJpbWVudGFsIGFwaSAtIG1pZ2h0IGNoYW5nZSBvbiBtaW5vci9wYXRjaCByZWxlYXNlc1xuICpcbiAqIENvbnZlcnQgYSBwcm9taXNlIHRvIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoYXQgcHJvbWlzZVxuICogVGhpcyBpcyBpbnRlbmRlZCB0byBhbGxvdyBmb3IgdXNhZ2Ugb2YgYHlpZWxkKmAgaW4gYXN5bmMgYWN0aW9ucyB0b1xuICogcmV0YWluIHRoZSBwcm9taXNlIHJldHVybiB0eXBlLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogZnVuY3Rpb24gZ2V0RGF0YUFzeW5jKGlucHV0OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4geyAuLi4gfVxuICpcbiAqIGNvbnN0IHNvbWVNb2RlbC5hY3Rpb25zKHNlbGYgPT4gKHtcbiAqICAgc29tZUFjdGlvbjogZmxvdyhmdW5jdGlvbiooKSB7XG4gKiAgICAgLy8gdmFsdWUgaXMgdHlwZWQgYXMgbnVtYmVyXG4gKiAgICAgY29uc3QgdmFsdWUgPSB5aWVsZCogdG9HZW5lcmF0b3IoZ2V0RGF0YUFzeW5jKFwiaW5wdXQgdmFsdWVcIikpO1xuICogICAgIC4uLlxuICogICB9KVxuICogfSkpXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdG9HZW5lcmF0b3IocCkge1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBwXTtcbiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpXTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmxvd1NwYXduZXIobmFtZSwgZ2VuZXJhdG9yKSB7XG4gICAgdmFyIHNwYXduZXIgPSBmdW5jdGlvbiBmbG93U3Bhd25lcigpIHtcbiAgICAgICAgLy8gSW1wbGVtZW50YXRpb24gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RqL2NvL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gICAgICAgIHZhciBydW5JZCA9IGdldE5leHRBY3Rpb25JZCgpO1xuICAgICAgICB2YXIgcGFyZW50Q29udGV4dCA9IGdldEN1cnJlbnRBY3Rpb25Db250ZXh0KCk7XG4gICAgICAgIGlmICghcGFyZW50Q29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiYSBtc3QgZmxvdyBtdXN0IGFsd2F5cyBoYXZlIGEgcGFyZW50IGNvbnRleHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudEFjdGlvbkNvbnRleHQgPSBnZXRQYXJlbnRBY3Rpb25Db250ZXh0KHBhcmVudENvbnRleHQpO1xuICAgICAgICBpZiAoIXBhcmVudEFjdGlvbkNvbnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwkMShcImEgbXN0IGZsb3cgbXVzdCBhbHdheXMgaGF2ZSBhIHBhcmVudCBhY3Rpb24gY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dEJhc2UgPSB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaWQ6IHJ1bklkLFxuICAgICAgICAgICAgdHJlZTogcGFyZW50Q29udGV4dC50cmVlLFxuICAgICAgICAgICAgY29udGV4dDogcGFyZW50Q29udGV4dC5jb250ZXh0LFxuICAgICAgICAgICAgcGFyZW50SWQ6IHBhcmVudENvbnRleHQuaWQsXG4gICAgICAgICAgICBhbGxQYXJlbnRJZHM6IF9fc3ByZWFkKHBhcmVudENvbnRleHQuYWxsUGFyZW50SWRzLCBbcGFyZW50Q29udGV4dC5pZF0pLFxuICAgICAgICAgICAgcm9vdElkOiBwYXJlbnRDb250ZXh0LnJvb3RJZCxcbiAgICAgICAgICAgIHBhcmVudEV2ZW50OiBwYXJlbnRDb250ZXh0LFxuICAgICAgICAgICAgcGFyZW50QWN0aW9uRXZlbnQ6IHBhcmVudEFjdGlvbkNvbnRleHRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGZ1bmN0aW9uIHdyYXAoZm4sIHR5cGUsIGFyZykge1xuICAgICAgICAgICAgZm4uJG1zdF9taWRkbGV3YXJlID0gc3Bhd25lci4kbXN0X21pZGRsZXdhcmU7IC8vIHBpY2sgdXAgYW55IG1pZGRsZXdhcmUgYXR0YWNoZWQgdG8gdGhlIGZsb3dcbiAgICAgICAgICAgIHJldHVybiBydW5XaXRoQWN0aW9uQ29udGV4dChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dEJhc2UpLCB7IHR5cGU6IHR5cGUsIGFyZ3M6IFthcmddIH0pLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBnZW47XG4gICAgICAgICAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uIGFzeW5jQWN0aW9uSW5pdCgpIHtcbiAgICAgICAgICAgICAgICBnZW4gPSBnZW5lcmF0b3IuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBvbkZ1bGZpbGxlZCh1bmRlZmluZWQpOyAvLyBraWNrIG9mZiB0aGUgZmxvd1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGluaXQuJG1zdF9taWRkbGV3YXJlID0gc3Bhd25lci4kbXN0X21pZGRsZXdhcmU7XG4gICAgICAgICAgICBydW5XaXRoQWN0aW9uQ29udGV4dChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29udGV4dEJhc2UpLCB7IHR5cGU6IFwiZmxvd19zcGF3blwiLCBhcmdzOiBhcmdzVG9BcnJheShhcmdzKSB9KSwgaW5pdCk7XG4gICAgICAgICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxlZChyZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsRXJyb3IgPSB3cmFwKGZ1bmN0aW9uIChyKSB7IHJldCA9IGdlbi5uZXh0KHIpOyB9LCBcImZsb3dfcmVzdW1lXCIsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWxFcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBnZW4udGhyb3coY2FuY2VsRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGVXaXRoRmFsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcChmdW5jdGlvbiAocikgeyByZWplY3QoZSk7IH0sIFwiZmxvd190aHJvd1wiLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dChyZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0ZWQoZXJyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgd3JhcChmdW5jdGlvbiAocikgeyByZXQgPSBnZW4udGhyb3cocik7IH0sIFwiZmxvd19yZXN1bWVfZXJyb3JcIiwgZXJyKTsgLy8gb3IgeWllbGRFcnJvcj9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZVdpdGhGYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cmFwKGZ1bmN0aW9uIChyKSB7IHJlamVjdChlKTsgfSwgXCJmbG93X3Rocm93XCIsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KHJldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBuZXh0KHJldCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlV2l0aEZhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyYXAoZnVuY3Rpb24gKHIpIHsgcmVzb2x2ZShyKTsgfSwgXCJmbG93X3JldHVyblwiLCByZXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IG1vcmUgdHlwZSBvZiB2YWx1ZXM/IFNlZSBodHRwczovL2dpdGh1Yi5jb20vdGovY28vYmxvYi8yNDliYmRjNzJkYTI0YWU0NDA3NmFmZDcxNjM0OWQyMDg5YjMxYzRjL2luZGV4LmpzI0wxMDBcbiAgICAgICAgICAgICAgICBpZiAoIXJldC52YWx1ZSB8fCB0eXBlb2YgcmV0LnZhbHVlLnRoZW4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJPbmx5IHByb21pc2VzIGNhbiBiZSB5aWVsZGVkIHRvIGBhc3luY2AsIGdvdDogXCIgKyByZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0LnZhbHVlLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBzcGF3bmVyO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBzcGxpdFBhdGNoKHBhdGNoKSB7XG4gICAgaWYgKCEoXCJvbGRWYWx1ZVwiIGluIHBhdGNoKSlcbiAgICAgICAgdGhyb3cgZmFpbCQxKFwiUGF0Y2hlcyB3aXRob3V0IGBvbGRWYWx1ZWAgZmllbGQgY2Fubm90IGJlIGludmVyc2VkXCIpO1xuICAgIHJldHVybiBbc3RyaXBQYXRjaChwYXRjaCksIGludmVydFBhdGNoKHBhdGNoKV07XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBzdHJpcFBhdGNoKHBhdGNoKSB7XG4gICAgLy8gc3RyaXBzIGBvbGR2YWx1ZWAgaW5mb3JtYXRpb24gZnJvbSB0aGUgcGF0Y2gsIHNvIHRoYXQgaXQgYmVjb21lcyBhIHBhdGNoIGNvbmZvcm0gdGhlIGpzb24tcGF0Y2ggc3BlY1xuICAgIC8vIHRoaXMgcmVtb3ZlcyB0aGUgYWJpbGl0eSB0byB1bmRvIHRoZSBwYXRjaFxuICAgIHN3aXRjaCAocGF0Y2gub3ApIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHsgb3A6IFwiYWRkXCIsIHBhdGg6IHBhdGNoLnBhdGgsIHZhbHVlOiBwYXRjaC52YWx1ZSB9O1xuICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgICAgICByZXR1cm4geyBvcDogXCJyZW1vdmVcIiwgcGF0aDogcGF0Y2gucGF0aCB9O1xuICAgICAgICBjYXNlIFwicmVwbGFjZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHsgb3A6IFwicmVwbGFjZVwiLCBwYXRoOiBwYXRjaC5wYXRoLCB2YWx1ZTogcGF0Y2gudmFsdWUgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnZlcnRQYXRjaChwYXRjaCkge1xuICAgIHN3aXRjaCAocGF0Y2gub3ApIHtcbiAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRjaC5wYXRoXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wOiBcImFkZFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGNoLnBhdGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhdGNoLm9sZFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwicmVwbGFjZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0Y2gucGF0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF0Y2gub2xkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBTaW1wbGUgc2ltcGxlIGNoZWNrIHRvIGNoZWNrIGl0IGlzIGEgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBpc051bWJlcih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcIm51bWJlclwiO1xufVxuLyoqXG4gKiBFc2NhcGUgc2xhc2hlcyBhbmQgYmFja3NsYXNoZXMuXG4gKlxuICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMVxuICovXG5mdW5jdGlvbiBlc2NhcGVKc29uUGF0aChwYXRoKSB7XG4gICAgaWYgKGlzTnVtYmVyKHBhdGgpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgcGF0aDtcbiAgICB9XG4gICAgaWYgKHBhdGguaW5kZXhPZihcIi9cIikgPT09IC0xICYmIHBhdGguaW5kZXhPZihcIn5cIikgPT09IC0xKVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIik7XG59XG4vKipcbiAqIFVuZXNjYXBlIHNsYXNoZXMgYW5kIGJhY2tzbGFzaGVzLlxuICovXG5mdW5jdGlvbiB1bmVzY2FwZUpzb25QYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBqc29uLXBhdGggY29tcGxpYW50IGpzb24gcGF0aCBmcm9tIHBhdGggcGFydHMuXG4gKlxuICogQHBhcmFtIHBhdGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGpvaW5Kc29uUGF0aChwYXRoKSB7XG4gICAgLy8gYC9gIHJlZmVycyB0byBwcm9wZXJ0eSB3aXRoIGFuIGVtcHR5IG5hbWUsIHdoaWxlIGBgIHJlZmVycyB0byByb290IGl0c2VsZiFcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIHZhciBnZXRQYXRoU3RyID0gZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAubWFwKGVzY2FwZUpzb25QYXRoKS5qb2luKFwiL1wiKTsgfTtcbiAgICBpZiAocGF0aFswXSA9PT0gXCIuXCIgfHwgcGF0aFswXSA9PT0gXCIuLlwiKSB7XG4gICAgICAgIC8vIHJlbGF0aXZlXG4gICAgICAgIHJldHVybiBnZXRQYXRoU3RyKHBhdGgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gYWJzb2x1dGVcbiAgICAgICAgcmV0dXJuIFwiL1wiICsgZ2V0UGF0aFN0cihwYXRoKTtcbiAgICB9XG59XG4vKipcbiAqIFNwbGl0cyBhbmQgZGVjb2RlcyBhIGpzb24gcGF0aCBpbnRvIHNldmVyYWwgcGFydHMuXG4gKlxuICogQHBhcmFtIHBhdGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHNwbGl0SnNvblBhdGgocGF0aCkge1xuICAgIC8vIGAvYCByZWZlcnMgdG8gcHJvcGVydHkgd2l0aCBhbiBlbXB0eSBuYW1lLCB3aGlsZSBgYCByZWZlcnMgdG8gcm9vdCBpdHNlbGYhXG4gICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdChcIi9cIikubWFwKHVuZXNjYXBlSnNvblBhdGgpO1xuICAgIHZhciB2YWxpZCA9IHBhdGggPT09IFwiXCIgfHxcbiAgICAgICAgcGF0aCA9PT0gXCIuXCIgfHxcbiAgICAgICAgcGF0aCA9PT0gXCIuLlwiIHx8XG4gICAgICAgIHN0cmluZ1N0YXJ0c1dpdGgocGF0aCwgXCIvXCIpIHx8XG4gICAgICAgIHN0cmluZ1N0YXJ0c1dpdGgocGF0aCwgXCIuL1wiKSB8fFxuICAgICAgICBzdHJpbmdTdGFydHNXaXRoKHBhdGgsIFwiLi4vXCIpO1xuICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgdGhyb3cgZmFpbCQxKFwiYSBqc29uIHBhdGggbXVzdCBiZSBlaXRoZXIgcm9vdGVkLCBlbXB0eSBvciByZWxhdGl2ZSwgYnV0IGdvdCAnXCIgKyBwYXRoICsgXCInXCIpO1xuICAgIH1cbiAgICAvLyAnL2EvYi9jJyAtPiBbXCJhXCIsIFwiYlwiLCBcImNcIl1cbiAgICAvLyAnLi4vLi4vYi9jJyAtPiBbXCIuLlwiLCBcIi4uXCIsIFwiYlwiLCBcImNcIl1cbiAgICAvLyAnJyAtPiBbXVxuICAgIC8vICcvJyAtPiBbJyddXG4gICAgLy8gJy4vYScgLT4gW1wiLlwiLCBcImFcIl1cbiAgICAvLyAvLi9hJyAtPiBbXCIuXCIsIFwiYVwiXSBlcXVpdmFsZW50IHRvICcuL2EnXG4gICAgaWYgKHBhcnRzWzBdID09PSBcIlwiKSB7XG4gICAgICAgIHBhcnRzLnNoaWZ0KCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbn1cblxuLyoqIEBoaWRkZW4gKi9cbnZhciAkcHJlUHJvY2Vzc29yRmFpbGVkID0gU3ltYm9sKFwiJHByZVByb2Nlc3NvckZhaWxlZFwiKTtcbnZhciBTbmFwc2hvdFByb2Nlc3NvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU25hcHNob3RQcm9jZXNzb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU25hcHNob3RQcm9jZXNzb3IoX3N1YnR5cGUsIF9wcm9jZXNzb3JzLCBuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUgfHwgX3N1YnR5cGUubmFtZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9zdWJ0eXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBfc3VidHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9wcm9jZXNzb3JzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBfcHJvY2Vzc29yc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU25hcHNob3RQcm9jZXNzb3IucHJvdG90eXBlLCBcImZsYWdzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS5mbGFncyB8IFR5cGVGbGFncy5TbmFwc2hvdFByb2Nlc3NvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcInNuYXBzaG90UHJvY2Vzc29yKFwiICsgdGhpcy5fc3VidHlwZS5kZXNjcmliZSgpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU25hcHNob3RQcm9jZXNzb3IucHJvdG90eXBlLCBcInByZVByb2Nlc3NTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJvY2Vzc29ycy5wcmVQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2Vzc29ycy5wcmVQcm9jZXNzb3IuY2FsbChudWxsLCBzbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc247XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU25hcHNob3RQcm9jZXNzb3IucHJvdG90eXBlLCBcInByZVByb2Nlc3NTbmFwc2hvdFNhZmVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChzbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVQcm9jZXNzU25hcHNob3Qoc24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJHByZVByb2Nlc3NvckZhaWxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwicG9zdFByb2Nlc3NTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJvY2Vzc29ycy5wb3N0UHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NvcnMucG9zdFByb2Nlc3Nvci5jYWxsKG51bGwsIHNuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzbjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwiX2ZpeE5vZGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gdGhlIG5vZGUgaGFzIHRvIHVzZSB0aGVzZSBtZXRob2RzIHJhdGhlciB0aGFuIHRoZSBvcmlnaW5hbCB0eXBlIG9uZXNcbiAgICAgICAgICAgIHByb3h5Tm9kZVR5cGVNZXRob2RzKG5vZGUudHlwZSwgdGhpcywgXCJjcmVhdGVcIik7XG4gICAgICAgICAgICB2YXIgb2xkR2V0U25hcHNob3QgPSBub2RlLmdldFNuYXBzaG90O1xuICAgICAgICAgICAgbm9kZS5nZXRTbmFwc2hvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucG9zdFByb2Nlc3NTbmFwc2hvdChvbGRHZXRTbmFwc2hvdC5jYWxsKG5vZGUpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIWlzVW5pb25UeXBlKHRoaXMuX3N1YnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5nZXRSZWNvbmNpbGlhdGlvblR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNuYXBzaG90UHJvY2Vzc29yLnByb3RvdHlwZSwgXCJpbnN0YW50aWF0ZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHByb2Nlc3NlZEluaXRpYWxWYWx1ZSA9IGlzU3RhdGVUcmVlTm9kZShpbml0aWFsVmFsdWUpXG4gICAgICAgICAgICAgICAgPyBpbml0aWFsVmFsdWVcbiAgICAgICAgICAgICAgICA6IHRoaXMucHJlUHJvY2Vzc1NuYXBzaG90KGluaXRpYWxWYWx1ZSk7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3N1YnR5cGUuaW5zdGFudGlhdGUocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgcHJvY2Vzc2VkSW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpeE5vZGUobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwicmVjb25jaWxlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9zdWJ0eXBlLnJlY29uY2lsZShjdXJyZW50LCBpc1N0YXRlVHJlZU5vZGUobmV3VmFsdWUpID8gbmV3VmFsdWUgOiB0aGlzLnByZVByb2Nlc3NTbmFwc2hvdChuZXdWYWx1ZSksIHBhcmVudCwgc3VicGF0aCk7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpeE5vZGUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwiZ2V0U25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCBhcHBseVBvc3RQcm9jZXNzKSB7XG4gICAgICAgICAgICBpZiAoYXBwbHlQb3N0UHJvY2VzcyA9PT0gdm9pZCAwKSB7IGFwcGx5UG9zdFByb2Nlc3MgPSB0cnVlOyB9XG4gICAgICAgICAgICB2YXIgc24gPSB0aGlzLl9zdWJ0eXBlLmdldFNuYXBzaG90KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5UG9zdFByb2Nlc3MgPyB0aGlzLnBvc3RQcm9jZXNzU25hcHNob3Qoc24pIDogc247XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU25hcHNob3RQcm9jZXNzb3IucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc2VkU24gPSB0aGlzLnByZVByb2Nlc3NTbmFwc2hvdFNhZmUodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3NlZFNuID09PSAkcHJlUHJvY2Vzc29yRmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVDaGVja0ZhaWx1cmUoY29udGV4dCwgdmFsdWUsIFwiRmFpbGVkIHRvIHByZXByb2Nlc3MgdmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS52YWxpZGF0ZShwcm9jZXNzZWRTbiwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU25hcHNob3RQcm9jZXNzb3IucHJvdG90eXBlLCBcImdldFN1YlR5cGVzXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VidHlwZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwiaXNcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0aGluZykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gaXNUeXBlKHRoaW5nKVxuICAgICAgICAgICAgICAgID8gdGhpcy5fc3VidHlwZVxuICAgICAgICAgICAgICAgIDogaXNTdGF0ZVRyZWVOb2RlKHRoaW5nKVxuICAgICAgICAgICAgICAgICAgICA/IGdldFNuYXBzaG90KHRoaW5nLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnByZVByb2Nlc3NTbmFwc2hvdFNhZmUodGhpbmcpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAkcHJlUHJvY2Vzc29yRmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGUudmFsaWRhdGUodmFsdWUsIFt7IHBhdGg6IFwiXCIsIHR5cGU6IHRoaXMuX3N1YnR5cGUgfV0pLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTbmFwc2hvdFByb2Nlc3Nvci5wcm90b3R5cGUsIFwiaXNBc3NpZ25hYmxlRnJvbVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlLmlzQXNzaWduYWJsZUZyb20odHlwZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU25hcHNob3RQcm9jZXNzb3IucHJvdG90eXBlLCBcImlzTWF0Y2hpbmdTbmFwc2hvdElkXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgc25hcHNob3QpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3N1YnR5cGUgaW5zdGFuY2VvZiBDb21wbGV4VHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc2VkU24gPSB0aGlzLnByZVByb2Nlc3NTbmFwc2hvdChzbmFwc2hvdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS5pc01hdGNoaW5nU25hcHNob3RJZChjdXJyZW50LCBwcm9jZXNzZWRTbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gU25hcHNob3RQcm9jZXNzb3I7XG59KEJhc2VUeXBlKSk7XG5mdW5jdGlvbiBwcm94eU5vZGVUeXBlTWV0aG9kcyhub2RlVHlwZSwgc25hcHNob3RQcm9jZXNzb3JUeXBlKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdmFyIG1ldGhvZHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBtZXRob2RzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBtZXRob2RzXzEgPSBfX3ZhbHVlcyhtZXRob2RzKSwgbWV0aG9kc18xXzEgPSBtZXRob2RzXzEubmV4dCgpOyAhbWV0aG9kc18xXzEuZG9uZTsgbWV0aG9kc18xXzEgPSBtZXRob2RzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gbWV0aG9kc18xXzEudmFsdWU7XG4gICAgICAgICAgICBub2RlVHlwZVttZXRob2RdID0gc25hcHNob3RQcm9jZXNzb3JUeXBlW21ldGhvZF0uYmluZChzbmFwc2hvdFByb2Nlc3NvclR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kc18xXzEgJiYgIW1ldGhvZHNfMV8xLmRvbmUgJiYgKF9hID0gbWV0aG9kc18xLnJldHVybikpIF9hLmNhbGwobWV0aG9kc18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgfVxufVxuLyoqXG4gKiBgdHlwZXMuc25hcHNob3RQcm9jZXNzb3JgIC0gUnVucyBhIHByZS9wb3N0IHNuYXBzaG90IHByb2Nlc3NvciBiZWZvcmUvYWZ0ZXIgc2VyaWFsaXppbmcgYSBnaXZlbiB0eXBlLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogY29uc3QgVG9kbzEgPSB0eXBlcy5tb2RlbCh7IHRleHQ6IHR5cGVzLnN0cmluZyB9KVxuICogLy8gaW4gdGhlIGJhY2tlbmQgdGhlIHRleHQgdHlwZSBtdXN0IGJlIG51bGwgd2hlbiBlbXB0eVxuICogaW50ZXJmYWNlIEJhY2tlbmRUb2RvIHtcbiAqICAgICB0ZXh0OiBzdHJpbmcgfCBudWxsXG4gKiB9XG4gKiBjb25zdCBUb2RvMiA9IHR5cGVzLnNuYXBzaG90UHJvY2Vzc29yKFRvZG8xLCB7XG4gKiAgICAgLy8gZnJvbSBzbmFwc2hvdCB0byBpbnN0YW5jZVxuICogICAgIHByZVByb2Nlc3NvcihzbjogQmFja2VuZFRvZG8pIHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICAgIHRleHQ6IHNuLnRleHQgfHwgXCJcIjtcbiAqICAgICAgICAgfVxuICogICAgIH0sXG4gKiAgICAgLy8gZnJvbSBpbnN0YW5jZSB0byBzbmFwc2hvdFxuICogICAgIHBvc3RQcm9jZXNzb3Ioc24pOiBCYWNrZW5kVG9kbyB7XG4gKiAgICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgICAgICB0ZXh0OiAhc24udGV4dCA/IG51bGwgOiBzbi50ZXh0XG4gKiAgICAgICAgIH1cbiAqICAgICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHR5cGUgVHlwZSB0byBydW4gdGhlIHByb2Nlc3NvcnMgb3Zlci5cbiAqIEBwYXJhbSBwcm9jZXNzb3JzIFByb2Nlc3NvcnMgdG8gcnVuLlxuICogQHBhcmFtIG5hbWUgVHlwZSBuYW1lLCBvciB1bmRlZmluZWQgdG8gaW5oZXJpdCB0aGUgaW5uZXIgdHlwZSBvbmUuXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBzbmFwc2hvdFByb2Nlc3Nvcih0eXBlLCBwcm9jZXNzb3JzLCBuYW1lKSB7XG4gICAgYXNzZXJ0SXNUeXBlKHR5cGUsIDEpO1xuICAgIGlmIChkZXZNb2RlKCkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3NvcnMucG9zdFByb2Nlc3NvciAmJiB0eXBlb2YgcHJvY2Vzc29ycy5wb3N0UHJvY2Vzc29yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICB0aHJvdyBmYWlsKFwicG9zdFNuYXBzaG90UHJvY2Vzc29yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzc29ycy5wcmVQcm9jZXNzb3IgJiYgdHlwZW9mIHByb2Nlc3NvcnMucHJlUHJvY2Vzc29yICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICB0aHJvdyBmYWlsKFwicHJlU25hcHNob3RQcm9jZXNzb3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgU25hcHNob3RQcm9jZXNzb3IodHlwZSwgcHJvY2Vzc29ycywgbmFtZSk7XG59XG5cbnZhciBuZWVkc0lkZW50aWZpZXJFcnJvciA9IFwiTWFwLnB1dCBjYW4gb25seSBiZSB1c2VkIHRvIHN0b3JlIGNvbXBsZXggdmFsdWVzIHRoYXQgaGF2ZSBhbiBpZGVudGlmaWVyIHR5cGUgYXR0cmlidXRlXCI7XG5mdW5jdGlvbiB0cnlDb2xsZWN0TW9kZWxUeXBlcyh0eXBlLCBtb2RlbFR5cGVzKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgdmFyIHN1YnR5cGVzID0gdHlwZS5nZXRTdWJUeXBlcygpO1xuICAgIGlmIChzdWJ0eXBlcyA9PT0gY2Fubm90RGV0ZXJtaW5lU3VidHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdWJ0eXBlcykge1xuICAgICAgICB2YXIgc3VidHlwZXNBcnJheSA9IGFzQXJyYXkoc3VidHlwZXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgc3VidHlwZXNBcnJheV8xID0gX192YWx1ZXMoc3VidHlwZXNBcnJheSksIHN1YnR5cGVzQXJyYXlfMV8xID0gc3VidHlwZXNBcnJheV8xLm5leHQoKTsgIXN1YnR5cGVzQXJyYXlfMV8xLmRvbmU7IHN1YnR5cGVzQXJyYXlfMV8xID0gc3VidHlwZXNBcnJheV8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJ0eXBlID0gc3VidHlwZXNBcnJheV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0cnlDb2xsZWN0TW9kZWxUeXBlcyhzdWJ0eXBlLCBtb2RlbFR5cGVzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc3VidHlwZXNBcnJheV8xXzEgJiYgIXN1YnR5cGVzQXJyYXlfMV8xLmRvbmUgJiYgKF9hID0gc3VidHlwZXNBcnJheV8xLnJldHVybikpIF9hLmNhbGwoc3VidHlwZXNBcnJheV8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIE1vZGVsVHlwZSkge1xuICAgICAgICBtb2RlbFR5cGVzLnB1c2godHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIE1hcElkZW50aWZpZXJNb2RlO1xuKGZ1bmN0aW9uIChNYXBJZGVudGlmaWVyTW9kZSkge1xuICAgIE1hcElkZW50aWZpZXJNb2RlW01hcElkZW50aWZpZXJNb2RlW1wiVU5LTk9XTlwiXSA9IDBdID0gXCJVTktOT1dOXCI7XG4gICAgTWFwSWRlbnRpZmllck1vZGVbTWFwSWRlbnRpZmllck1vZGVbXCJZRVNcIl0gPSAxXSA9IFwiWUVTXCI7XG4gICAgTWFwSWRlbnRpZmllck1vZGVbTWFwSWRlbnRpZmllck1vZGVbXCJOT1wiXSA9IDJdID0gXCJOT1wiO1xufSkoTWFwSWRlbnRpZmllck1vZGUgfHwgKE1hcElkZW50aWZpZXJNb2RlID0ge30pKTtcbnZhciBNU1RNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1TVE1hcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNU1RNYXAoaW5pdGlhbERhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxEYXRhLCBvYnNlcnZhYmxlLnJlZi5lbmhhbmNlcikgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1TVE1hcC5wcm90b3R5cGUsIFwiZ2V0XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAvLyBtYXliZSB0aGlzIGlzIG92ZXItZW50aG91c2lhc3RpYz8gbm9ybWFsaXplIG51bWVyaWMga2V5cyB0byBzdHJpbmdzXG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBcIlwiICsga2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNU1RNYXAucHJvdG90eXBlLCBcImhhc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuaGFzLmNhbGwodGhpcywgXCJcIiArIGtleSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTVNUTWFwLnByb3RvdHlwZSwgXCJkZWxldGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmRlbGV0ZS5jYWxsKHRoaXMsIFwiXCIgKyBrZXkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1TVE1hcC5wcm90b3R5cGUsIFwic2V0XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2V0LmNhbGwodGhpcywgXCJcIiArIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1TVE1hcC5wcm90b3R5cGUsIFwicHV0XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiTWFwLnB1dCBjYW5ub3QgYmUgdXNlZCB0byBzZXQgZW1wdHkgdmFsdWVzXCIpO1xuICAgICAgICAgICAgaWYgKGlzU3RhdGVUcmVlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChkZXZNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmlkZW50aWZpZXJBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShuZWVkc0lkZW50aWZpZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaWRlbnRpZmllciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEobmVlZHNJZGVudGlmaWVyRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldChub2RlLmlkZW50aWZpZXIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNNdXRhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIk1hcC5wdXQgY2FuIG9ubHkgYmUgdXNlZCB0byBzdG9yZSBjb21wbGV4IHZhbHVlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBtYXBOb2RlID0gZ2V0U3RhdGVUcmVlTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgbWFwVHlwZSA9IG1hcE5vZGUudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAobWFwVHlwZS5pZGVudGlmaWVyTW9kZSAhPT0gTWFwSWRlbnRpZmllck1vZGUuWUVTKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShuZWVkc0lkZW50aWZpZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpZEF0dHIgPSBtYXBUeXBlLm1hcElkZW50aWZpZXJBdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdmFsdWVbaWRBdHRyXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRJZGVudGlmaWVyKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgYWdhaW4gYnV0IHRoaXMgdGltZSBhZnRlciBjcmVhdGluZyBhIG5vZGUgZm9yIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBpdCBtaWdodCBiZSBhbiBvcHRpb25hbCBpZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gdGhpcy5wdXQobWFwVHlwZS5nZXRDaGlsZFR5cGUoKS5jcmVhdGUodmFsdWUsIG1hcE5vZGUuZW52aXJvbm1lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHV0KGdldFNuYXBzaG90KG5ld05vZGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIE1TVE1hcDtcbn0oT2JzZXJ2YWJsZU1hcCkpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIE1hcFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwVHlwZShuYW1lLCBfc3ViVHlwZSwgaG9va0luaXRpYWxpemVycykge1xuICAgICAgICBpZiAoaG9va0luaXRpYWxpemVycyA9PT0gdm9pZCAwKSB7IGhvb2tJbml0aWFsaXplcnMgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX3N1YlR5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IF9zdWJUeXBlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaWRlbnRpZmllck1vZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE1hcElkZW50aWZpZXJNb2RlLlVOS05PV05cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtYXBJZGVudGlmaWVyQXR0cmlidXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmbGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogVHlwZUZsYWdzLk1hcFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImhvb2tJbml0aWFsaXplcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5fZGV0ZXJtaW5lSWRlbnRpZmllck1vZGUoKTtcbiAgICAgICAgX3RoaXMuaG9va0luaXRpYWxpemVycyA9IGhvb2tJbml0aWFsaXplcnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcImhvb2tzXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoaG9va3MpIHtcbiAgICAgICAgICAgIHZhciBob29rSW5pdGlhbGl6ZXJzID0gdGhpcy5ob29rSW5pdGlhbGl6ZXJzLmxlbmd0aCA+IDAgPyB0aGlzLmhvb2tJbml0aWFsaXplcnMuY29uY2F0KGhvb2tzKSA6IFtob29rc107XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1hcFR5cGUodGhpcy5uYW1lLCB0aGlzLl9zdWJUeXBlLCBob29rSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBUeXBlLnByb3RvdHlwZSwgXCJpbnN0YW50aWF0ZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lSWRlbnRpZmllck1vZGUoKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVPYmplY3ROb2RlKHRoaXMsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiX2RldGVybWluZUlkZW50aWZpZXJNb2RlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZGVudGlmaWVyTW9kZSAhPT0gTWFwSWRlbnRpZmllck1vZGUuVU5LTk9XTikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb2RlbFR5cGVzID0gW107XG4gICAgICAgICAgICBpZiAodHJ5Q29sbGVjdE1vZGVsVHlwZXModGhpcy5fc3ViVHlwZSwgbW9kZWxUeXBlcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllckF0dHJpYnV0ZSA9IG1vZGVsVHlwZXMucmVkdWNlKGZ1bmN0aW9uIChjdXJyZW50LCB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZS5pZGVudGlmaWVyQXR0cmlidXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IHR5cGUuaWRlbnRpZmllckF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiVGhlIG9iamVjdHMgaW4gYSBtYXAgc2hvdWxkIGFsbCBoYXZlIHRoZSBzYW1lIGlkZW50aWZpZXIgYXR0cmlidXRlLCBleHBlY3RlZCAnXCIgKyBjdXJyZW50ICsgXCInLCBidXQgY2hpbGQgb2YgdHlwZSAnXCIgKyB0eXBlLm5hbWUgKyBcIicgZGVjbGFyZWQgYXR0cmlidXRlICdcIiArIHR5cGUuaWRlbnRpZmllckF0dHJpYnV0ZSArIFwiJyBhcyBpZGVudGlmaWVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlLmlkZW50aWZpZXJBdHRyaWJ1dGU7XG4gICAgICAgICAgICAgICAgfSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBpZiAoaWRlbnRpZmllckF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkZW50aWZpZXJNb2RlID0gTWFwSWRlbnRpZmllck1vZGUuWUVTO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcElkZW50aWZpZXJBdHRyaWJ1dGUgPSBpZGVudGlmaWVyQXR0cmlidXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyTW9kZSA9IE1hcElkZW50aWZpZXJNb2RlLk5PO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBUeXBlLnByb3RvdHlwZSwgXCJpbml0aWFsaXplQ2hpbGROb2Rlc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG9iak5vZGUsIGluaXRpYWxTbmFwc2hvdCkge1xuICAgICAgICAgICAgaWYgKGluaXRpYWxTbmFwc2hvdCA9PT0gdm9pZCAwKSB7IGluaXRpYWxTbmFwc2hvdCA9IHt9OyB9XG4gICAgICAgICAgICB2YXIgc3ViVHlwZSA9IG9iak5vZGUudHlwZS5fc3ViVHlwZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGluaXRpYWxTbmFwc2hvdCkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHN1YlR5cGUuaW5zdGFudGlhdGUob2JqTm9kZSwgbmFtZSwgdW5kZWZpbmVkLCBpbml0aWFsU25hcHNob3RbbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcImNyZWF0ZU5ld0luc3RhbmNlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNU1RNYXAoY2hpbGROb2Rlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiZmluYWxpemVOZXdJbnN0YW5jZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIGluc3RhbmNlKSB7XG4gICAgICAgICAgICBfaW50ZXJjZXB0UmVhZHMoaW5zdGFuY2UsIG5vZGUudW5ib3gpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgICAgICB0eXBlLmhvb2tJbml0aWFsaXplcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaG9va3MgPSBpbml0aWFsaXplcihpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaG9va3MpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvb2sgPSBob29rc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbkludm9rZXIgPSBjcmVhdGVBY3Rpb25JbnZva2VyKGluc3RhbmNlLCBuYW1lLCBob29rKTtcbiAgICAgICAgICAgICAgICAgICAgKCFkZXZNb2RlKCkgPyBhZGRIaWRkZW5GaW5hbFByb3AgOiBhZGRIaWRkZW5Xcml0YWJsZVByb3ApKGluc3RhbmNlLCBuYW1lLCBhY3Rpb25JbnZva2VyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW50ZXJjZXB0KGluc3RhbmNlLCB0aGlzLndpbGxDaGFuZ2UpO1xuICAgICAgICAgICAgb2JzZXJ2ZShpbnN0YW5jZSwgdGhpcy5kaWRDaGFuZ2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcImRlc2NyaWJlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJNYXA8c3RyaW5nLCBcIiArIHRoaXMuX3N1YlR5cGUuZGVzY3JpYmUoKSArIFwiPlwiO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcImdldENoaWxkcmVuXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIChub2RlLnN0b3JlZFZhbHVlIGFzIE9ic2VydmFibGVNYXA8YW55PikudmFsdWVzKClcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMobm9kZS5zdG9yZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiZ2V0Q2hpbGROb2RlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gbm9kZS5zdG9yZWRWYWx1ZS5nZXQoXCJcIiArIGtleSk7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJOb3QgYSBjaGlsZCBcIiArIGtleSk7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGROb2RlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcIndpbGxDaGFuZ2VcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZ2V0U3RhdGVUcmVlTm9kZShjaGFuZ2Uub2JqZWN0KTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBjaGFuZ2UubmFtZTtcbiAgICAgICAgICAgIG5vZGUuYXNzZXJ0V3JpdGFibGUoeyBzdWJwYXRoOiBrZXkgfSk7XG4gICAgICAgICAgICB2YXIgbWFwVHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgICAgIHZhciBzdWJUeXBlID0gbWFwVHlwZS5fc3ViVHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IGNoYW5nZS5vYmplY3QuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWNoZWNrSW50ZXJuYWwoc3ViVHlwZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLm5ld1ZhbHVlID0gc3ViVHlwZS5yZWNvbmNpbGUobm9kZS5nZXRDaGlsZE5vZGUoa2V5KSwgY2hhbmdlLm5ld1ZhbHVlLCBub2RlLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwVHlwZS5wcm9jZXNzSWRlbnRpZmllcihrZXksIGNoYW5nZS5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlY2hlY2tJbnRlcm5hbChzdWJUeXBlLCBjaGFuZ2UubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLm5ld1ZhbHVlID0gc3ViVHlwZS5pbnN0YW50aWF0ZShub2RlLCBrZXksIHVuZGVmaW5lZCwgY2hhbmdlLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFR5cGUucHJvY2Vzc0lkZW50aWZpZXIoa2V5LCBjaGFuZ2UubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBUeXBlLnByb3RvdHlwZSwgXCJwcm9jZXNzSWRlbnRpZmllclwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGV4cGVjdGVkLCBub2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZGVudGlmaWVyTW9kZSA9PT0gTWFwSWRlbnRpZmllck1vZGUuWUVTICYmIG5vZGUgaW5zdGFuY2VvZiBPYmplY3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBub2RlLmlkZW50aWZpZXI7XG4gICAgICAgICAgICAgICAgaWYgKGlkZW50aWZpZXIgIT09IGV4cGVjdGVkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJBIG1hcCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgYW4gaWRlbnRpZmllciBzaG91bGQgYWx3YXlzIHN0b3JlIHRoZSBvYmplY3QgdW5kZXIgdGhlaXIgb3duIGlkZW50aWZpZXIuIFRyeWluZyB0byBzdG9yZSBrZXkgJ1wiICsgaWRlbnRpZmllciArIFwiJywgYnV0IGV4cGVjdGVkOiAnXCIgKyBleHBlY3RlZCArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBUeXBlLnByb3RvdHlwZSwgXCJnZXRTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgICAgIG5vZGUuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXNbY2hpbGROb2RlLnN1YnBhdGhdID0gY2hpbGROb2RlLnNuYXBzaG90O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcInByb2Nlc3NJbml0aWFsU25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc2VkID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRba2V5XSA9IGNoaWxkTm9kZXNba2V5XS5nZXRTbmFwc2hvdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcImRpZENoYW5nZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKGNoYW5nZS5vYmplY3QpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFuZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgbm9kZS5lbWl0UGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZXNjYXBlSnNvblBhdGgoY2hhbmdlLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNoYW5nZS5uZXdWYWx1ZS5zbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBjaGFuZ2Uub2xkVmFsdWUgPyBjaGFuZ2Uub2xkVmFsdWUuc25hcHNob3QgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgfSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCBub2RlLmVtaXRQYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGVzY2FwZUpzb25QYXRoKGNoYW5nZS5uYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaGFuZ2UubmV3VmFsdWUuc25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH0sIG5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBub2RlIGdvdCBkZWxldGVkLCBnZXQgdGhlIG9sZCBzbmFwc2hvdCBhbmQgbWFrZSB0aGUgbm9kZSBkaWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFNuYXBzaG90ID0gY2hhbmdlLm9sZFZhbHVlLnNuYXBzaG90O1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2Uub2xkVmFsdWUuZGllKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVtaXQgdGhlIHBhdGNoXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIG5vZGUuZW1pdFBhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZXNjYXBlSnNvblBhdGgoY2hhbmdlLm5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFNuYXBzaG90XG4gICAgICAgICAgICAgICAgICAgIH0sIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcImFwcGx5UGF0Y2hMb2NhbGx5XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgc3VicGF0aCwgcGF0Y2gpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBub2RlLnN0b3JlZFZhbHVlO1xuICAgICAgICAgICAgc3dpdGNoIChwYXRjaC5vcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwbGFjZVwiOlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2V0KHN1YnBhdGgsIHBhdGNoLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlbW92ZVwiOlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZGVsZXRlKHN1YnBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXBUeXBlLnByb3RvdHlwZSwgXCJhcHBseVNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgc25hcHNob3QpIHtcbiAgICAgICAgICAgIHR5cGVjaGVja0ludGVybmFsKHRoaXMsIHNuYXBzaG90KTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBub2RlLnN0b3JlZFZhbHVlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXlzID0ge307XG4gICAgICAgICAgICBBcnJheS5mcm9tKHRhcmdldC5rZXlzKCkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRLZXlzW2tleV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgdXNlIHRhcmdldC5yZXBsYWNlLCBhcyBpdCB3aWxsIHRocm93IGF3YXkgYWxsIGV4aXN0aW5nIGl0ZW1zIGZpcnN0XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5zZXQoa2V5LCBzbmFwc2hvdFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEtleXNbXCJcIiArIGtleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGN1cnJlbnRLZXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEtleXNba2V5XSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcImdldENoaWxkVHlwZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YlR5cGU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiaXNWYWxpZFNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVDaGVja0ZhaWx1cmUoY29udGV4dCwgdmFsdWUsIFwiVmFsdWUgaXMgbm90IGEgcGxhaW4gb2JqZWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5UeXBlRXJyb3JzKE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3N1YlR5cGUudmFsaWRhdGUodmFsdWVbcGF0aF0sIGdldENvbnRleHRGb3JQYXRoKGNvbnRleHQsIHBhdGgsIF90aGlzLl9zdWJUeXBlKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwVHlwZS5wcm90b3R5cGUsIFwiZ2V0RGVmYXVsdFNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKRUNUO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcFR5cGUucHJvdG90eXBlLCBcInJlbW92ZUNoaWxkXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgc3VicGF0aCkge1xuICAgICAgICAgICAgbm9kZS5zdG9yZWRWYWx1ZS5kZWxldGUoc3VicGF0aCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gTWFwVHlwZTtcbn0oQ29tcGxleFR5cGUpKTtcbk1hcFR5cGUucHJvdG90eXBlLmFwcGx5U25hcHNob3QgPSBhY3Rpb24oTWFwVHlwZS5wcm90b3R5cGUuYXBwbHlTbmFwc2hvdCk7XG4vKipcbiAqIGB0eXBlcy5tYXBgIC0gQ3JlYXRlcyBhIGtleSBiYXNlZCBjb2xsZWN0aW9uIHR5cGUgd2hvJ3MgY2hpbGRyZW4gYXJlIGFsbCBvZiBhIHVuaWZvcm0gZGVjbGFyZWQgdHlwZS5cbiAqIElmIHRoZSB0eXBlIHN0b3JlZCBpbiBhIG1hcCBoYXMgYW4gaWRlbnRpZmllciwgaXQgaXMgbWFuZGF0b3J5IHRvIHN0b3JlIHRoZSBjaGlsZCB1bmRlciB0aGF0IGlkZW50aWZpZXIgaW4gdGhlIG1hcC5cbiAqXG4gKiBUaGlzIHR5cGUgd2lsbCBhbHdheXMgcHJvZHVjZSBbb2JzZXJ2YWJsZSBtYXBzXShodHRwczovL21vYnguanMub3JnL2FwaS5odG1sI29ic2VydmFibGVtYXApXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBUb2RvID0gdHlwZXMubW9kZWwoe1xuICogICBpZDogdHlwZXMuaWRlbnRpZmllcixcbiAqICAgdGFzazogdHlwZXMuc3RyaW5nXG4gKiB9KVxuICpcbiAqIGNvbnN0IFRvZG9TdG9yZSA9IHR5cGVzLm1vZGVsKHtcbiAqICAgdG9kb3M6IHR5cGVzLm1hcChUb2RvKVxuICogfSlcbiAqXG4gKiBjb25zdCBzID0gVG9kb1N0b3JlLmNyZWF0ZSh7IHRvZG9zOiB7fSB9KVxuICogdW5wcm90ZWN0KHMpXG4gKiBzLnRvZG9zLnNldCgxNywgeyB0YXNrOiBcIkdyYWIgY29mZmVlXCIsIGlkOiAxNyB9KVxuICogcy50b2Rvcy5wdXQoeyB0YXNrOiBcIkdyYWIgY29va2llXCIsIGlkOiAxOCB9KSAvLyBwdXQgd2lsbCBpbmZlciBrZXkgZnJvbSB0aGUgaWRlbnRpZmllclxuICogY29uc29sZS5sb2cocy50b2Rvcy5nZXQoMTcpLnRhc2spIC8vIHByaW50czogXCJHcmFiIGNvZmZlZVwiXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3VidHlwZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gbWFwKHN1YnR5cGUpIHtcbiAgICByZXR1cm4gbmV3IE1hcFR5cGUoXCJtYXA8c3RyaW5nLCBcIiArIHN1YnR5cGUubmFtZSArIFwiPlwiLCBzdWJ0eXBlKTtcbn1cbi8qKlxuICogUmV0dXJucyBpZiBhIGdpdmVuIHZhbHVlIHJlcHJlc2VudHMgYSBtYXAgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnMgYHRydWVgIGlmIGl0IGlzIGEgbWFwIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzTWFwVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIGlzVHlwZSh0eXBlKSAmJiAodHlwZS5mbGFncyAmIFR5cGVGbGFncy5NYXApID4gMDtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIEFycmF5VHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5VHlwZShuYW1lLCBfc3ViVHlwZSwgaG9va0luaXRpYWxpemVycykge1xuICAgICAgICBpZiAoaG9va0luaXRpYWxpemVycyA9PT0gdm9pZCAwKSB7IGhvb2tJbml0aWFsaXplcnMgPSBbXTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX3N1YlR5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IF9zdWJUeXBlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZmxhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFR5cGVGbGFncy5BcnJheVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImhvb2tJbml0aWFsaXplcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5ob29rSW5pdGlhbGl6ZXJzID0gaG9va0luaXRpYWxpemVycztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJob29rc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGhvb2tzKSB7XG4gICAgICAgICAgICB2YXIgaG9va0luaXRpYWxpemVycyA9IHRoaXMuaG9va0luaXRpYWxpemVycy5sZW5ndGggPiAwID8gdGhpcy5ob29rSW5pdGlhbGl6ZXJzLmNvbmNhdChob29rcykgOiBbaG9va3NdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheVR5cGUodGhpcy5uYW1lLCB0aGlzLl9zdWJUeXBlLCBob29rSW5pdGlhbGl6ZXJzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlT2JqZWN0Tm9kZSh0aGlzLCBwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwiaW5pdGlhbGl6ZUNoaWxkTm9kZXNcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChvYmpOb2RlLCBzbmFwc2hvdCkge1xuICAgICAgICAgICAgaWYgKHNuYXBzaG90ID09PSB2b2lkIDApIHsgc25hcHNob3QgPSBbXTsgfVxuICAgICAgICAgICAgdmFyIHN1YlR5cGUgPSBvYmpOb2RlLnR5cGUuX3N1YlR5cGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBzbmFwc2hvdC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJwYXRoID0gXCJcIiArIGluZGV4O1xuICAgICAgICAgICAgICAgIHJlc3VsdFtzdWJwYXRoXSA9IHN1YlR5cGUuaW5zdGFudGlhdGUob2JqTm9kZSwgc3VicGF0aCwgdW5kZWZpbmVkLCBpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVR5cGUucHJvdG90eXBlLCBcImNyZWF0ZU5ld0luc3RhbmNlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGUuYXJyYXkoY29udmVydENoaWxkTm9kZXNUb0FycmF5KGNoaWxkTm9kZXMpLCBtb2J4U2hhbGxvdyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJmaW5hbGl6ZU5ld0luc3RhbmNlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIF9nZXRBZG1pbmlzdHJhdGlvbihpbnN0YW5jZSkuZGVoYW5jZXIgPSBub2RlLnVuYm94O1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgICAgICB0eXBlLmhvb2tJbml0aWFsaXplcnMuZm9yRWFjaChmdW5jdGlvbiAoaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaG9va3MgPSBpbml0aWFsaXplcihpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoaG9va3MpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvb2sgPSBob29rc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbkludm9rZXIgPSBjcmVhdGVBY3Rpb25JbnZva2VyKGluc3RhbmNlLCBuYW1lLCBob29rKTtcbiAgICAgICAgICAgICAgICAgICAgKCFkZXZNb2RlKCkgPyBhZGRIaWRkZW5GaW5hbFByb3AgOiBhZGRIaWRkZW5Xcml0YWJsZVByb3ApKGluc3RhbmNlLCBuYW1lLCBhY3Rpb25JbnZva2VyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW50ZXJjZXB0KGluc3RhbmNlLCB0aGlzLndpbGxDaGFuZ2UpO1xuICAgICAgICAgICAgb2JzZXJ2ZShpbnN0YW5jZSwgdGhpcy5kaWRDaGFuZ2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJUeXBlLmRlc2NyaWJlKCkgKyBcIltdXCI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJnZXRDaGlsZHJlblwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnN0b3JlZFZhbHVlLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJnZXRDaGlsZE5vZGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCBrZXkpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IE51bWJlcihrZXkpO1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgbm9kZS5zdG9yZWRWYWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3RvcmVkVmFsdWVbaW5kZXhdO1xuICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiTm90IGEgY2hpbGQ6IFwiICsga2V5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVR5cGUucHJvdG90eXBlLCBcIndpbGxDaGFuZ2VcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjaGFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZ2V0U3RhdGVUcmVlTm9kZShjaGFuZ2Uub2JqZWN0KTtcbiAgICAgICAgICAgIG5vZGUuYXNzZXJ0V3JpdGFibGUoeyBzdWJwYXRoOiBcIlwiICsgY2hhbmdlLmluZGV4IH0pO1xuICAgICAgICAgICAgdmFyIHN1YlR5cGUgPSBub2RlLnR5cGUuX3N1YlR5cGU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhbmdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UubmV3VmFsdWUgPT09IGNoYW5nZS5vYmplY3RbY2hhbmdlLmluZGV4XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVkTm9kZXMgPSByZWNvbmNpbGVBcnJheUNoaWxkcmVuKG5vZGUsIHN1YlR5cGUsIFtjaGlsZE5vZGVzW2NoYW5nZS5pbmRleF1dLCBbY2hhbmdlLm5ld1ZhbHVlXSwgW2NoYW5nZS5pbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1cGRhdGVkTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5uZXdWYWx1ZSA9IHVwZGF0ZWROb2Rlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic3BsaWNlXCI6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleF8xID0gY2hhbmdlLmluZGV4LCByZW1vdmVkQ291bnQgPSBjaGFuZ2UucmVtb3ZlZENvdW50LCBhZGRlZCA9IGNoYW5nZS5hZGRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRlZE5vZGVzID0gcmVjb25jaWxlQXJyYXlDaGlsZHJlbihub2RlLCBzdWJUeXBlLCBjaGlsZE5vZGVzLnNsaWNlKGluZGV4XzEsIGluZGV4XzEgKyByZW1vdmVkQ291bnQpLCBhZGRlZCwgYWRkZWQubWFwKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBpbmRleF8xICsgaTsgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZGRlZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UuYWRkZWQgPSBhZGRlZE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBhdGhzIG9mIHJlbWFpbmluZyBpdGVtc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4XzEgKyByZW1vdmVkQ291bnQ7IGkgPCBjaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc1tpXS5zZXRQYXJlbnQobm9kZSwgXCJcIiArIChpICsgYWRkZWQubGVuZ3RoIC0gcmVtb3ZlZENvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwiZ2V0U25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRDaGlsZHJlbigpLm1hcChmdW5jdGlvbiAoY2hpbGROb2RlKSB7IHJldHVybiBjaGlsZE5vZGUuc25hcHNob3Q7IH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwicHJvY2Vzc0luaXRpYWxTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBwcm9jZXNzZWQgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NlZC5wdXNoKGNoaWxkTm9kZXNba2V5XS5nZXRTbmFwc2hvdCgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVR5cGUucHJvdG90eXBlLCBcImRpZENoYW5nZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKGNoYW5nZS5vYmplY3QpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFuZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1cGRhdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgbm9kZS5lbWl0UGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogXCJcIiArIGNoYW5nZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaGFuZ2UubmV3VmFsdWUuc25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogY2hhbmdlLm9sZFZhbHVlID8gY2hhbmdlLm9sZFZhbHVlLnNuYXBzaG90IDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH0sIG5vZGUpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzcGxpY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGNoYW5nZS5yZW1vdmVkQ291bnQgLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZW1pdFBhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJyZW1vdmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIlwiICsgKGNoYW5nZS5pbmRleCArIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBjaGFuZ2UucmVtb3ZlZFtpXS5zbmFwc2hvdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlLmFkZGVkQ291bnQ7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZW1pdFBhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJhZGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcIlwiICsgKGNoYW5nZS5pbmRleCArIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBub2RlLmdldENoaWxkTm9kZShcIlwiICsgKGNoYW5nZS5pbmRleCArIGkpKS5zbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwiYXBwbHlQYXRjaExvY2FsbHlcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCBzdWJwYXRoLCBwYXRjaCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IG5vZGUuc3RvcmVkVmFsdWU7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzdWJwYXRoID09PSBcIi1cIiA/IHRhcmdldC5sZW5ndGggOiBOdW1iZXIoc3VicGF0aCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhdGNoLm9wKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcGxhY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2luZGV4XSA9IHBhdGNoLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5zcGxpY2UoaW5kZXgsIDAsIHBhdGNoLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlbW92ZVwiOlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXlUeXBlLnByb3RvdHlwZSwgXCJhcHBseVNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgc25hcHNob3QpIHtcbiAgICAgICAgICAgIHR5cGVjaGVja0ludGVybmFsKHRoaXMsIHNuYXBzaG90KTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBub2RlLnN0b3JlZFZhbHVlO1xuICAgICAgICAgICAgdGFyZ2V0LnJlcGxhY2Uoc25hcHNob3QpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwiZ2V0Q2hpbGRUeXBlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3ViVHlwZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVR5cGUucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHZhbHVlLCBcIlZhbHVlIGlzIG5vdCBhbiBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVHlwZUVycm9ycyh2YWx1ZS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zdWJUeXBlLnZhbGlkYXRlKGl0ZW0sIGdldENvbnRleHRGb3JQYXRoKGNvbnRleHQsIFwiXCIgKyBpbmRleCwgX3RoaXMuX3N1YlR5cGUpKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheVR5cGUucHJvdG90eXBlLCBcImdldERlZmF1bHRTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEVNUFRZX0FSUkFZO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5VHlwZS5wcm90b3R5cGUsIFwicmVtb3ZlQ2hpbGRcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCBzdWJwYXRoKSB7XG4gICAgICAgICAgICBub2RlLnN0b3JlZFZhbHVlLnNwbGljZShOdW1iZXIoc3VicGF0aCksIDEpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEFycmF5VHlwZTtcbn0oQ29tcGxleFR5cGUpKTtcbkFycmF5VHlwZS5wcm90b3R5cGUuYXBwbHlTbmFwc2hvdCA9IGFjdGlvbihBcnJheVR5cGUucHJvdG90eXBlLmFwcGx5U25hcHNob3QpO1xuLyoqXG4gKiBgdHlwZXMuYXJyYXlgIC0gQ3JlYXRlcyBhbiBpbmRleCBiYXNlZCBjb2xsZWN0aW9uIHR5cGUgd2hvJ3MgY2hpbGRyZW4gYXJlIGFsbCBvZiBhIHVuaWZvcm0gZGVjbGFyZWQgdHlwZS5cbiAqXG4gKiBUaGlzIHR5cGUgd2lsbCBhbHdheXMgcHJvZHVjZSBbb2JzZXJ2YWJsZSBhcnJheXNdKGh0dHBzOi8vbW9ieC5qcy5vcmcvYXBpLmh0bWwjb2JzZXJ2YWJsZWFycmF5KVxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogY29uc3QgVG9kbyA9IHR5cGVzLm1vZGVsKHtcbiAqICAgdGFzazogdHlwZXMuc3RyaW5nXG4gKiB9KVxuICpcbiAqIGNvbnN0IFRvZG9TdG9yZSA9IHR5cGVzLm1vZGVsKHtcbiAqICAgdG9kb3M6IHR5cGVzLmFycmF5KFRvZG8pXG4gKiB9KVxuICpcbiAqIGNvbnN0IHMgPSBUb2RvU3RvcmUuY3JlYXRlKHsgdG9kb3M6IFtdIH0pXG4gKiB1bnByb3RlY3QocykgLy8gbmVlZGVkIHRvIGFsbG93IG1vZGlmeWluZyBvdXRzaWRlIG9mIGFuIGFjdGlvblxuICogcy50b2Rvcy5wdXNoKHsgdGFzazogXCJHcmFiIGNvZmZlZVwiIH0pXG4gKiBjb25zb2xlLmxvZyhzLnRvZG9zWzBdKSAvLyBwcmludHM6IFwiR3JhYiBjb2ZmZWVcIlxuICogYGBgXG4gKlxuICogQHBhcmFtIHN1YnR5cGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGFycmF5KHN1YnR5cGUpIHtcbiAgICBhc3NlcnRJc1R5cGUoc3VidHlwZSwgMSk7XG4gICAgcmV0dXJuIG5ldyBBcnJheVR5cGUoc3VidHlwZS5uYW1lICsgXCJbXVwiLCBzdWJ0eXBlKTtcbn1cbmZ1bmN0aW9uIHJlY29uY2lsZUFycmF5Q2hpbGRyZW4ocGFyZW50LCBjaGlsZFR5cGUsIG9sZE5vZGVzLCBuZXdWYWx1ZXMsIG5ld1BhdGhzKSB7XG4gICAgdmFyIG5vdGhpbmdDaGFuZ2VkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDs7IGkrKykge1xuICAgICAgICB2YXIgaGFzTmV3Tm9kZSA9IGkgPD0gbmV3VmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBvbGROb2RlID0gb2xkTm9kZXNbaV07XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IGhhc05ld05vZGUgPyBuZXdWYWx1ZXNbaV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBuZXdQYXRoID0gXCJcIiArIG5ld1BhdGhzW2ldO1xuICAgICAgICAvLyBmb3Igc29tZSByZWFzb24sIGluc3RlYWQgb2YgbmV3VmFsdWUgd2UgZ290IGEgbm9kZSwgZmFsbGJhY2sgdG8gdGhlIHN0b3JlZFZhbHVlXG4gICAgICAgIC8vIFRPRE86IGh0dHBzOi8vZ2l0aHViLmNvbS9tb2J4anMvbW9ieC1zdGF0ZS10cmVlL2lzc3Vlcy8zNDAjaXNzdWVjb21tZW50LTMyNTU4MTY4MVxuICAgICAgICBpZiAoaXNOb2RlKG5ld1ZhbHVlKSlcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUuc3RvcmVkVmFsdWU7XG4gICAgICAgIGlmICghb2xkTm9kZSAmJiAhaGFzTmV3Tm9kZSkge1xuICAgICAgICAgICAgLy8gYm90aCBhcmUgZW1wdHksIGVuZFxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWhhc05ld05vZGUpIHtcbiAgICAgICAgICAgIC8vIG5ldyBvbmUgZG9lcyBub3QgZXhpc3RzXG4gICAgICAgICAgICBub3RoaW5nQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgb2xkTm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaWYgKG9sZE5vZGUgaW5zdGFuY2VvZiBPYmplY3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgaXQgaXMgZ29pbmcgdG8gYmUgcmV0dXJuZWQgYnkgcG9wL3NwbGljZS9zaGlmdCBiZXR0ZXIgY3JlYXRlIGl0IGJlZm9yZSBraWxsaW5nIGl0XG4gICAgICAgICAgICAgICAgLy8gc28gaXQgZG9lc24ndCBlbmQgdXAgaW4gYW4gdW5kZWFkIHN0YXRlXG4gICAgICAgICAgICAgICAgb2xkTm9kZS5jcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2VJZk5lZWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2xkTm9kZS5kaWUoKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb2xkTm9kZSkge1xuICAgICAgICAgICAgLy8gdGhlcmUgaXMgbm8gb2xkIG5vZGUsIGNyZWF0ZSBpdFxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgYWxyZWFkeSBiZWxvbmdzIHRvIHRoZSBzYW1lIHBhcmVudC4gaWYgc28sIGF2b2lkIHB1c2hpbmcgaXRlbSBpbi4gb25seSBzd2FwcGluZyBjYW4gb2NjdXIuXG4gICAgICAgICAgICBpZiAoaXNTdGF0ZVRyZWVOb2RlKG5ld1ZhbHVlKSAmJiBnZXRTdGF0ZVRyZWVOb2RlKG5ld1ZhbHVlKS5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBpcyBvd25lZCBieSB0aGlzIHBhcmVudCwgYnV0IG5vdCBpbiB0aGUgcmVjb25jaWxhYmxlIHNldCwgc28gaXQgbXVzdCBiZSBkb3VibGVcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJDYW5ub3QgYWRkIGFuIG9iamVjdCB0byBhIHN0YXRlIHRyZWUgaWYgaXQgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBzYW1lIG9yIGFub3RoZXIgc3RhdGUgdHJlZS4gVHJpZWQgdG8gYXNzaWduIGFuIG9iamVjdCB0byAnXCIgKyBwYXJlbnQucGF0aCArIFwiL1wiICsgbmV3UGF0aCArIFwiJywgYnV0IGl0IGxpdmVzIGFscmVhZHkgYXQgJ1wiICsgZ2V0U3RhdGVUcmVlTm9kZShuZXdWYWx1ZSkucGF0aCArIFwiJ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vdGhpbmdDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IHZhbHVlQXNOb2RlKGNoaWxkVHlwZSwgcGFyZW50LCBuZXdQYXRoLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICBvbGROb2Rlcy5zcGxpY2UoaSwgMCwgbmV3Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJlU2FtZShvbGROb2RlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGJvdGggYXJlIHRoZSBzYW1lLCByZWNvbmNpbGVcbiAgICAgICAgICAgIG9sZE5vZGVzW2ldID0gdmFsdWVBc05vZGUoY2hpbGRUeXBlLCBwYXJlbnQsIG5ld1BhdGgsIG5ld1ZhbHVlLCBvbGROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG8sIHRyeSB0byByZW9yZGVyXG4gICAgICAgICAgICB2YXIgb2xkTWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvLyBmaW5kIGEgcG9zc2libGUgY2FuZGlkYXRlIHRvIHJldXNlXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gaTsgaiA8IG9sZE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZVNhbWUob2xkTm9kZXNbal0sIG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGRNYXRjaCA9IG9sZE5vZGVzLnNwbGljZShqLCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm90aGluZ0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBuZXdOb2RlID0gdmFsdWVBc05vZGUoY2hpbGRUeXBlLCBwYXJlbnQsIG5ld1BhdGgsIG5ld1ZhbHVlLCBvbGRNYXRjaCk7XG4gICAgICAgICAgICBvbGROb2Rlcy5zcGxpY2UoaSwgMCwgbmV3Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vdGhpbmdDaGFuZ2VkID8gbnVsbCA6IG9sZE5vZGVzO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBub2RlIGF0IGdpdmVuIHBhcmVudCBhbmQgc3VicGF0aC4gQXR0ZW1wdHMgdG8gcmV1c2Ugb2xkIG5vZGUgaWYgcG9zc2libGUgYW5kIGdpdmVuLlxuICovXG5mdW5jdGlvbiB2YWx1ZUFzTm9kZShjaGlsZFR5cGUsIHBhcmVudCwgc3VicGF0aCwgbmV3VmFsdWUsIG9sZE5vZGUpIHtcbiAgICAvLyBlbnN1cmUgdGhlIHZhbHVlIGlzIHZhbGlkLWlzaFxuICAgIHR5cGVjaGVja0ludGVybmFsKGNoaWxkVHlwZSwgbmV3VmFsdWUpO1xuICAgIGZ1bmN0aW9uIGdldE5ld05vZGUoKSB7XG4gICAgICAgIC8vIHRoZSBuZXcgdmFsdWUgaGFzIGEgTVNUIG5vZGVcbiAgICAgICAgaWYgKGlzU3RhdGVUcmVlTm9kZShuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGNoaWxkTm9kZS5hc3NlcnRBbGl2ZShFTVBUWV9PQkpFQ1QpO1xuICAgICAgICAgICAgLy8gdGhlIG5vZGUgbGl2ZXMgaGVyZVxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5wYXJlbnQgIT09IG51bGwgJiYgY2hpbGROb2RlLnBhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY2hpbGROb2RlLnNldFBhcmVudChwYXJlbnQsIHN1YnBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlcmUgaXMgb2xkIG5vZGUgYW5kIG5ldyBvbmUgaXMgYSB2YWx1ZS9zbmFwc2hvdFxuICAgICAgICBpZiAob2xkTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkVHlwZS5yZWNvbmNpbGUob2xkTm9kZSwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90aGluZyB0byBkbywgY3JlYXRlIGZyb20gc2NyYXRjaFxuICAgICAgICByZXR1cm4gY2hpbGRUeXBlLmluc3RhbnRpYXRlKHBhcmVudCwgc3VicGF0aCwgdW5kZWZpbmVkLCBuZXdWYWx1ZSk7XG4gICAgfVxuICAgIHZhciBuZXdOb2RlID0gZ2V0TmV3Tm9kZSgpO1xuICAgIGlmIChvbGROb2RlICYmIG9sZE5vZGUgIT09IG5ld05vZGUpIHtcbiAgICAgICAgaWYgKG9sZE5vZGUgaW5zdGFuY2VvZiBPYmplY3ROb2RlKSB7XG4gICAgICAgICAgICAvLyBzaW5jZSBpdCBpcyBnb2luZyB0byBiZSByZXR1cm5lZCBieSBwb3Avc3BsaWNlL3NoaWZ0IGJldHRlciBjcmVhdGUgaXQgYmVmb3JlIGtpbGxpbmcgaXRcbiAgICAgICAgICAgIC8vIHNvIGl0IGRvZXNuJ3QgZW5kIHVwIGluIGFuIHVuZGVhZCBzdGF0ZVxuICAgICAgICAgICAgb2xkTm9kZS5jcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2VJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIG9sZE5vZGUuZGllKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIG5vZGUgaG9sZHMgYSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlU2FtZShvbGROb2RlLCBuZXdWYWx1ZSkge1xuICAgIC8vIG5ldmVyIGNvbnNpZGVyIGRlYWQgb2xkIG5vZGVzIGZvciByZWNvbmNpbGlhdGlvblxuICAgIGlmICghb2xkTm9kZS5pc0FsaXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gdGhlIG5ldyB2YWx1ZSBoYXMgdGhlIHNhbWUgbm9kZVxuICAgIGlmIChpc1N0YXRlVHJlZU5vZGUobmV3VmFsdWUpKSB7XG4gICAgICAgIHZhciBuZXdOb2RlID0gZ2V0U3RhdGVUcmVlTm9kZShuZXdWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXdOb2RlLmlzQWxpdmUgJiYgbmV3Tm9kZSA9PT0gb2xkTm9kZTtcbiAgICB9XG4gICAgLy8gdGhlIHByb3ZpZGVkIHZhbHVlIGlzIHRoZSBzbmFwc2hvdCBvZiB0aGUgb2xkIG5vZGVcbiAgICBpZiAob2xkTm9kZS5zbmFwc2hvdCA9PT0gbmV3VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIE5vbiBvYmplY3Qgbm9kZXMgZG9uJ3QgZ2V0IHJlY29uY2lsZWRcbiAgICBpZiAoIShvbGROb2RlIGluc3RhbmNlb2YgT2JqZWN0Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgb2xkTm9kZVR5cGUgPSBvbGROb2RlLmdldFJlY29uY2lsaWF0aW9uVHlwZSgpO1xuICAgIC8vIG5ldyB2YWx1ZSBpcyBhIHNuYXBzaG90IHdpdGggdGhlIGNvcnJlY3QgaWRlbnRpZmllclxuICAgIHJldHVybiAob2xkTm9kZS5pZGVudGlmaWVyICE9PSBudWxsICYmXG4gICAgICAgIG9sZE5vZGUuaWRlbnRpZmllckF0dHJpYnV0ZSAmJlxuICAgICAgICBpc1BsYWluT2JqZWN0KG5ld1ZhbHVlKSAmJlxuICAgICAgICBvbGROb2RlVHlwZS5pcyhuZXdWYWx1ZSkgJiZcbiAgICAgICAgb2xkTm9kZVR5cGUuaXNNYXRjaGluZ1NuYXBzaG90SWQob2xkTm9kZSwgbmV3VmFsdWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyBpZiBhIGdpdmVuIHZhbHVlIHJlcHJlc2VudHMgYW4gYXJyYXkgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB0eXBlIGlzIGFuIGFycmF5IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gaXNUeXBlKHR5cGUpICYmICh0eXBlLmZsYWdzICYgVHlwZUZsYWdzLkFycmF5KSA+IDA7XG59XG5cbnZhciBQUkVfUFJPQ0VTU19TTkFQU0hPVCA9IFwicHJlUHJvY2Vzc1NuYXBzaG90XCI7XG52YXIgUE9TVF9QUk9DRVNTX1NOQVBTSE9UID0gXCJwb3N0UHJvY2Vzc1NuYXBzaG90XCI7XG5mdW5jdGlvbiBvYmplY3RUeXBlVG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGdldFN0YXRlVHJlZU5vZGUodGhpcykudG9TdHJpbmcoKTtcbn1cbnZhciBkZWZhdWx0T2JqZWN0T3B0aW9ucyA9IHtcbiAgICBuYW1lOiBcIkFub255bW91c01vZGVsXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgaW5pdGlhbGl6ZXJzOiBFTVBUWV9BUlJBWVxufTtcbmZ1bmN0aW9uIHRvUHJvcGVydGllc09iamVjdChkZWNsYXJlZFByb3BzKSB7XG4gICAgLy8gbG9vcCB0aHJvdWdoIHByb3BlcnRpZXMgYW5kIGVuc3VyZXMgdGhhdCBhbGwgaXRlbXMgYXJlIHR5cGVzXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRlY2xhcmVkUHJvcHMpLnJlZHVjZShmdW5jdGlvbiAocHJvcHMsIGtleSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgLy8gd2FybiBpZiB1c2VyIGludGVuZGVkIGEgSE9PS1xuICAgICAgICBpZiAoa2V5IGluIEhvb2spXG4gICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJIb29rICdcIiArIGtleSArIFwiJyB3YXMgZGVmaW5lZCBhcyBwcm9wZXJ0eS4gSG9va3Mgc2hvdWxkIGJlIGRlZmluZWQgYXMgcGFydCBvZiB0aGUgYWN0aW9uc1wiKTtcbiAgICAgICAgLy8gdGhlIHVzZXIgaW50ZW5kZWQgdG8gdXNlIGEgdmlld1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvcHMsIGtleSk7XG4gICAgICAgIGlmIChcImdldFwiIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkdldHRlcnMgYXJlIG5vdCBzdXBwb3J0ZWQgYXMgcHJvcGVydGllcy4gUGxlYXNlIHVzZSB2aWV3cyBpbnN0ZWFkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVuZGVmaW5lZCBhbmQgbnVsbCBhcmUgbm90IHZhbGlkXG4gICAgICAgIHZhciB2YWx1ZSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJUaGUgZGVmYXVsdCB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGFzIHRoZSB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZC4gRGlkIHlvdSBtZWFuIGB0eXBlcy5tYXliZShzb21lVHlwZSlgP1wiKTtcbiAgICAgICAgICAgIC8vIGl0cyBhIHByaW1pdGl2ZSwgY29udmVydCB0byBpdHMgdHlwZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICBfYVtrZXldID0gb3B0aW9uYWwoZ2V0UHJpbWl0aXZlRmFjdG9yeUZyb21WYWx1ZSh2YWx1ZSksIHZhbHVlKSxcbiAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgLy8gbWFwIGRlZmF1bHRzIHRvIGVtcHR5IG9iamVjdCBhdXRvbWF0aWNhbGx5IGZvciBtb2RlbHNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgKF9iID0ge30sXG4gICAgICAgICAgICAgICAgX2Jba2V5XSA9IG9wdGlvbmFsKHZhbHVlLCB7fSksXG4gICAgICAgICAgICAgICAgX2IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5VHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCAoX2MgPSB7fSwgX2Nba2V5XSA9IG9wdGlvbmFsKHZhbHVlLCBbXSksIF9jKSk7XG4gICAgICAgICAgICAvLyBpdHMgYWxyZWFkeSBhIHR5cGVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1R5cGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgICAgICAvLyBpdHMgYSBmdW5jdGlvbiwgbWF5YmUgdGhlIHVzZXIgd2FudGVkIGEgdmlldz9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZXZNb2RlKCkgJiYgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkludmFsaWQgdHlwZSBkZWZpbml0aW9uIGZvciBwcm9wZXJ0eSAnXCIgKyBrZXkgKyBcIicsIGl0IGxvb2tzIGxpa2UgeW91IHBhc3NlZCBhIGZ1bmN0aW9uLiBEaWQgeW91IGZvcmdldCB0byBpbnZva2UgaXQsIG9yIGRpZCB5b3UgaW50ZW5kIHRvIGRlY2xhcmUgYSB2aWV3IC8gYWN0aW9uP1wiKTtcbiAgICAgICAgICAgIC8vIG5vIG90aGVyIGNvbXBsZXggdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGV2TW9kZSgpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiSW52YWxpZCB0eXBlIGRlZmluaXRpb24gZm9yIHByb3BlcnR5ICdcIiArIGtleSArIFwiJywgaXQgbG9va3MgbGlrZSB5b3UgcGFzc2VkIGFuIG9iamVjdC4gVHJ5IHBhc3NpbmcgYW5vdGhlciBtb2RlbCB0eXBlIG9yIGEgdHlwZXMuZnJvemVuLlwiKTtcbiAgICAgICAgICAgIC8vIFdURiBkaWQgeW91IHBhc3MgaW4gbWF0ZT9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkludmFsaWQgdHlwZSBkZWZpbml0aW9uIGZvciBwcm9wZXJ0eSAnXCIgKyBrZXkgKyBcIicsIGNhbm5vdCBpbmZlciBhIHR5cGUgZnJvbSBhIHZhbHVlIGxpa2UgJ1wiICsgdmFsdWUgKyBcIicgKFwiICsgdHlwZW9mIHZhbHVlICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgfSwgZGVjbGFyZWRQcm9wcyk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG52YXIgTW9kZWxUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb2RlbFR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9kZWxUeXBlKG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0cy5uYW1lIHx8IGRlZmF1bHRPYmplY3RPcHRpb25zLm5hbWUpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmbGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogVHlwZUZsYWdzLk9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIG9yaWdpbmFsIG9iamVjdCBkZWZpbml0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaW5pdGlhbGl6ZXJzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwcm9wZXJ0aWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwcmVQcm9jZXNzb3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcInBvc3RQcm9jZXNzb3JcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcInByb3BlcnR5TmFtZXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIm5hbWVkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jbG9uZUFuZEVuaGFuY2UoeyBuYW1lOiBuYW1lIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jbG9uZUFuZEVuaGFuY2UoeyBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcInByZVByb2Nlc3NTbmFwc2hvdFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHByZVByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UHJlcHJvY2Vzc29yID0gX3RoaXMucHJlUHJvY2Vzc29yO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFByZXByb2Nlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNsb25lQW5kRW5oYW5jZSh7IHByZVByb2Nlc3NvcjogcHJlUHJvY2Vzc29yIH0pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNsb25lQW5kRW5oYW5jZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVQcm9jZXNzb3I6IGZ1bmN0aW9uIChzbmFwc2hvdCkgeyByZXR1cm4gY3VycmVudFByZXByb2Nlc3NvcihwcmVQcm9jZXNzb3Ioc25hcHNob3QpKTsgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwb3N0UHJvY2Vzc1NuYXBzaG90XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocG9zdFByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UG9zdHByb2Nlc3NvciA9IF90aGlzLnBvc3RQcm9jZXNzb3I7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UG9zdHByb2Nlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNsb25lQW5kRW5oYW5jZSh7IHBvc3RQcm9jZXNzb3I6IHBvc3RQcm9jZXNzb3IgfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2xvbmVBbmRFbmhhbmNlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RQcm9jZXNzb3I6IGZ1bmN0aW9uIChzbmFwc2hvdCkgeyByZXR1cm4gcG9zdFByb2Nlc3NvcihjdXJyZW50UG9zdHByb2Nlc3NvcihzbmFwc2hvdCkpOyB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihfdGhpcywgZGVmYXVsdE9iamVjdE9wdGlvbnMsIG9wdHMpO1xuICAgICAgICAvLyBlbnN1cmVzIHRoYXQgYW55IGRlZmF1bHQgdmFsdWUgZ2V0cyBjb252ZXJ0ZWQgdG8gaXRzIHJlbGF0ZWQgdHlwZVxuICAgICAgICBfdGhpcy5wcm9wZXJ0aWVzID0gdG9Qcm9wZXJ0aWVzT2JqZWN0KF90aGlzLnByb3BlcnRpZXMpO1xuICAgICAgICBmcmVlemUoX3RoaXMucHJvcGVydGllcyk7IC8vIG1ha2Ugc3VyZSBub2JvZHkgbWVzc2VzIHdpdGggaXRcbiAgICAgICAgX3RoaXMucHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKF90aGlzLnByb3BlcnRpZXMpO1xuICAgICAgICBfdGhpcy5pZGVudGlmaWVyQXR0cmlidXRlID0gX3RoaXMuX2dldElkZW50aWZpZXJBdHRyaWJ1dGUoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJfZ2V0SWRlbnRpZmllckF0dHJpYnV0ZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJBdHRyaWJ1dGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmZvckFsbFByb3BzKGZ1bmN0aW9uIChwcm9wTmFtZSwgcHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcFR5cGUuZmxhZ3MgJiBUeXBlRmxhZ3MuSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWRlbnRpZmllckF0dHJpYnV0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkNhbm5vdCBkZWZpbmUgcHJvcGVydHkgJ1wiICsgcHJvcE5hbWUgKyBcIicgYXMgb2JqZWN0IGlkZW50aWZpZXIsIHByb3BlcnR5ICdcIiArIGlkZW50aWZpZXJBdHRyaWJ1dGUgKyBcIicgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGlkZW50aWZpZXIgcHJvcGVydHlcIik7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJBdHRyaWJ1dGUgPSBwcm9wTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBpZGVudGlmaWVyQXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiY2xvbmVBbmRFbmhhbmNlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2RlbFR5cGUoe1xuICAgICAgICAgICAgICAgIG5hbWU6IG9wdHMubmFtZSB8fCB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wZXJ0aWVzLCBvcHRzLnByb3BlcnRpZXMpLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVyczogdGhpcy5pbml0aWFsaXplcnMuY29uY2F0KG9wdHMuaW5pdGlhbGl6ZXJzIHx8IFtdKSxcbiAgICAgICAgICAgICAgICBwcmVQcm9jZXNzb3I6IG9wdHMucHJlUHJvY2Vzc29yIHx8IHRoaXMucHJlUHJvY2Vzc29yLFxuICAgICAgICAgICAgICAgIHBvc3RQcm9jZXNzb3I6IG9wdHMucG9zdFByb2Nlc3NvciB8fCB0aGlzLnBvc3RQcm9jZXNzb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiYWN0aW9uc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGFjdGlvbkluaXRpYWxpemVyID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnN0YW50aWF0ZUFjdGlvbnMoc2VsZiwgZm4oc2VsZikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lQW5kRW5oYW5jZSh7IGluaXRpYWxpemVyczogW2FjdGlvbkluaXRpYWxpemVyXSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlQWN0aW9uc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNlbGYsIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHJldHVybiBpcyBjb3JyZWN0XG4gICAgICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9ucykpXG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiYWN0aW9ucyBpbml0aWFsaXplciBzaG91bGQgcmV0dXJuIGEgcGxhaW4gb2JqZWN0IGNvbnRhaW5pbmcgYWN0aW9uc1wiKTtcbiAgICAgICAgICAgIC8vIGJpbmQgYWN0aW9ucyB0byB0aGUgb2JqZWN0IGNyZWF0ZWRcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyB3YXJuIGlmIHByZXByb2Nlc3NvciB3YXMgZ2l2ZW5cbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gUFJFX1BST0NFU1NfU05BUFNIT1QpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkNhbm5vdCBkZWZpbmUgYWN0aW9uICdcIiArIFBSRV9QUk9DRVNTX1NOQVBTSE9UICsgXCInLCBpdCBzaG91bGQgYmUgZGVmaW5lZCB1c2luZyAndHlwZS5wcmVQcm9jZXNzU25hcHNob3QoZm4pJyBpbnN0ZWFkXCIpO1xuICAgICAgICAgICAgICAgIC8vIHdhcm4gaWYgcG9zdHByb2Nlc3NvciB3YXMgZ2l2ZW5cbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gUE9TVF9QUk9DRVNTX1NOQVBTSE9UKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJDYW5ub3QgZGVmaW5lIGFjdGlvbiAnXCIgKyBQT1NUX1BST0NFU1NfU05BUFNIT1QgKyBcIicsIGl0IHNob3VsZCBiZSBkZWZpbmVkIHVzaW5nICd0eXBlLnBvc3RQcm9jZXNzU25hcHNob3QoZm4pJyBpbnN0ZWFkXCIpO1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb24yID0gYWN0aW9uc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAvLyBhcHBseSBob29rIGNvbXBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VBY3Rpb24gPSBzZWxmW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIEhvb2sgJiYgYmFzZUFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BlY2lhbGl6ZWRBY3Rpb25fMSA9IGFjdGlvbjI7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlQWN0aW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsaXplZEFjdGlvbl8xLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoZSBnb2FsIG9mIHRoaXMgaXMgdG8gbWFrZSBzdXJlIGFjdGlvbnMgdXNpbmcgXCJ0aGlzXCIgY2FuIGNhbGwgdGhlbXNlbHZlcyxcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSBzdGlsbCBhbGxvd2luZyB0aGUgbWlkZGxld2FyZXMgdG8gcmVnaXN0ZXIgdGhlbVxuICAgICAgICAgICAgICAgIHZhciBtaWRkbGV3YXJlcyA9IGFjdGlvbjIuJG1zdF9taWRkbGV3YXJlOyAvLyBtYWtlIHN1cmUgbWlkZGxld2FyZXMgYXJlIG5vdCBsb3N0XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kQWN0aW9uID0gYWN0aW9uMi5iaW5kKGFjdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJvdW5kQWN0aW9uLiRtc3RfbWlkZGxld2FyZSA9IG1pZGRsZXdhcmVzO1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25JbnZva2VyID0gY3JlYXRlQWN0aW9uSW52b2tlcihzZWxmLCBuYW1lLCBib3VuZEFjdGlvbik7XG4gICAgICAgICAgICAgICAgYWN0aW9uc1tuYW1lXSA9IGFjdGlvbkludm9rZXI7XG4gICAgICAgICAgICAgICAgKCFkZXZNb2RlKCkgPyBhZGRIaWRkZW5GaW5hbFByb3AgOiBhZGRIaWRkZW5Xcml0YWJsZVByb3ApKHNlbGYsIG5hbWUsIGFjdGlvbkludm9rZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJ2b2xhdGlsZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiWW91IHBhc3NlZCBhbiBcIiArIHR5cGVvZiBmbiArIFwiIHRvIHZvbGF0aWxlIHN0YXRlIGFzIGFuIGFyZ3VtZW50LCB3aGVuIGZ1bmN0aW9uIGlzIGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0YXRlSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoc2VsZikge1xuICAgICAgICAgICAgICAgIF90aGlzLmluc3RhbnRpYXRlVm9sYXRpbGVTdGF0ZShzZWxmLCBmbihzZWxmKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmVBbmRFbmhhbmNlKHsgaW5pdGlhbGl6ZXJzOiBbc3RhdGVJbml0aWFsaXplcl0gfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJpbnN0YW50aWF0ZVZvbGF0aWxlU3RhdGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChzZWxmLCBzdGF0ZSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgdmlld3MgcmV0dXJuXG4gICAgICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3Qoc3RhdGUpKVxuICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcInZvbGF0aWxlIHN0YXRlIGluaXRpYWxpemVyIHNob3VsZCByZXR1cm4gYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyBzdGF0ZVwiKTtcbiAgICAgICAgICAgIHNldChzZWxmLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJleHRlbmRcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpbml0aWFsaXplciA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZm4oc2VsZiksIGFjdGlvbnMgPSBfYS5hY3Rpb25zLCB2aWV3cyA9IF9hLnZpZXdzLCBzdGF0ZSA9IF9hLnN0YXRlLCByZXN0ID0gX19yZXN0KF9hLCBbXCJhY3Rpb25zXCIsIFwidmlld3NcIiwgXCJzdGF0ZVwiXSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHJlc3QpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIlRoZSBgZXh0ZW5kYCBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGEgc3Vic2V0IG9mIHRoZSBmaWVsZHMgJ2FjdGlvbnMnLCAndmlld3MnIGFuZCAnc3RhdGUnLiBGb3VuZCBpbnZhbGlkIGtleSAnXCIgKyBrZXkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnN0YW50aWF0ZVZvbGF0aWxlU3RhdGUoc2VsZiwgc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3cylcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5zdGFudGlhdGVWaWV3cyhzZWxmLCB2aWV3cyk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmluc3RhbnRpYXRlQWN0aW9ucyhzZWxmLCBhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZUFuZEVuaGFuY2UoeyBpbml0aWFsaXplcnM6IFtpbml0aWFsaXplcl0gfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJ2aWV3c1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHZpZXdJbml0aWFsaXplciA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5zdGFudGlhdGVWaWV3cyhzZWxmLCBmbihzZWxmKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmVBbmRFbmhhbmNlKHsgaW5pdGlhbGl6ZXJzOiBbdmlld0luaXRpYWxpemVyXSB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlVmlld3NcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChzZWxmLCB2aWV3cykge1xuICAgICAgICAgICAgLy8gY2hlY2sgdmlld3MgcmV0dXJuXG4gICAgICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3Qodmlld3MpKVxuICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcInZpZXdzIGluaXRpYWxpemVyIHNob3VsZCByZXR1cm4gYSBwbGFpbiBvYmplY3QgY29udGFpbmluZyB2aWV3c1wiKTtcbiAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZpZXdzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgLy8gaXMgdGhpcyBhIGNvbXB1dGVkIHByb3BlcnR5P1xuICAgICAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2aWV3cywga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJnZXRcIiBpbiBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5JDEoc2VsZiwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgbWFrZU9ic2VydmFibGUoc2VsZiwgKF9hID0ge30sIF9hW2tleV0gPSBjb21wdXRlZCwgX2EpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAoIWRldk1vZGUoKSA/IGFkZEhpZGRlbkZpbmFsUHJvcCA6IGFkZEhpZGRlbldyaXRhYmxlUHJvcCkoc2VsZiwga2V5LCBkZXNjcmlwdG9yLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkEgdmlldyBtZW1iZXIgc2hvdWxkIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGdldHRlciBiYXNlZCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBpc1N0YXRlVHJlZU5vZGUoaW5pdGlhbFZhbHVlKVxuICAgICAgICAgICAgICAgID8gaW5pdGlhbFZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLmFwcGx5U25hcHNob3RQcmVQcm9jZXNzb3IoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVPYmplY3ROb2RlKHRoaXMsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbjogcmVjb3JkIGFsbCBwcm9wLSB2aWV3LSBhbmQgYWN0aW9uIG5hbWVzIGFmdGVyIGZpcnN0IGNvbnN0cnVjdGlvbiwgYW5kIGdlbmVyYXRlIGFuIG9wdGltYWwgYmFzZSBjbGFzc1xuICAgICAgICAgICAgLy8gdGhhdCBwcmUtcmVzZXJ2ZXMgYWxsIHRoZXNlIGZpZWxkcyBmb3IgZmFzdCBvYmplY3QtbWVtYmVyIGxvb2t1cHNcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImluaXRpYWxpemVDaGlsZE5vZGVzXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqTm9kZSwgaW5pdGlhbFNuYXBzaG90KSB7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbFNuYXBzaG90ID09PSB2b2lkIDApIHsgaW5pdGlhbFNuYXBzaG90ID0ge307IH1cbiAgICAgICAgICAgIHZhciB0eXBlID0gb2JqTm9kZS50eXBlO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgdHlwZS5mb3JBbGxQcm9wcyhmdW5jdGlvbiAobmFtZSwgY2hpbGRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gY2hpbGRUeXBlLmluc3RhbnRpYXRlKG9iak5vZGUsIG5hbWUsIHVuZGVmaW5lZCwgaW5pdGlhbFNuYXBzaG90W25hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImNyZWF0ZU5ld0luc3RhbmNlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoY2hpbGROb2Rlcykge1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGUub2JqZWN0KGNoaWxkTm9kZXMsIEVNUFRZX09CSkVDVCwgbW9ieFNoYWxsb3cpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiZmluYWxpemVOZXdJbnN0YW5jZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIGluc3RhbmNlKSB7XG4gICAgICAgICAgICBhZGRIaWRkZW5GaW5hbFByb3AoaW5zdGFuY2UsIFwidG9TdHJpbmdcIiwgb2JqZWN0VHlwZVRvU3RyaW5nKTtcbiAgICAgICAgICAgIHRoaXMuZm9yQWxsUHJvcHMoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBfaW50ZXJjZXB0UmVhZHMoaW5zdGFuY2UsIG5hbWUsIG5vZGUudW5ib3gpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVycy5yZWR1Y2UoZnVuY3Rpb24gKHNlbGYsIGZuKSB7IHJldHVybiBmbihzZWxmKTsgfSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgaW50ZXJjZXB0KGluc3RhbmNlLCB0aGlzLndpbGxDaGFuZ2UpO1xuICAgICAgICAgICAgb2JzZXJ2ZShpbnN0YW5jZSwgdGhpcy5kaWRDaGFuZ2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwid2lsbENoYW5nZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGNoZykge1xuICAgICAgICAgICAgLy8gVE9ETzogbW9ieCB0eXBpbmdzIGRvbid0IHNlZW0gdG8gdGFrZSBpbnRvIGFjY291bnQgdGhhdCBuZXdWYWx1ZSBjYW4gYmUgc2V0IGV2ZW4gd2hlbiByZW1vdmluZyBhIHByb3BcbiAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGc7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGdldFN0YXRlVHJlZU5vZGUoY2hhbmdlLm9iamVjdCk7XG4gICAgICAgICAgICB2YXIgc3VicGF0aCA9IGNoYW5nZS5uYW1lO1xuICAgICAgICAgICAgbm9kZS5hc3NlcnRXcml0YWJsZSh7IHN1YnBhdGg6IHN1YnBhdGggfSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRUeXBlID0gbm9kZS50eXBlLnByb3BlcnRpZXNbc3VicGF0aF07XG4gICAgICAgICAgICAvLyBvbmx5IHByb3BlcnRpZXMgYXJlIHR5cGVkLCBzdGF0ZSBhcmUgc3RvcmVkIGFzLWlzIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIGlmIChjaGlsZFR5cGUpIHtcbiAgICAgICAgICAgICAgICB0eXBlY2hlY2tJbnRlcm5hbChjaGlsZFR5cGUsIGNoYW5nZS5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlLm5ld1ZhbHVlID0gY2hpbGRUeXBlLnJlY29uY2lsZShub2RlLmdldENoaWxkTm9kZShzdWJwYXRoKSwgY2hhbmdlLm5ld1ZhbHVlLCBub2RlLCBzdWJwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJkaWRDaGFuZ2VcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjaGcpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1vYnggdHlwaW5ncyBkb24ndCBzZWVtIHRvIHRha2UgaW50byBhY2NvdW50IHRoYXQgbmV3VmFsdWUgY2FuIGJlIHNldCBldmVuIHdoZW4gcmVtb3ZpbmcgYSBwcm9wXG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hnO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGdldFN0YXRlVHJlZU5vZGUoY2hhbmdlLm9iamVjdCk7XG4gICAgICAgICAgICB2YXIgY2hpbGRUeXBlID0gY2hpbGROb2RlLnR5cGUucHJvcGVydGllc1tjaGFuZ2UubmFtZV07XG4gICAgICAgICAgICBpZiAoIWNoaWxkVHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGRvbid0IGVtaXQgcGF0Y2hlcyBmb3Igdm9sYXRpbGUgc3RhdGVcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2xkQ2hpbGRWYWx1ZSA9IGNoYW5nZS5vbGRWYWx1ZSA/IGNoYW5nZS5vbGRWYWx1ZS5zbmFwc2hvdCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNoaWxkTm9kZS5lbWl0UGF0Y2goe1xuICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBlc2NhcGVKc29uUGF0aChjaGFuZ2UubmFtZSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNoYW5nZS5uZXdWYWx1ZS5zbmFwc2hvdCxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkQ2hpbGRWYWx1ZVxuICAgICAgICAgICAgfSwgY2hpbGROb2RlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImdldENoaWxkcmVuXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZm9yQWxsUHJvcHMoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChfdGhpcy5nZXRDaGlsZE5vZGUobm9kZSwgbmFtZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiZ2V0Q2hpbGROb2RlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5wcm9wZXJ0aWVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJOb3QgYSB2YWx1ZSBwcm9wZXJ0eTogXCIgKyBrZXkpO1xuICAgICAgICAgICAgdmFyIGFkbSA9IF9nZXRBZG1pbmlzdHJhdGlvbihub2RlLnN0b3JlZFZhbHVlLCBrZXkpO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGFkbS5yYXcoKTtcbiAgICAgICAgICAgIGlmICghY2hpbGROb2RlKVxuICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIk5vZGUgbm90IGF2YWlsYWJsZSBmb3IgcHJvcGVydHkgXCIgKyBrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImdldFNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgYXBwbHlQb3N0UHJvY2Vzcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChhcHBseVBvc3RQcm9jZXNzID09PSB2b2lkIDApIHsgYXBwbHlQb3N0UHJvY2VzcyA9IHRydWU7IH1cbiAgICAgICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZm9yQWxsUHJvcHMoZnVuY3Rpb24gKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgICAgICAgICBnZXRBdG9tKG5vZGUuc3RvcmVkVmFsdWUsIG5hbWUpLnJlcG9ydE9ic2VydmVkKCk7XG4gICAgICAgICAgICAgICAgcmVzW25hbWVdID0gX3RoaXMuZ2V0Q2hpbGROb2RlKG5vZGUsIG5hbWUpLnNuYXBzaG90O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYXBwbHlQb3N0UHJvY2Vzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5U25hcHNob3RQb3N0UHJvY2Vzc29yKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwicHJvY2Vzc0luaXRpYWxTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBwcm9jZXNzZWQgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NlZFtrZXldID0gY2hpbGROb2Rlc1trZXldLmdldFNuYXBzaG90KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5U25hcHNob3RQb3N0UHJvY2Vzc29yKHByb2Nlc3NlZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJhcHBseVBhdGNoTG9jYWxseVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIHN1YnBhdGgsIHBhdGNoKSB7XG4gICAgICAgICAgICBpZiAoIShwYXRjaC5vcCA9PT0gXCJyZXBsYWNlXCIgfHwgcGF0Y2gub3AgPT09IFwiYWRkXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwib2JqZWN0IGRvZXMgbm90IHN1cHBvcnQgb3BlcmF0aW9uIFwiICsgcGF0Y2gub3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5zdG9yZWRWYWx1ZVtzdWJwYXRoXSA9IHBhdGNoLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiYXBwbHlTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIHNuYXBzaG90KSB7XG4gICAgICAgICAgICB0eXBlY2hlY2tJbnRlcm5hbCh0aGlzLCBzbmFwc2hvdCk7XG4gICAgICAgICAgICB2YXIgcHJlUHJvY2Vzc2VkU25hcHNob3QgPSB0aGlzLmFwcGx5U25hcHNob3RQcmVQcm9jZXNzb3Ioc25hcHNob3QpO1xuICAgICAgICAgICAgdGhpcy5mb3JBbGxQcm9wcyhmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuc3RvcmVkVmFsdWVbbmFtZV0gPSBwcmVQcm9jZXNzZWRTbmFwc2hvdFtuYW1lXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiYXBwbHlTbmFwc2hvdFByZVByb2Nlc3NvclwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgICAgICB2YXIgcHJvY2Vzc29yID0gdGhpcy5wcmVQcm9jZXNzb3I7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc29yID8gcHJvY2Vzc29yLmNhbGwobnVsbCwgc25hcHNob3QpIDogc25hcHNob3Q7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJhcHBseVNuYXBzaG90UG9zdFByb2Nlc3NvclwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgICAgICB2YXIgcG9zdFByb2Nlc3NvciA9IHRoaXMucG9zdFByb2Nlc3NvcjtcbiAgICAgICAgICAgIGlmIChwb3N0UHJvY2Vzc29yKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3N0UHJvY2Vzc29yLmNhbGwobnVsbCwgc25hcHNob3QpO1xuICAgICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiZ2V0Q2hpbGRUeXBlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocHJvcGVydHlOYW1lKSB7XG4gICAgICAgICAgICBhc3NlcnRJc1N0cmluZyhwcm9wZXJ0eU5hbWUsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiaXNWYWxpZFNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgc25hcHNob3QgPSB0aGlzLmFwcGx5U25hcHNob3RQcmVQcm9jZXNzb3IodmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KHNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHNuYXBzaG90LCBcIlZhbHVlIGlzIG5vdCBhIHBsYWluIG9iamVjdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbGF0dGVuVHlwZUVycm9ycyh0aGlzLnByb3BlcnR5TmFtZXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcGVydGllc1trZXldLnZhbGlkYXRlKHNuYXBzaG90W2tleV0sIGdldENvbnRleHRGb3JQYXRoKGNvbnRleHQsIGtleSwgX3RoaXMucHJvcGVydGllc1trZXldKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kZWxUeXBlLnByb3RvdHlwZSwgXCJmb3JBbGxQcm9wc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4oa2V5LCBfdGhpcy5wcm9wZXJ0aWVzW2tleV0pOyB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2RlbFR5cGUucHJvdG90eXBlLCBcImRlc2NyaWJlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLy8gb3B0aW1pemF0aW9uOiBjYWNoZVxuICAgICAgICAgICAgcmV0dXJuIChcInsgXCIgK1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHlOYW1lc1xuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleSArIFwiOiBcIiArIF90aGlzLnByb3BlcnRpZXNba2V5XS5kZXNjcmliZSgpOyB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcIjsgXCIpICtcbiAgICAgICAgICAgICAgICBcIiB9XCIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwiZ2V0RGVmYXVsdFNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gRU1QVFlfT0JKRUNUO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZGVsVHlwZS5wcm90b3R5cGUsIFwicmVtb3ZlQ2hpbGRcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCBzdWJwYXRoKSB7XG4gICAgICAgICAgICBub2RlLnN0b3JlZFZhbHVlW3N1YnBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIE1vZGVsVHlwZTtcbn0oQ29tcGxleFR5cGUpKTtcbk1vZGVsVHlwZS5wcm90b3R5cGUuYXBwbHlTbmFwc2hvdCA9IGFjdGlvbihNb2RlbFR5cGUucHJvdG90eXBlLmFwcGx5U25hcHNob3QpO1xuLyoqXG4gKiBgdHlwZXMubW9kZWxgIC0gQ3JlYXRlcyBhIG5ldyBtb2RlbCB0eXBlIGJ5IHByb3ZpZGluZyBhIG5hbWUsIHByb3BlcnRpZXMsIHZvbGF0aWxlIHN0YXRlIGFuZCBhY3Rpb25zLlxuICpcbiAqIFNlZSB0aGUgW21vZGVsIHR5cGVdKC9jb25jZXB0cy90cmVlcyNjcmVhdGluZy1tb2RlbHMpIGRlc2NyaXB0aW9uIG9yIHRoZSBbZ2V0dGluZyBzdGFydGVkXShpbnRyby9nZXR0aW5nLXN0YXJ0ZWQubWQjZ2V0dGluZy1zdGFydGVkLTEpIHR1dG9yaWFsLlxuICovXG5mdW5jdGlvbiBtb2RlbCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIiA/IGFyZ3Muc2hpZnQoKSA6IFwiQW5vbnltb3VzTW9kZWxcIjtcbiAgICB2YXIgcHJvcGVydGllcyA9IGFyZ3Muc2hpZnQoKSB8fCB7fTtcbiAgICByZXR1cm4gbmV3IE1vZGVsVHlwZSh7IG5hbWU6IG5hbWUsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMgfSk7XG59XG4vKipcbiAqIGB0eXBlcy5jb21wb3NlYCAtIENvbXBvc2VzIGEgbmV3IG1vZGVsIGZyb20gb25lIG9yIG1vcmUgZXhpc3RpbmcgbW9kZWwgdHlwZXMuXG4gKiBUaGlzIG1ldGhvZCBjYW4gYmUgaW52b2tlZCBpbiB0d28gZm9ybXM6XG4gKiBHaXZlbiAyIG9yIG1vcmUgbW9kZWwgdHlwZXMsIHRoZSB0eXBlcyBhcmUgY29tcG9zZWQgaW50byBhIG5ldyBUeXBlLlxuICogR2l2ZW4gZmlyc3QgcGFyYW1ldGVyIGFzIGEgc3RyaW5nIGFuZCAyIG9yIG1vcmUgbW9kZWwgdHlwZXMsXG4gKiB0aGUgdHlwZXMgYXJlIGNvbXBvc2VkIGludG8gYSBuZXcgVHlwZSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIC8vIFRPRE86IGp1c3Qgam9pbiB0aGUgYmFzZSB0eXBlIG5hbWVzIGlmIG5vIG5hbWUgaXMgcHJvdmlkZWRcbiAgICB2YXIgaGFzVHlwZW5hbWUgPSB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIjtcbiAgICB2YXIgdHlwZU5hbWUgPSBoYXNUeXBlbmFtZSA/IGFyZ3NbMF0gOiBcIkFub255bW91c01vZGVsXCI7XG4gICAgaWYgKGhhc1R5cGVuYW1lKSB7XG4gICAgICAgIGFyZ3Muc2hpZnQoKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgYWxsIHBhcmFtZXRlcnNcbiAgICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaSkge1xuICAgICAgICAgICAgYXNzZXJ0QXJnKHR5cGUsIGlzTW9kZWxUeXBlLCBcIm1vYngtc3RhdGUtdHJlZSBtb2RlbCB0eXBlXCIsIGhhc1R5cGVuYW1lID8gaSArIDIgOiBpICsgMSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJnc1xuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXIpIHtcbiAgICAgICAgcmV0dXJuIHByZXYuY2xvbmVBbmRFbmhhbmNlKHtcbiAgICAgICAgICAgIG5hbWU6IHByZXYubmFtZSArIFwiX1wiICsgY3VyLm5hbWUsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBjdXIucHJvcGVydGllcyxcbiAgICAgICAgICAgIGluaXRpYWxpemVyczogY3VyLmluaXRpYWxpemVycyxcbiAgICAgICAgICAgIHByZVByb2Nlc3NvcjogZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1ci5hcHBseVNuYXBzaG90UHJlUHJvY2Vzc29yKHByZXYuYXBwbHlTbmFwc2hvdFByZVByb2Nlc3NvcihzbmFwc2hvdCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc3RQcm9jZXNzb3I6IGZ1bmN0aW9uIChzbmFwc2hvdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXIuYXBwbHlTbmFwc2hvdFBvc3RQcm9jZXNzb3IocHJldi5hcHBseVNuYXBzaG90UG9zdFByb2Nlc3NvcihzbmFwc2hvdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgICAgICAubmFtZWQodHlwZU5hbWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIGEgZ2l2ZW4gdmFsdWUgcmVwcmVzZW50cyBhIG1vZGVsIHR5cGUuXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlzTW9kZWxUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gaXNUeXBlKHR5cGUpICYmICh0eXBlLmZsYWdzICYgVHlwZUZsYWdzLk9iamVjdCkgPiAwO1xufVxuXG4vLyBUT0RPOiBpbXBsZW1lbnQgQ29yZVR5cGUgdXNpbmcgdHlwZXMuY3VzdG9tID9cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBDb3JlVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29yZVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29yZVR5cGUobmFtZSwgZmxhZ3MsIGNoZWNrZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICAgIGlmIChpbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IGluaXRpYWxpemVyID0gaWRlbnRpdHk7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImZsYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBmbGFnc1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImNoZWNrZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGNoZWNrZXJcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpbml0aWFsaXplclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogaW5pdGlhbGl6ZXJcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvcmVUeXBlLnByb3RvdHlwZSwgXCJkZXNjcmliZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3JlVHlwZS5wcm90b3R5cGUsIFwiaW5zdGFudGlhdGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTY2FsYXJOb2RlKHRoaXMsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29yZVR5cGUucHJvdG90eXBlLCBcImNyZWF0ZU5ld0luc3RhbmNlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoc25hcHNob3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVyKHNuYXBzaG90KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb3JlVHlwZS5wcm90b3R5cGUsIFwiaXNWYWxpZFNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChpc1ByaW1pdGl2ZSh2YWx1ZSkgJiYgdGhpcy5jaGVja2VyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlQ2hlY2tTdWNjZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLm5hbWUgPT09IFwiRGF0ZVwiID8gXCJEYXRlIG9yIGEgdW5peCBtaWxsaXNlY29uZHMgdGltZXN0YW1wXCIgOiB0aGlzLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZUNoZWNrRmFpbHVyZShjb250ZXh0LCB2YWx1ZSwgXCJWYWx1ZSBpcyBub3QgYSBcIiArIHR5cGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDb3JlVHlwZTtcbn0oU2ltcGxlVHlwZSkpO1xuLyoqXG4gKiBgdHlwZXMuc3RyaW5nYCAtIENyZWF0ZXMgYSB0eXBlIHRoYXQgY2FuIG9ubHkgY29udGFpbiBhIHN0cmluZyB2YWx1ZS5cbiAqIFRoaXMgdHlwZSBpcyB1c2VkIGZvciBzdHJpbmcgdmFsdWVzIGJ5IGRlZmF1bHRcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IFBlcnNvbiA9IHR5cGVzLm1vZGVsKHtcbiAqICAgZmlyc3ROYW1lOiB0eXBlcy5zdHJpbmcsXG4gKiAgIGxhc3ROYW1lOiBcIkRvZVwiXG4gKiB9KVxuICogYGBgXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lXG52YXIgc3RyaW5nID0gbmV3IENvcmVUeXBlKFwic3RyaW5nXCIsIFR5cGVGbGFncy5TdHJpbmcsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjsgfSk7XG4vKipcbiAqIGB0eXBlcy5udW1iZXJgIC0gQ3JlYXRlcyBhIHR5cGUgdGhhdCBjYW4gb25seSBjb250YWluIGEgbnVtZXJpYyB2YWx1ZS5cbiAqIFRoaXMgdHlwZSBpcyB1c2VkIGZvciBudW1lcmljIHZhbHVlcyBieSBkZWZhdWx0XG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBWZWN0b3IgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHg6IHR5cGVzLm51bWJlcixcbiAqICAgeTogMS41XG4gKiB9KVxuICogYGBgXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lXG52YXIgbnVtYmVyID0gbmV3IENvcmVUeXBlKFwibnVtYmVyXCIsIFR5cGVGbGFncy5OdW1iZXIsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIjsgfSk7XG4vKipcbiAqIGB0eXBlcy5pbnRlZ2VyYCAtIENyZWF0ZXMgYSB0eXBlIHRoYXQgY2FuIG9ubHkgY29udGFpbiBhbiBpbnRlZ2VyIHZhbHVlLlxuICogVGhpcyB0eXBlIGlzIHVzZWQgZm9yIGludGVnZXIgdmFsdWVzIGJ5IGRlZmF1bHRcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IFNpemUgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHdpZHRoOiB0eXBlcy5pbnRlZ2VyLFxuICogICBoZWlnaHQ6IDEwXG4gKiB9KVxuICogYGBgXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lXG52YXIgaW50ZWdlciA9IG5ldyBDb3JlVHlwZShcImludGVnZXJcIiwgVHlwZUZsYWdzLkludGVnZXIsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBpc0ludGVnZXIodik7IH0pO1xuLyoqXG4gKiBgdHlwZXMuYm9vbGVhbmAgLSBDcmVhdGVzIGEgdHlwZSB0aGF0IGNhbiBvbmx5IGNvbnRhaW4gYSBib29sZWFuIHZhbHVlLlxuICogVGhpcyB0eXBlIGlzIHVzZWQgZm9yIGJvb2xlYW4gdmFsdWVzIGJ5IGRlZmF1bHRcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IFRoaW5nID0gdHlwZXMubW9kZWwoe1xuICogICBpc0Nvb2w6IHR5cGVzLmJvb2xlYW4sXG4gKiAgIGlzQXdlc29tZTogZmFsc2VcbiAqIH0pXG4gKiBgYGBcbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcbnZhciBib29sZWFuID0gbmV3IENvcmVUeXBlKFwiYm9vbGVhblwiLCBUeXBlRmxhZ3MuQm9vbGVhbiwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIjsgfSk7XG4vKipcbiAqIGB0eXBlcy5udWxsYCAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBgbnVsbGBcbiAqL1xudmFyIG51bGxUeXBlID0gbmV3IENvcmVUeXBlKFwibnVsbFwiLCBUeXBlRmxhZ3MuTnVsbCwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgPT09IG51bGw7IH0pO1xuLyoqXG4gKiBgdHlwZXMudW5kZWZpbmVkYCAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYFxuICovXG52YXIgdW5kZWZpbmVkVHlwZSA9IG5ldyBDb3JlVHlwZShcInVuZGVmaW5lZFwiLCBUeXBlRmxhZ3MuVW5kZWZpbmVkLCBmdW5jdGlvbiAodikgeyByZXR1cm4gdiA9PT0gdW5kZWZpbmVkOyB9KTtcbnZhciBfRGF0ZVByaW1pdGl2ZSA9IG5ldyBDb3JlVHlwZShcIkRhdGVcIiwgVHlwZUZsYWdzLkRhdGUsIGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiB8fCB2IGluc3RhbmNlb2YgRGF0ZTsgfSwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2IGluc3RhbmNlb2YgRGF0ZSA/IHYgOiBuZXcgRGF0ZSh2KSk7IH0pO1xuX0RhdGVQcmltaXRpdmUuZ2V0U25hcHNob3QgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLnN0b3JlZFZhbHVlLmdldFRpbWUoKTtcbn07XG4vKipcbiAqIGB0eXBlcy5EYXRlYCAtIENyZWF0ZXMgYSB0eXBlIHRoYXQgY2FuIG9ubHkgY29udGFpbiBhIGphdmFzY3JpcHQgRGF0ZSB2YWx1ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IExvZ0xpbmUgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIHRpbWVzdGFtcDogdHlwZXMuRGF0ZSxcbiAqIH0pXG4gKlxuICogTG9nTGluZS5jcmVhdGUoeyB0aW1lc3RhbXA6IG5ldyBEYXRlKCkgfSlcbiAqIGBgYFxuICovXG52YXIgRGF0ZVByaW1pdGl2ZSA9IF9EYXRlUHJpbWl0aXZlO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJpbWl0aXZlRmFjdG9yeUZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBudW1iZXI7IC8vIEluIHRoZSBmdXR1cmUsIGlzSW50ZWdlcih2YWx1ZSkgPyBpbnRlZ2VyIDogbnVtYmVyIHdvdWxkIGJlIGludGVyZXN0aW5nLCBidXQgd291bGQgYmUgdG9vIGJyZWFraW5nIGZvciBub3dcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBib29sZWFuO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICAgICAgICAgIHJldHVybiBEYXRlUHJpbWl0aXZlO1xuICAgIH1cbiAgICB0aHJvdyBmYWlsJDEoXCJDYW5ub3QgZGV0ZXJtaW5lIHByaW1pdGl2ZSB0eXBlIGZyb20gdmFsdWUgXCIgKyB2YWx1ZSk7XG59XG4vKipcbiAqIFJldHVybnMgaWYgYSBnaXZlbiB2YWx1ZSByZXByZXNlbnRzIGEgcHJpbWl0aXZlIHR5cGUuXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIChpc1R5cGUodHlwZSkgJiZcbiAgICAgICAgKHR5cGUuZmxhZ3MgJlxuICAgICAgICAgICAgKFR5cGVGbGFncy5TdHJpbmcgfFxuICAgICAgICAgICAgICAgIFR5cGVGbGFncy5OdW1iZXIgfFxuICAgICAgICAgICAgICAgIFR5cGVGbGFncy5JbnRlZ2VyIHxcbiAgICAgICAgICAgICAgICBUeXBlRmxhZ3MuQm9vbGVhbiB8XG4gICAgICAgICAgICAgICAgVHlwZUZsYWdzLkRhdGUpKSA+XG4gICAgICAgICAgICAwKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIExpdGVyYWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpdGVyYWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZmxhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFR5cGVGbGFncy5MaXRlcmFsXG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXRlcmFsLnByb3RvdHlwZSwgXCJpbnN0YW50aWF0ZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNjYWxhck5vZGUodGhpcywgcGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaXRlcmFsLnByb3RvdHlwZSwgXCJkZXNjcmliZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpdGVyYWwucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUodmFsdWUpICYmIHZhbHVlID09PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVDaGVja1N1Y2Nlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHZhbHVlLCBcIlZhbHVlIGlzIG5vdCBhIGxpdGVyYWwgXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gTGl0ZXJhbDtcbn0oU2ltcGxlVHlwZSkpO1xuLyoqXG4gKiBgdHlwZXMubGl0ZXJhbGAgLSBUaGUgbGl0ZXJhbCB0eXBlIHdpbGwgcmV0dXJuIGEgdHlwZSB0aGF0IHdpbGwgbWF0Y2ggb25seSB0aGUgZXhhY3QgZ2l2ZW4gdHlwZS5cbiAqIFRoZSBnaXZlbiB2YWx1ZSBtdXN0IGJlIGEgcHJpbWl0aXZlLCBpbiBvcmRlciB0byBiZSBzZXJpYWxpemVkIHRvIGEgc25hcHNob3QgY29ycmVjdGx5LlxuICogWW91IGNhbiB1c2UgbGl0ZXJhbCB0byBtYXRjaCBleGFjdCBzdHJpbmdzIGZvciBleGFtcGxlIHRoZSBleGFjdCBtYWxlIG9yIGZlbWFsZSBzdHJpbmcuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBQZXJzb24gPSB0eXBlcy5tb2RlbCh7XG4gKiAgICAgbmFtZTogdHlwZXMuc3RyaW5nLFxuICogICAgIGdlbmRlcjogdHlwZXMudW5pb24odHlwZXMubGl0ZXJhbCgnbWFsZScpLCB0eXBlcy5saXRlcmFsKCdmZW1hbGUnKSlcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHVzZSBpbiB0aGUgc3RyaWN0IGVxdWFsIGNoZWNrXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBsaXRlcmFsKHZhbHVlKSB7XG4gICAgLy8gY2hlY2sgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwcmltaXRpdmVcbiAgICBhc3NlcnRBcmcodmFsdWUsIGlzUHJpbWl0aXZlLCBcInByaW1pdGl2ZVwiLCAxKTtcbiAgICByZXR1cm4gbmV3IExpdGVyYWwodmFsdWUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIGEgZ2l2ZW4gdmFsdWUgcmVwcmVzZW50cyBhIGxpdGVyYWwgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaXNMaXRlcmFsVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIGlzVHlwZSh0eXBlKSAmJiAodHlwZS5mbGFncyAmIFR5cGVGbGFncy5MaXRlcmFsKSA+IDA7XG59XG5cbnZhciBSZWZpbmVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZpbmVtZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZmluZW1lbnQobmFtZSwgX3N1YnR5cGUsIF9wcmVkaWNhdGUsIF9tZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfc3VidHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogX3N1YnR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfcHJlZGljYXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBfcHJlZGljYXRlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX21lc3NhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IF9tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZpbmVtZW50LnByb3RvdHlwZSwgXCJmbGFnc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGUuZmxhZ3MgfCBUeXBlRmxhZ3MuUmVmaW5lbWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZpbmVtZW50LnByb3RvdHlwZSwgXCJkZXNjcmliZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZpbmVtZW50LnByb3RvdHlwZSwgXCJpbnN0YW50aWF0ZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBjaGlsZCB0eXBlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS5pbnN0YW50aWF0ZShwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmluZW1lbnQucHJvdG90eXBlLCBcImlzQXNzaWduYWJsZUZyb21cIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS5pc0Fzc2lnbmFibGVGcm9tKHR5cGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmluZW1lbnQucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgc3VidHlwZUVycm9ycyA9IHRoaXMuX3N1YnR5cGUudmFsaWRhdGUodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHN1YnR5cGVFcnJvcnMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZUVycm9ycztcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IGlzU3RhdGVUcmVlTm9kZSh2YWx1ZSkgPyBnZXRTdGF0ZVRyZWVOb2RlKHZhbHVlKS5zbmFwc2hvdCA6IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcmVkaWNhdGUoc25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVDaGVja0ZhaWx1cmUoY29udGV4dCwgdmFsdWUsIHRoaXMuX21lc3NhZ2UodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlQ2hlY2tTdWNjZXNzKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmaW5lbWVudC5wcm90b3R5cGUsIFwicmVjb25jaWxlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGUucmVjb25jaWxlKGN1cnJlbnQsIG5ld1ZhbHVlLCBwYXJlbnQsIHN1YnBhdGgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmluZW1lbnQucHJvdG90eXBlLCBcImdldFN1YlR5cGVzXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VidHlwZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBSZWZpbmVtZW50O1xufShCYXNlVHlwZSkpO1xuLyoqXG4gKiBgdHlwZXMucmVmaW5lbWVudGAgLSBDcmVhdGVzIGEgdHlwZSB0aGF0IGlzIG1vcmUgc3BlY2lmaWMgdGhhbiB0aGUgYmFzZSB0eXBlLCBlLmcuIGB0eXBlcy5yZWZpbmVtZW50KHR5cGVzLnN0cmluZywgdmFsdWUgPT4gdmFsdWUubGVuZ3RoID4gNSlgIHRvIGNyZWF0ZSBhIHR5cGUgb2Ygc3RyaW5ncyB0aGF0IGNhbiBvbmx5IGJlIGxvbmdlciB0aGVuIDUuXG4gKlxuICogQHBhcmFtIG5hbWVcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gcHJlZGljYXRlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiByZWZpbmVtZW50KCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiID8gYXJncy5zaGlmdCgpIDogaXNUeXBlKGFyZ3NbMF0pID8gYXJnc1swXS5uYW1lIDogbnVsbDtcbiAgICB2YXIgdHlwZSA9IGFyZ3NbMF07XG4gICAgdmFyIHByZWRpY2F0ZSA9IGFyZ3NbMV07XG4gICAgdmFyIG1lc3NhZ2UgPSBhcmdzWzJdXG4gICAgICAgID8gYXJnc1syXVxuICAgICAgICA6IGZ1bmN0aW9uICh2KSB7IHJldHVybiBcIlZhbHVlIGRvZXMgbm90IHJlc3BlY3QgdGhlIHJlZmluZW1lbnQgcHJlZGljYXRlXCI7IH07XG4gICAgLy8gZW5zdXJlcyBhbGwgcGFyYW1ldGVycyBhcmUgY29ycmVjdFxuICAgIGFzc2VydElzVHlwZSh0eXBlLCBbMSwgMl0pO1xuICAgIGFzc2VydElzU3RyaW5nKG5hbWUsIDEpO1xuICAgIGFzc2VydElzRnVuY3Rpb24ocHJlZGljYXRlLCBbMiwgM10pO1xuICAgIGFzc2VydElzRnVuY3Rpb24obWVzc2FnZSwgWzMsIDRdKTtcbiAgICByZXR1cm4gbmV3IFJlZmluZW1lbnQobmFtZSwgdHlwZSwgcHJlZGljYXRlLCBtZXNzYWdlKTtcbn1cbi8qKlxuICogUmV0dXJucyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgcmVmaW5lbWVudCB0eXBlLlxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc1JlZmluZW1lbnRUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gKHR5cGUuZmxhZ3MgJiBUeXBlRmxhZ3MuUmVmaW5lbWVudCkgPiAwO1xufVxuXG4vKipcbiAqIGB0eXBlcy5lbnVtZXJhdGlvbmAgLSBDYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gc3RyaW5nIGJhc2VkIGVudW1lcmF0aW9uLlxuICogKG5vdGU6IHRoaXMgbWV0aG9kcyBpcyBqdXN0IHN1Z2FyIGZvciBhIHVuaW9uIG9mIHN0cmluZyBsaXRlcmFscylcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IFRyYWZmaWNMaWdodCA9IHR5cGVzLm1vZGVsKHtcbiAqICAgY29sb3I6IHR5cGVzLmVudW1lcmF0aW9uKFwiQ29sb3JcIiwgW1wiUmVkXCIsIFwiT3JhbmdlXCIsIFwiR3JlZW5cIl0pXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgZGVzY3JpcHRpdmUgbmFtZSBvZiB0aGUgZW51bWVyYXRpb24gKG9wdGlvbmFsKVxuICogQHBhcmFtIG9wdGlvbnMgcG9zc2libGUgdmFsdWVzIHRoaXMgZW51bWVyYXRpb24gY2FuIGhhdmVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGVudW1lcmF0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVhbE9wdGlvbnMgPSB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMgOiBuYW1lO1xuICAgIC8vIGNoZWNrIGFsbCBvcHRpb25zXG4gICAgaWYgKGRldk1vZGUoKSkge1xuICAgICAgICByZWFsT3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb24sIGkpIHtcbiAgICAgICAgICAgIGFzc2VydElzU3RyaW5nKG9wdGlvbiwgaSArIDEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSB1bmlvbi5hcHBseSh2b2lkIDAsIF9fc3ByZWFkKHJlYWxPcHRpb25zLm1hcChmdW5jdGlvbiAob3B0aW9uKSB7IHJldHVybiBsaXRlcmFsKFwiXCIgKyBvcHRpb24pOyB9KSkpO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgdHlwZS5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdHlwZTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIFVuaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbmlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbmlvbihuYW1lLCBfdHlwZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl90eXBlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogX3R5cGVzXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX2Rpc3BhdGNoZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIl9lYWdlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgb3B0aW9ucyA9IF9fYXNzaWduKHsgZWFnZXI6IHRydWUsIGRpc3BhdGNoZXI6IHVuZGVmaW5lZCB9LCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMuX2Rpc3BhdGNoZXIgPSBvcHRpb25zLmRpc3BhdGNoZXI7XG4gICAgICAgIGlmICghb3B0aW9ucy5lYWdlcilcbiAgICAgICAgICAgIF90aGlzLl9lYWdlciA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmlvbi5wcm90b3R5cGUsIFwiZmxhZ3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBUeXBlRmxhZ3MuVW5pb247XG4gICAgICAgICAgICB0aGlzLl90eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IHR5cGUuZmxhZ3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5pb24ucHJvdG90eXBlLCBcImlzQXNzaWduYWJsZUZyb21cIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZXMuc29tZShmdW5jdGlvbiAoc3ViVHlwZSkgeyByZXR1cm4gc3ViVHlwZS5pc0Fzc2lnbmFibGVGcm9tKHR5cGUpOyB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmlvbi5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIihcIiArIHRoaXMuX3R5cGVzLm1hcChmdW5jdGlvbiAoZmFjdG9yeSkgeyByZXR1cm4gZmFjdG9yeS5kZXNjcmliZSgpOyB9KS5qb2luKFwiIHwgXCIpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5pb24ucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZGV0ZXJtaW5lVHlwZShpbml0aWFsVmFsdWUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiTm8gbWF0Y2hpbmcgdHlwZSBmb3IgdW5pb24gXCIgKyB0aGlzLmRlc2NyaWJlKCkpOyAvLyBjYW4gaGFwcGVuIGluIHByb2QgYnVpbGRzXG4gICAgICAgICAgICByZXR1cm4gdHlwZS5pbnN0YW50aWF0ZShwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVuaW9uLnByb3RvdHlwZSwgXCJyZWNvbmNpbGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjdXJyZW50LCBuZXdWYWx1ZSwgcGFyZW50LCBzdWJwYXRoKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuZGV0ZXJtaW5lVHlwZShuZXdWYWx1ZSwgY3VycmVudC5nZXRSZWNvbmNpbGlhdGlvblR5cGUoKSk7XG4gICAgICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiTm8gbWF0Y2hpbmcgdHlwZSBmb3IgdW5pb24gXCIgKyB0aGlzLmRlc2NyaWJlKCkpOyAvLyBjYW4gaGFwcGVuIGluIHByb2QgYnVpbGRzXG4gICAgICAgICAgICByZXR1cm4gdHlwZS5yZWNvbmNpbGUoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVW5pb24ucHJvdG90eXBlLCBcImRldGVybWluZVR5cGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgcmVjb25jaWxlQ3VycmVudFR5cGUpIHtcbiAgICAgICAgICAgIC8vIHRyeSB0aGUgZGlzcGF0Y2hlciwgaWYgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3BhdGNoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hlcih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBtb3N0IGFjY29tb2RhdGluZyB0eXBlXG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgdXNpbmcgcmVjb25jaWxpYXRpb24gdHJ5IHRoZSBjdXJyZW50IG5vZGUgdHlwZSBmaXJzdCAoZml4IGZvciAjMTA0NSlcbiAgICAgICAgICAgIGlmIChyZWNvbmNpbGVDdXJyZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZWNvbmNpbGVDdXJyZW50VHlwZS5pcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY29uY2lsZUN1cnJlbnRUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZXNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAhPT0gcmVjb25jaWxlQ3VycmVudFR5cGU7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKGZ1bmN0aW9uICh0eXBlKSB7IHJldHVybiB0eXBlLmlzKHZhbHVlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdHlwZXMuZmluZChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS5pcyh2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVuaW9uLnByb3RvdHlwZSwgXCJpc1ZhbGlkU25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3BhdGNoZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hlcih2YWx1ZSkudmFsaWRhdGUodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFsbEVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFwcGxpY2FibGVUeXBlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3R5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gdHlwZS52YWxpZGF0ZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VhZ2VyKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVDaGVja1N1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZVR5cGVzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbGxFcnJvcnMucHVzaChlcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcHBsaWNhYmxlVHlwZXMgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVDaGVja1N1Y2Nlc3MoKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHZhbHVlLCBcIk5vIHR5cGUgaXMgYXBwbGljYWJsZSBmb3IgdGhlIHVuaW9uXCIpLmNvbmNhdChmbGF0dGVuVHlwZUVycm9ycyhhbGxFcnJvcnMpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVbmlvbi5wcm90b3R5cGUsIFwiZ2V0U3ViVHlwZXNcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90eXBlcztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBVbmlvbjtcbn0oQmFzZVR5cGUpKTtcbi8qKlxuICogYHR5cGVzLnVuaW9uYCAtIENyZWF0ZSBhIHVuaW9uIG9mIG11bHRpcGxlIHR5cGVzLiBJZiB0aGUgY29ycmVjdCB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCB1bmFtYmlndW91c2x5IGZyb20gYSBzbmFwc2hvdCwgcHJvdmlkZSBhIGRpc3BhdGNoZXIgZnVuY3Rpb24gb2YgdGhlIGZvcm0gYChzbmFwc2hvdCkgPT4gVHlwZWAuXG4gKlxuICogQHBhcmFtIG9wdGlvbnNPclR5cGVcbiAqIEBwYXJhbSBvdGhlclR5cGVzXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB1bmlvbihvcHRpb25zT3JUeXBlKSB7XG4gICAgdmFyIG90aGVyVHlwZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvdGhlclR5cGVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IGlzVHlwZShvcHRpb25zT3JUeXBlKSA/IHVuZGVmaW5lZCA6IG9wdGlvbnNPclR5cGU7XG4gICAgdmFyIHR5cGVzID0gaXNUeXBlKG9wdGlvbnNPclR5cGUpID8gX19zcHJlYWQoW29wdGlvbnNPclR5cGVdLCBvdGhlclR5cGVzKSA6IG90aGVyVHlwZXM7XG4gICAgdmFyIG5hbWUgPSBcIihcIiArIHR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS5uYW1lOyB9KS5qb2luKFwiIHwgXCIpICsgXCIpXCI7XG4gICAgLy8gY2hlY2sgYWxsIG9wdGlvbnNcbiAgICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmcob3B0aW9ucywgZnVuY3Rpb24gKG8pIHsgcmV0dXJuIGlzUGxhaW5PYmplY3Qobyk7IH0sIFwib2JqZWN0IHsgZWFnZXI/OiBib29sZWFuLCBkaXNwYXRjaGVyPzogRnVuY3Rpb24gfVwiLCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpKSB7XG4gICAgICAgICAgICBhc3NlcnRJc1R5cGUodHlwZSwgb3B0aW9ucyA/IGkgKyAyIDogaSArIDEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVbmlvbihuYW1lLCB0eXBlcywgb3B0aW9ucyk7XG59XG4vKipcbiAqIFJldHVybnMgaWYgYSBnaXZlbiB2YWx1ZSByZXByZXNlbnRzIGEgdW5pb24gdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaXNVbmlvblR5cGUodHlwZSkge1xuICAgIHJldHVybiAodHlwZS5mbGFncyAmIFR5cGVGbGFncy5VbmlvbikgPiAwO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEBpbnRlcm5hbFxuICovXG52YXIgT3B0aW9uYWxWYWx1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3B0aW9uYWxWYWx1ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPcHRpb25hbFZhbHVlKF9zdWJ0eXBlLCBfZGVmYXVsdFZhbHVlLCBvcHRpb25hbFZhbHVlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBfc3VidHlwZS5uYW1lKSB8fCB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX3N1YnR5cGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IF9zdWJ0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiX2RlZmF1bHRWYWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogX2RlZmF1bHRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIm9wdGlvbmFsVmFsdWVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb25hbFZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3B0aW9uYWxWYWx1ZS5wcm90b3R5cGUsIFwiZmxhZ3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlLmZsYWdzIHwgVHlwZUZsYWdzLk9wdGlvbmFsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9wdGlvbmFsVmFsdWUucHJvdG90eXBlLCBcImRlc2NyaWJlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS5kZXNjcmliZSgpICsgXCI/XCI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3B0aW9uYWxWYWx1ZS5wcm90b3R5cGUsIFwiaW5zdGFudGlhdGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbmFsVmFsdWVzLmluZGV4T2YoaW5pdGlhbFZhbHVlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRJbnN0YW5jZU9yU25hcHNob3QgPSB0aGlzLmdldERlZmF1bHRJbnN0YW5jZU9yU25hcHNob3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3VidHlwZS5pbnN0YW50aWF0ZShwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBkZWZhdWx0SW5zdGFuY2VPclNuYXBzaG90KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlLmluc3RhbnRpYXRlKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3B0aW9uYWxWYWx1ZS5wcm90b3R5cGUsIFwicmVjb25jaWxlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGUucmVjb25jaWxlKGN1cnJlbnQsIHRoaXMub3B0aW9uYWxWYWx1ZXMuaW5kZXhPZihuZXdWYWx1ZSkgPCAwICYmIHRoaXMuX3N1YnR5cGUuaXMobmV3VmFsdWUpXG4gICAgICAgICAgICAgICAgPyBuZXdWYWx1ZVxuICAgICAgICAgICAgICAgIDogdGhpcy5nZXREZWZhdWx0SW5zdGFuY2VPclNuYXBzaG90KCksIHBhcmVudCwgc3VicGF0aCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3B0aW9uYWxWYWx1ZS5wcm90b3R5cGUsIFwiZ2V0RGVmYXVsdEluc3RhbmNlT3JTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRJbnN0YW5jZU9yU25hcHNob3QgPSB0eXBlb2YgdGhpcy5fZGVmYXVsdFZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2RlZmF1bHRWYWx1ZSgpXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAvLyB3aGlsZSBzdGF0aWMgdmFsdWVzIGFyZSBhbHJlYWR5IHNuYXBzaG90cyBhbmQgY2hlY2tlZCBvbiB0eXBlcy5vcHRpb25hbFxuICAgICAgICAgICAgLy8gZ2VuZXJhdG9yIGZ1bmN0aW9ucyBtdXN0IGFsd2F5cyBiZSByZWNoZWNrZWQganVzdCBpbiBjYXNlXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2RlZmF1bHRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdHlwZWNoZWNrSW50ZXJuYWwodGhpcywgZGVmYXVsdEluc3RhbmNlT3JTbmFwc2hvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEluc3RhbmNlT3JTbmFwc2hvdDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcHRpb25hbFZhbHVlLnByb3RvdHlwZSwgXCJpc1ZhbGlkU25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgLy8gZGVmYXVsdGVkIHZhbHVlcyBjYW4gYmUgc2tpcHBlZFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlQ2hlY2tTdWNjZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBib3VuY2UgdmFsaWRhdGlvbiB0byB0aGUgc3ViLXR5cGVcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJ0eXBlLnZhbGlkYXRlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcHRpb25hbFZhbHVlLnByb3RvdHlwZSwgXCJpc0Fzc2lnbmFibGVGcm9tXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGUuaXNBc3NpZ25hYmxlRnJvbSh0eXBlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPcHRpb25hbFZhbHVlLnByb3RvdHlwZSwgXCJnZXRTdWJUeXBlc1wiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnR5cGU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gT3B0aW9uYWxWYWx1ZTtcbn0oQmFzZVR5cGUpKTtcbmZ1bmN0aW9uIGNoZWNrT3B0aW9uYWxQcmVjb25kaXRpb25zKHR5cGUsIGRlZmF1bHRWYWx1ZU9yRnVuY3Rpb24pIHtcbiAgICAvLyBtYWtlIHN1cmUgd2UgbmV2ZXIgcGFzcyBkaXJlY3QgaW5zdGFuY2VzXG4gICAgaWYgKHR5cGVvZiBkZWZhdWx0VmFsdWVPckZ1bmN0aW9uICE9PSBcImZ1bmN0aW9uXCIgJiYgaXNTdGF0ZVRyZWVOb2RlKGRlZmF1bHRWYWx1ZU9yRnVuY3Rpb24pKSB7XG4gICAgICAgIHRocm93IGZhaWwkMShcImRlZmF1bHQgdmFsdWUgY2Fubm90IGJlIGFuIGluc3RhbmNlLCBwYXNzIGEgc25hcHNob3Qgb3IgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gaW5zdGFuY2Uvc25hcHNob3QgaW5zdGVhZFwiKTtcbiAgICB9XG4gICAgYXNzZXJ0SXNUeXBlKHR5cGUsIDEpO1xuICAgIGlmIChkZXZNb2RlKCkpIHtcbiAgICAgICAgLy8gd2Ugb25seSBjaGVjayBkZWZhdWx0IHZhbHVlcyBpZiB0aGV5IGFyZSBwYXNzZWQgZGlyZWN0bHlcbiAgICAgICAgLy8gaWYgdGhleSBhcmUgZ2VuZXJhdG9yIGZ1bmN0aW9ucyB0aGV5IHdpbGwgYmUgY2hlY2tlZCBvbmNlIHRoZXkgYXJlIGdlbmVyYXRlZFxuICAgICAgICAvLyB3ZSBkb24ndCBjaGVjayBnZW5lcmF0b3IgZnVuY3Rpb24gcmVzdWx0cyBoZXJlIHRvIGF2b2lkIGdlbmVyYXRpbmcgYSBub2RlIGp1c3QgZm9yIHR5cGUtY2hlY2tpbmcgcHVycG9zZXNcbiAgICAgICAgLy8gd2hpY2ggbWlnaHQgZ2VuZXJhdGUgc2lkZS1lZmZlY3RzXG4gICAgICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlT3JGdW5jdGlvbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0eXBlY2hlY2tJbnRlcm5hbCh0eXBlLCBkZWZhdWx0VmFsdWVPckZ1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogYHR5cGVzLm9wdGlvbmFsYCAtIENhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIHByb3BlcnR5IHdpdGggYSBkZWZhdWx0IHZhbHVlLlxuICpcbiAqIERlcGVuZGluZyBvbiB0aGUgdGhpcmQgYXJndW1lbnQgKGBvcHRpb25hbFZhbHVlc2ApIHRoZXJlIGFyZSB0d28gd2F5cyBvZiBvcGVyYXRpb246XG4gKiAtIElmIHRoZSBhcmd1bWVudCBpcyBub3QgcHJvdmlkZWQsIHRoZW4gaWYgYSB2YWx1ZSBpcyBub3QgcHJvdmlkZWQgaW4gdGhlIHNuYXBzaG90IChgdW5kZWZpbmVkYCBvciBtaXNzaW5nKSxcbiAqICAgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBwcm92aWRlZCBgZGVmYXVsdFZhbHVlYFxuICogLSBJZiB0aGUgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZW4gaWYgdGhlIHZhbHVlIGluIHRoZSBzbmFwc2hvdCBtYXRjaGVzIG9uZSBvZiB0aGUgb3B0aW9uYWwgdmFsdWVzIGluc2lkZSB0aGUgYXJyYXkgdGhlbiBpdCB3aWxsXG4gKiAgIGRlZmF1bHQgdG8gdGhlIHByb3ZpZGVkIGBkZWZhdWx0VmFsdWVgLiBBZGRpdGlvbmFsbHksIGlmIG9uZSBvZiB0aGUgb3B0aW9uYWwgdmFsdWVzIGluc2lkZSB0aGUgYXJyYXkgaXMgYHVuZGVmaW5lZGAgdGhlbiBhIG1pc3NpbmdcbiAqICAgcHJvcGVydHkgaXMgYWxzbyB2YWxpZC5cbiAqXG4gKiAgIE5vdGUgdGhhdCBpdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGluY2x1ZGUgdmFsdWVzIG9mIHRoZSBzYW1lIHR5cGUgYXMgdGhlIGludGVuZGVkIHN1YnR5cGUgYXMgb3B0aW9uYWwgdmFsdWVzLFxuICogICBpbiB0aGlzIGNhc2UgdGhlIG9wdGlvbmFsIHZhbHVlIHdpbGwgYmUgdHJhbnNmb3JtZWQgaW50byB0aGUgYGRlZmF1bHRWYWx1ZWAgKGUuZy4gYHR5cGVzLm9wdGlvbmFsKHR5cGVzLnN0cmluZywgXCJ1bm5hbWVkXCIsIFt1bmRlZmluZWQsIFwiXCJdKWBcbiAqICAgd2lsbCB0cmFuc2Zvcm0gdGhlIHNuYXBzaG90IHZhbHVlcyBgdW5kZWZpbmVkYCAoYW5kIHRoZXJlZm9yZSBtaXNzaW5nKSBhbmQgZW1wdHkgc3RyaW5ncyBpbnRvIHRoZSBzdHJpbmcgYFwidW5uYW1lZFwiYCB3aGVuIGl0IGdldHNcbiAqICAgaW5zdGFudGlhdGVkKS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGZvciBldmVyeSBuZXcgaW5zdGFuY2UuXG4gKiBBcHBseWluZyBhIHNuYXBzaG90IGluIHdoaWNoIHRoZSBvcHRpb25hbCB2YWx1ZSBpcyBvbmUgb2YgdGhlIG9wdGlvbmFsIHZhbHVlcyAob3IgYHVuZGVmaW5lZGAvX25vdF8gcHJlc2VudCBpZiBub25lIGFyZSBwcm92aWRlZCkgY2F1c2VzIHRoZVxuICogdmFsdWUgdG8gYmUgcmVzZXQuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBUb2RvID0gdHlwZXMubW9kZWwoe1xuICogICB0aXRsZTogdHlwZXMuc3RyaW5nLFxuICogICBzdWJ0aXRsZTE6IHR5cGVzLm9wdGlvbmFsKHR5cGVzLnN0cmluZywgXCJcIiwgW251bGxdKSxcbiAqICAgc3VidGl0bGUyOiB0eXBlcy5vcHRpb25hbCh0eXBlcy5zdHJpbmcsIFwiXCIsIFtudWxsLCB1bmRlZmluZWRdKSxcbiAqICAgZG9uZTogdHlwZXMub3B0aW9uYWwodHlwZXMuYm9vbGVhbiwgZmFsc2UpLFxuICogICBjcmVhdGVkOiB0eXBlcy5vcHRpb25hbCh0eXBlcy5EYXRlLCAoKSA9PiBuZXcgRGF0ZSgpKSxcbiAqIH0pXG4gKlxuICogLy8gaWYgZG9uZSBpcyBtaXNzaW5nIC8gdW5kZWZpbmVkIGl0IHdpbGwgYmVjb21lIGZhbHNlXG4gKiAvLyBpZiBjcmVhdGVkIGlzIG1pc3NpbmcgLyB1bmRlZmluZWQgaXQgd2lsbCBnZXQgYSBmcmVzaGx5IGdlbmVyYXRlZCB0aW1lc3RhbXBcbiAqIC8vIGlmIHN1YnRpdGxlMSBpcyBudWxsIGl0IHdpbGwgZGVmYXVsdCB0byBcIlwiLCBidXQgaXQgY2Fubm90IGJlIG1pc3Npbmcgb3IgdW5kZWZpbmVkXG4gKiAvLyBpZiBzdWJ0aXRsZTIgaXMgbnVsbCBvciB1bmRlZmluZWQgaXQgd2lsbCBkZWZhdWx0IHRvIFwiXCI7IHNpbmNlIGl0IGNhbiBiZSB1bmRlZmluZWQgaXQgY2FuIGFsc28gYmUgbWlzc2luZ1xuICogY29uc3QgdG9kbyA9IFRvZG8uY3JlYXRlKHsgdGl0bGU6IFwiR2V0IGNvZmZlZVwiLCBzdWJ0aXRsZTE6IG51bGwgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlT3JGdW5jdGlvblxuICogQHBhcmFtIG9wdGlvbmFsVmFsdWVzIGFuIG9wdGlvbmFsIGFycmF5IHdpdGggemVybyBvciBtb3JlIHByaW1pdGl2ZSB2YWx1ZXMgKHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBudWxsIG9yIHVuZGVmaW5lZClcbiAqICAgICAgICAgICAgICAgICAgICAgICB0aGF0IHdpbGwgYmUgY29udmVydGVkIGludG8gdGhlIGRlZmF1bHQuIGBbIHVuZGVmaW5lZCBdYCBpcyBhc3N1bWVkIHdoZW4gbm9uZSBpcyBwcm92aWRlZFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gb3B0aW9uYWwodHlwZSwgZGVmYXVsdFZhbHVlT3JGdW5jdGlvbiwgb3B0aW9uYWxWYWx1ZXMpIHtcbiAgICBjaGVja09wdGlvbmFsUHJlY29uZGl0aW9ucyh0eXBlLCBkZWZhdWx0VmFsdWVPckZ1bmN0aW9uKTtcbiAgICByZXR1cm4gbmV3IE9wdGlvbmFsVmFsdWUodHlwZSwgZGVmYXVsdFZhbHVlT3JGdW5jdGlvbiwgb3B0aW9uYWxWYWx1ZXMgPyBvcHRpb25hbFZhbHVlcyA6IHVuZGVmaW5lZEFzT3B0aW9uYWxWYWx1ZXMpO1xufVxudmFyIHVuZGVmaW5lZEFzT3B0aW9uYWxWYWx1ZXMgPSBbdW5kZWZpbmVkXTtcbi8qKlxuICogUmV0dXJucyBpZiBhIHZhbHVlIHJlcHJlc2VudHMgYW4gb3B0aW9uYWwgdHlwZS5cbiAqXG4gKiBAdGVtcGxhdGUgSVRcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc09wdGlvbmFsVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIGlzVHlwZSh0eXBlKSAmJiAodHlwZS5mbGFncyAmIFR5cGVGbGFncy5PcHRpb25hbCkgPiAwO1xufVxuXG52YXIgb3B0aW9uYWxVbmRlZmluZWRUeXBlID0gb3B0aW9uYWwodW5kZWZpbmVkVHlwZSwgdW5kZWZpbmVkKTtcbnZhciBvcHRpb25hbE51bGxUeXBlID0gb3B0aW9uYWwobnVsbFR5cGUsIG51bGwpO1xuLyoqXG4gKiBgdHlwZXMubWF5YmVgIC0gTWF5YmUgd2lsbCBtYWtlIGEgdHlwZSBudWxsYWJsZSwgYW5kIGFsc28gb3B0aW9uYWwuXG4gKiBUaGUgdmFsdWUgYHVuZGVmaW5lZGAgd2lsbCBiZSB1c2VkIHRvIHJlcHJlc2VudCBudWxsYWJpbGl0eS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gbWF5YmUodHlwZSkge1xuICAgIGFzc2VydElzVHlwZSh0eXBlLCAxKTtcbiAgICByZXR1cm4gdW5pb24odHlwZSwgb3B0aW9uYWxVbmRlZmluZWRUeXBlKTtcbn1cbi8qKlxuICogYHR5cGVzLm1heWJlTnVsbGAgLSBNYXliZSB3aWxsIG1ha2UgYSB0eXBlIG51bGxhYmxlLCBhbmQgYWxzbyBvcHRpb25hbC5cbiAqIFRoZSB2YWx1ZSBgbnVsbGAgd2lsbCBiZSB1c2VkIHRvIHJlcHJlc2VudCBubyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gbWF5YmVOdWxsKHR5cGUpIHtcbiAgICBhc3NlcnRJc1R5cGUodHlwZSwgMSk7XG4gICAgcmV0dXJuIHVuaW9uKHR5cGUsIG9wdGlvbmFsTnVsbFR5cGUpO1xufVxuXG52YXIgTGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTGF0ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMYXRlKG5hbWUsIF9kZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfZGVmaW5pdGlvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogX2RlZmluaXRpb25cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfc3ViVHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXRlLnByb3RvdHlwZSwgXCJmbGFnc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9zdWJUeXBlID8gdGhpcy5fc3ViVHlwZS5mbGFncyA6IDApIHwgVHlwZUZsYWdzLkxhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF0ZS5wcm90b3R5cGUsIFwiZ2V0U3ViVHlwZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG11c3RTdWNjZWVkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N1YlR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy5fZGVmaW5pdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJlZmVyZW5jZUVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIGhhcHBlbiBpbiBzdHJpY3QgRVM1IGNvZGUgd2hlbiBhIGRlZmluaXRpb24gaXMgc2VsZiByZWZlcmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG11c3RTdWNjZWVkICYmIHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiTGF0ZSB0eXBlIHNlZW1zIHRvIGJlIHVzZWQgdG9vIGVhcmx5LCB0aGUgZGVmaW5pdGlvbiAoc3RpbGwpIHJldHVybnMgdW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXZNb2RlKCkgJiYgIWlzVHlwZSh0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcIkZhaWxlZCB0byBkZXRlcm1pbmUgc3VidHlwZSwgbWFrZSBzdXJlIHR5cGVzLmxhdGUgcmV0dXJucyBhIHR5cGUgZGVmaW5pdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YlR5cGUgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdWJUeXBlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExhdGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTdWJUeXBlKHRydWUpLmluc3RhbnRpYXRlKHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF0ZS5wcm90b3R5cGUsIFwicmVjb25jaWxlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3ViVHlwZSh0cnVlKS5yZWNvbmNpbGUoY3VycmVudCwgbmV3VmFsdWUsIHBhcmVudCwgc3VicGF0aCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGF0ZS5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0ID0gdGhpcy5nZXRTdWJUeXBlKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0ID8gdC5uYW1lIDogXCI8dWtub3duIGxhdGUgdHlwZT5cIjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMYXRlLnByb3RvdHlwZSwgXCJpc1ZhbGlkU25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmdldFN1YlR5cGUoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgICAgICAgLy8gU2VlICM5MTY7IHRoZSB2YXJpYWJsZSB0aGUgZGVmaW5pdGlvbiBjbG9zdXJlIGlzIHBvaW50aW5nIHRvIHdhc24ndCBkZWZpbmVkIHlldCwgc28gY2FuJ3QgYmUgZXZhbHV0ZWQgeWV0IGhlcmVcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZUNoZWNrU3VjY2VzcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHQudmFsaWRhdGUodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExhdGUucHJvdG90eXBlLCBcImlzQXNzaWduYWJsZUZyb21cIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuZ2V0U3ViVHlwZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gdCA/IHQuaXNBc3NpZ25hYmxlRnJvbSh0eXBlKSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExhdGUucHJvdG90eXBlLCBcImdldFN1YlR5cGVzXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3VidHlwZSA9IHRoaXMuZ2V0U3ViVHlwZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gc3VidHlwZSA/IHN1YnR5cGUgOiBjYW5ub3REZXRlcm1pbmVTdWJ0eXBlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIExhdGU7XG59KEJhc2VUeXBlKSk7XG4vKipcbiAqIGB0eXBlcy5sYXRlYCAtIERlZmluZXMgYSB0eXBlIHRoYXQgZ2V0cyBpbXBsZW1lbnRlZCBsYXRlci4gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3UgaGF2ZSB0byBkZWFsIHdpdGggY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICogUGxlYXNlIG5vdGljZSB0aGF0IHdoZW4gZGVmaW5pbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIFR5cGVTY3JpcHQgaXNuJ3Qgc21hcnQgZW5vdWdoIHRvIGluZmVyZW5jZSB0aGVtLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0c1xuICogICAvLyBUeXBlU2NyaXB0IGlzbid0IHNtYXJ0IGVub3VnaCB0byBpbmZlciBzZWxmIHJlZmVyZW5jaW5nIHR5cGVzLlxuICogIGNvbnN0IE5vZGUgPSB0eXBlcy5tb2RlbCh7XG4gKiAgICAgICBjaGlsZHJlbjogdHlwZXMuYXJyYXkodHlwZXMubGF0ZSgoKTogSUFueU1vZGVsVHlwZSA9PiBOb2RlKSkgLy8gdGhlbiB0eXBlY2FzdCBlYWNoIGFycmF5IGVsZW1lbnQgdG8gSW5zdGFuY2U8dHlwZW9mIE5vZGU+XG4gKiAgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRvIHVzZSBmb3IgdGhlIHR5cGUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICogQHBhcmFtIHR5cGUgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHR5cGUgdGhhdCB3aWxsIGJlIGRlZmluZWQuXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBsYXRlKG5hbWVPclR5cGUsIG1heWJlVHlwZSkge1xuICAgIHZhciBuYW1lID0gdHlwZW9mIG5hbWVPclR5cGUgPT09IFwic3RyaW5nXCIgPyBuYW1lT3JUeXBlIDogXCJsYXRlKFwiICsgbmFtZU9yVHlwZS50b1N0cmluZygpICsgXCIpXCI7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgbmFtZU9yVHlwZSA9PT0gXCJzdHJpbmdcIiA/IG1heWJlVHlwZSA6IG5hbWVPclR5cGU7XG4gICAgLy8gY2hlY2tzIHRoYXQgdGhlIHR5cGUgaXMgYWN0dWFsbHkgYSBsYXRlIHR5cGVcbiAgICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgICAgIGlmICghKHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZS5sZW5ndGggPT09IDApKVxuICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiSW52YWxpZCBsYXRlIHR5cGUsIGV4cGVjdGVkIGEgZnVuY3Rpb24gd2l0aCB6ZXJvIGFyZ3VtZW50cyB0aGF0IHJldHVybnMgYSB0eXBlLCBnb3Q6IFwiICtcbiAgICAgICAgICAgICAgICB0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMYXRlKG5hbWUsIHR5cGUpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIGEgZ2l2ZW4gdmFsdWUgcmVwcmVzZW50cyBhIGxhdGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0gdHlwZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaXNMYXRlVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIGlzVHlwZSh0eXBlKSAmJiAodHlwZS5mbGFncyAmIFR5cGVGbGFncy5MYXRlKSA+IDA7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBGcm96ZW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZyb3plbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGcm96ZW4oc3ViVHlwZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzdWJUeXBlID8gXCJmcm96ZW4oXCIgKyBzdWJUeXBlLm5hbWUgKyBcIilcIiA6IFwiZnJvemVuXCIpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzdWJUeXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBzdWJUeXBlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZmxhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFR5cGVGbGFncy5Gcm96ZW5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyb3plbi5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjxhbnkgaW1tdXRhYmxlIHZhbHVlPlwiO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZyb3plbi5wcm90b3R5cGUsIFwiaW5zdGFudGlhdGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBub2RlXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlU2NhbGFyTm9kZSh0aGlzLCBwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBkZWVwRnJlZXplKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnJvemVuLnByb3RvdHlwZSwgXCJpc1ZhbGlkU25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKCFpc1NlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZUNoZWNrRmFpbHVyZShjb250ZXh0LCB2YWx1ZSwgXCJWYWx1ZSBpcyBub3Qgc2VyaWFsaXphYmxlIGFuZCBjYW5ub3QgYmUgZnJvemVuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3ViVHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJUeXBlLnZhbGlkYXRlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlQ2hlY2tTdWNjZXNzKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gRnJvemVuO1xufShTaW1wbGVUeXBlKSk7XG52YXIgdW50eXBlZEZyb3plbkluc3RhbmNlID0gbmV3IEZyb3plbigpO1xuLyoqXG4gKiBgdHlwZXMuZnJvemVuYCAtIEZyb3plbiBjYW4gYmUgdXNlZCB0byBzdG9yZSBhbnkgdmFsdWUgdGhhdCBpcyBzZXJpYWxpemFibGUgaW4gaXRzZWxmICh0aGF0IGlzIHZhbGlkIEpTT04pLlxuICogRnJvemVuIHZhbHVlcyBuZWVkIHRvIGJlIGltbXV0YWJsZSBvciB0cmVhdGVkIGFzIGlmIGltbXV0YWJsZS4gVGhleSBuZWVkIGJlIHNlcmlhbGl6YWJsZSBhcyB3ZWxsLlxuICogVmFsdWVzIHN0b3JlZCBpbiBmcm96ZW4gd2lsbCBzbmFwc2hvdHRlZCBhcy1pcyBieSBNU1QsIGFuZCBpbnRlcm5hbCBjaGFuZ2VzIHdpbGwgbm90IGJlIHRyYWNrZWQuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgdG8gc3RvcmUgY29tcGxleCwgYnV0IGltbXV0YWJsZSB2YWx1ZXMgbGlrZSB2ZWN0b3JzIGV0Yy4gSXQgY2FuIGZvcm0gYSBwb3dlcmZ1bCBicmlkZ2UgdG8gcGFydHMgb2YgeW91ciBhcHBsaWNhdGlvbiB0aGF0IHNob3VsZCBiZSBpbW11dGFibGUsIG9yIHRoYXQgYXNzdW1lIGRhdGEgdG8gYmUgaW1tdXRhYmxlLlxuICpcbiAqIE5vdGU6IGlmIHlvdSB3YW50IHRvIHN0b3JlIGZyZWUtZm9ybSBzdGF0ZSB0aGF0IGlzIG11dGFibGUsIG9yIG5vdCBzZXJpYWxpemVhYmxlLCBjb25zaWRlciB1c2luZyB2b2xhdGlsZSBzdGF0ZSBpbnN0ZWFkLlxuICpcbiAqIEZyb3plbiBwcm9wZXJ0aWVzIGNhbiBiZSBkZWZpbmVkIGluIHRocmVlIGRpZmZlcmVudCB3YXlzXG4gKiAxLiBgdHlwZXMuZnJvemVuKFN1YlR5cGUpYCAtIHByb3ZpZGUgYSB2YWxpZCBNU1QgdHlwZSBhbmQgZnJvemVuIHdpbGwgY2hlY2sgaWYgdGhlIHByb3ZpZGVkIGRhdGEgY29uZm9ybXMgdGhlIHNuYXBzaG90IGZvciB0aGF0IHR5cGVcbiAqIDIuIGB0eXBlcy5mcm96ZW4oeyBzb21lRGVmYXVsdFZhbHVlOiB0cnVlfSlgIC0gcHJvdmlkZSBhIHByaW1pdGl2ZSB2YWx1ZSwgb2JqZWN0IG9yIGFycmF5LCBhbmQgTVNUIHdpbGwgaW5mZXIgdGhlIHR5cGUgZnJvbSB0aGF0IG9iamVjdCwgYW5kIGFsc28gbWFrZSBpdCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGZpZWxkXG4gKiAzLiBgdHlwZXMuZnJvemVuPFR5cGVTY3JpcHRUeXBlPigpYCAtIHByb3ZpZGUgYSB0eXBlc2NyaXB0IHR5cGUsIHRvIGhlbHAgaW4gc3Ryb25nbHkgdHlwaW5nIHRoZSBmaWVsZCAoZGVzaWduIHRpbWUgb25seSlcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGNvbnN0IEdhbWVDaGFyYWN0ZXIgPSB0eXBlcy5tb2RlbCh7XG4gKiAgIG5hbWU6IHN0cmluZyxcbiAqICAgbG9jYXRpb246IHR5cGVzLmZyb3plbih7IHg6IDAsIHk6IDB9KVxuICogfSlcbiAqXG4gKiBjb25zdCBoZXJvID0gR2FtZUNoYXJhY3Rlci5jcmVhdGUoe1xuICogICBuYW1lOiBcIk1hcmlvXCIsXG4gKiAgIGxvY2F0aW9uOiB7IHg6IDcsIHk6IDQgfVxuICogfSlcbiAqXG4gKiBoZXJvLmxvY2F0aW9uID0geyB4OiAxMCwgeTogMiB9IC8vIE9LXG4gKiBoZXJvLmxvY2F0aW9uLnggPSA3IC8vIE5vdCBvayFcbiAqIGBgYFxuICpcbiAqIGBgYHRzXG4gKiB0eXBlIFBvaW50ID0geyB4OiBudW1iZXIsIHk6IG51bWJlciB9XG4gKiAgICBjb25zdCBNb3VzZSA9IHR5cGVzLm1vZGVsKHtcbiAqICAgICAgICAgbG9jOiB0eXBlcy5mcm96ZW48UG9pbnQ+KClcbiAqICAgIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlT3JUeXBlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBmcm96ZW4oYXJnKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB1bnR5cGVkRnJvemVuSW5zdGFuY2U7XG4gICAgZWxzZSBpZiAoaXNUeXBlKGFyZykpXG4gICAgICAgIHJldHVybiBuZXcgRnJvemVuKGFyZyk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gb3B0aW9uYWwodW50eXBlZEZyb3plbkluc3RhbmNlLCBhcmcpO1xufVxuLyoqXG4gKiBSZXR1cm5zIGlmIGEgZ2l2ZW4gdmFsdWUgcmVwcmVzZW50cyBhIGZyb3plbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0Zyb3plblR5cGUodHlwZSkge1xuICAgIHJldHVybiBpc1R5cGUodHlwZSkgJiYgKHR5cGUuZmxhZ3MgJiBUeXBlRmxhZ3MuRnJvemVuKSA+IDA7XG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRhdGlvbkNhdXNlKGhvb2spIHtcbiAgICBzd2l0Y2ggKGhvb2spIHtcbiAgICAgICAgY2FzZSBIb29rLmJlZm9yZURlc3Ryb3k6XG4gICAgICAgICAgICByZXR1cm4gXCJkZXN0cm95XCI7XG4gICAgICAgIGNhc2UgSG9vay5iZWZvcmVEZXRhY2g6XG4gICAgICAgICAgICByZXR1cm4gXCJkZXRhY2hcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxudmFyIFN0b3JlZFJlZmVyZW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yZWRSZWZlcmVuY2UodmFsdWUsIHRhcmdldFR5cGUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGFyZ2V0VHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdGFyZ2V0VHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRlbnRpZmllclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2RlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc29sdmVkUmVmZXJlbmNlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1ZhbGlkSWRlbnRpZmllcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaWRlbnRpZmllciA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU3RhdGVUcmVlTm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXROb2RlID0gZ2V0U3RhdGVUcmVlTm9kZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldE5vZGUuaWRlbnRpZmllckF0dHJpYnV0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJDYW4gb25seSBzdG9yZSByZWZlcmVuY2VzIHdpdGggYSBkZWZpbmVkIGlkZW50aWZpZXIgYXR0cmlidXRlLlwiKTtcbiAgICAgICAgICAgIHZhciBpZCA9IHRhcmdldE5vZGUudW5ub3JtYWxpemVkSWRlbnRpZmllcjtcbiAgICAgICAgICAgIGlmIChpZCA9PT0gbnVsbCB8fCBpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZmFpbCQxKFwiQ2FuIG9ubHkgc3RvcmUgcmVmZXJlbmNlcyB0byB0cmVlIG5vZGVzIHdpdGggYSBkZWZpbmVkIGlkZW50aWZpZXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJDYW4gb25seSBzdG9yZSByZWZlcmVuY2VzIHRvIHRyZWUgbm9kZXMgb3IgaWRlbnRpZmllcnMsIGdvdDogJ1wiICsgdmFsdWUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0b3JlZFJlZmVyZW5jZS5wcm90b3R5cGUsIFwidXBkYXRlUmVzb2x2ZWRSZWZlcmVuY2VcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZElkID0gbm9ybWFsaXplSWRlbnRpZmllcih0aGlzLmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBub2RlLnJvb3Q7XG4gICAgICAgICAgICB2YXIgbGFzdENhY2hlTW9kaWZpY2F0aW9uID0gcm9vdC5pZGVudGlmaWVyQ2FjaGUuZ2V0TGFzdENhY2hlTW9kaWZpY2F0aW9uUGVySWQobm9ybWFsaXplZElkKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXNvbHZlZFJlZmVyZW5jZSB8fFxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRSZWZlcmVuY2UubGFzdENhY2hlTW9kaWZpY2F0aW9uICE9PSBsYXN0Q2FjaGVNb2RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VHlwZSA9IHRoaXMudGFyZ2V0VHlwZTtcbiAgICAgICAgICAgICAgICAvLyByZWZlcmVuY2Ugd2FzIGluaXRpYWxpemVkIHdpdGggdGhlIGlkZW50aWZpZXIgb2YgdGhlIHRhcmdldFxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSByb290LmlkZW50aWZpZXJDYWNoZS5yZXNvbHZlKHRhcmdldFR5cGUsIG5vcm1hbGl6ZWRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSZWZlcmVuY2VFcnJvcihcIlttb2J4LXN0YXRlLXRyZWVdIEZhaWxlZCB0byByZXNvbHZlIHJlZmVyZW5jZSAnXCIgKyB0aGlzLmlkZW50aWZpZXIgKyBcIicgdG8gdHlwZSAnXCIgKyB0aGlzLnRhcmdldFR5cGUubmFtZSArIFwiJyAoZnJvbSBub2RlOiBcIiArIG5vZGUucGF0aCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFJlZmVyZW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBsYXN0Q2FjaGVNb2RpZmljYXRpb246IGxhc3RDYWNoZU1vZGlmaWNhdGlvblxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmVkUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJyZXNvbHZlZFZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdmVkUmVmZXJlbmNlKHRoaXMubm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFJlZmVyZW5jZS5ub2RlLnZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFN0b3JlZFJlZmVyZW5jZTtcbn0oKSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG52YXIgSW52YWxpZFJlZmVyZW5jZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnZhbGlkUmVmZXJlbmNlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW52YWxpZFJlZmVyZW5jZUVycm9yKG0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBJbnZhbGlkUmVmZXJlbmNlRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW52YWxpZFJlZmVyZW5jZUVycm9yO1xufShFcnJvcikpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIEJhc2VSZWZlcmVuY2VUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCYXNlUmVmZXJlbmNlVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXNlUmVmZXJlbmNlVHlwZSh0YXJnZXRUeXBlLCBvbkludmFsaWRhdGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwicmVmZXJlbmNlKFwiICsgdGFyZ2V0VHlwZS5uYW1lICsgXCIpXCIpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0YXJnZXRUeXBlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0YXJnZXRUeXBlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwib25JbnZhbGlkYXRlZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogb25JbnZhbGlkYXRlZFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcImZsYWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBUeXBlRmxhZ3MuUmVmZXJlbmNlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUmVmZXJlbmNlVHlwZS5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcImlzQXNzaWduYWJsZUZyb21cIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRUeXBlLmlzQXNzaWduYWJsZUZyb20odHlwZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZElkZW50aWZpZXIodmFsdWUpXG4gICAgICAgICAgICAgICAgPyB0eXBlQ2hlY2tTdWNjZXNzKClcbiAgICAgICAgICAgICAgICA6IHR5cGVDaGVja0ZhaWx1cmUoY29udGV4dCwgdmFsdWUsIFwiVmFsdWUgaXMgbm90IGEgdmFsaWQgaWRlbnRpZmllciwgd2hpY2ggaXMgYSBzdHJpbmcgb3IgYSBudW1iZXJcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcImZpcmVJbnZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGNhdXNlLCBzdG9yZWRSZWZOb2RlLCByZWZlcmVuY2VJZCwgcmVmVGFyZ2V0Tm9kZSkge1xuICAgICAgICAgICAgLy8gdG8gYWN0dWFsbHkgaW52YWxpZGF0ZSBhIHJlZmVyZW5jZSB3ZSBuZWVkIGFuIGFsaXZlIHBhcmVudCxcbiAgICAgICAgICAgIC8vIHNpbmNlIGl0IGlzIGEgc2NhbGFyIHZhbHVlIChpbW11dGFibGUtaXNoKSBhbmQgd2UgbmVlZCB0byBjaGFuZ2UgaXRcbiAgICAgICAgICAgIC8vIGZyb20gdGhlIHBhcmVudFxuICAgICAgICAgICAgdmFyIHN0b3JlZFJlZlBhcmVudE5vZGUgPSBzdG9yZWRSZWZOb2RlLnBhcmVudDtcbiAgICAgICAgICAgIGlmICghc3RvcmVkUmVmUGFyZW50Tm9kZSB8fCAhc3RvcmVkUmVmUGFyZW50Tm9kZS5pc0FsaXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0b3JlZFJlZlBhcmVudFZhbHVlID0gc3RvcmVkUmVmUGFyZW50Tm9kZS5zdG9yZWRWYWx1ZTtcbiAgICAgICAgICAgIGlmICghc3RvcmVkUmVmUGFyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uSW52YWxpZGF0ZWQoe1xuICAgICAgICAgICAgICAgIGNhdXNlOiBjYXVzZSxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IHN0b3JlZFJlZlBhcmVudFZhbHVlLFxuICAgICAgICAgICAgICAgIGludmFsaWRUYXJnZXQ6IHJlZlRhcmdldE5vZGUgPyByZWZUYXJnZXROb2RlLnN0b3JlZFZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGludmFsaWRJZDogcmVmZXJlbmNlSWQsXG4gICAgICAgICAgICAgICAgcmVwbGFjZVJlZjogZnVuY3Rpb24gKG5ld1JlZikge1xuICAgICAgICAgICAgICAgICAgICBhcHBseVBhdGNoKHN0b3JlZFJlZk5vZGUucm9vdC5zdG9yZWRWYWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld1JlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHN0b3JlZFJlZk5vZGUucGF0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbW92ZVJlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb2RlbFR5cGUoc3RvcmVkUmVmUGFyZW50Tm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlUmVmKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBseVBhdGNoKHN0b3JlZFJlZk5vZGUucm9vdC5zdG9yZWRWYWx1ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlbW92ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHN0b3JlZFJlZk5vZGUucGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUmVmZXJlbmNlVHlwZS5wcm90b3R5cGUsIFwiYWRkVGFyZ2V0Tm9kZVdhdGNoZXJcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChzdG9yZWRSZWZOb2RlLCByZWZlcmVuY2VJZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBtYWtlIHN1cmUgdGhlIHRhcmdldCBub2RlIGJlY29tZXMgY3JlYXRlZFxuICAgICAgICAgICAgdmFyIHJlZlRhcmdldFZhbHVlID0gdGhpcy5nZXRWYWx1ZShzdG9yZWRSZWZOb2RlKTtcbiAgICAgICAgICAgIGlmICghcmVmVGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlZlRhcmdldE5vZGUgPSBnZXRTdGF0ZVRyZWVOb2RlKHJlZlRhcmdldFZhbHVlKTtcbiAgICAgICAgICAgIHZhciBob29rSGFuZGxlciA9IGZ1bmN0aW9uIChfLCByZWZUYXJnZXROb2RlSG9vaykge1xuICAgICAgICAgICAgICAgIHZhciBjYXVzZSA9IGdldEludmFsaWRhdGlvbkNhdXNlKHJlZlRhcmdldE5vZGVIb29rKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyZUludmFsaWRhdGVkKGNhdXNlLCBzdG9yZWRSZWZOb2RlLCByZWZlcmVuY2VJZCwgcmVmVGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlZlRhcmdldERldGFjaEhvb2tEaXNwb3NlciA9IHJlZlRhcmdldE5vZGUucmVnaXN0ZXJIb29rKEhvb2suYmVmb3JlRGV0YWNoLCBob29rSGFuZGxlcik7XG4gICAgICAgICAgICB2YXIgcmVmVGFyZ2V0RGVzdHJveUhvb2tEaXNwb3NlciA9IHJlZlRhcmdldE5vZGUucmVnaXN0ZXJIb29rKEhvb2suYmVmb3JlRGVzdHJveSwgaG9va0hhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZWZUYXJnZXREZXRhY2hIb29rRGlzcG9zZXIoKTtcbiAgICAgICAgICAgICAgICByZWZUYXJnZXREZXN0cm95SG9va0Rpc3Bvc2VyKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VSZWZlcmVuY2VUeXBlLnByb3RvdHlwZSwgXCJ3YXRjaFRhcmdldE5vZGVGb3JJbnZhbGlkYXRpb25zXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAoc3RvcmVkUmVmTm9kZSwgaWRlbnRpZmllciwgY3VzdG9tR2V0U2V0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9uSW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb25SZWZUYXJnZXREZXN0cm95ZWRIb29rRGlzcG9zZXI7XG4gICAgICAgICAgICAvLyBnZXQgcmlkIG9mIHRoZSB3YXRjaGVyIGhvb2sgd2hlbiB0aGUgc3RvcmVkIHJlZiBub2RlIGlzIGRlc3Ryb3llZFxuICAgICAgICAgICAgLy8gZGV0YWNoZWQgaXMgaWdub3JlZCBzaW5jZSBzY2FsYXIgbm9kZXMgKHdoZXJlIHRoZSByZWZlcmVuY2UgcmVzaWRlcykgY2Fubm90IGJlIGRldGFjaGVkXG4gICAgICAgICAgICBzdG9yZWRSZWZOb2RlLnJlZ2lzdGVySG9vayhIb29rLmJlZm9yZURlc3Ryb3ksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAob25SZWZUYXJnZXREZXN0cm95ZWRIb29rRGlzcG9zZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25SZWZUYXJnZXREZXN0cm95ZWRIb29rRGlzcG9zZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzdGFydFdhdGNoaW5nID0gZnVuY3Rpb24gKHN5bmMpIHtcbiAgICAgICAgICAgICAgICAvLyByZS1jcmVhdGUgaG9vayBpbiBjYXNlIHRoZSBzdG9yZWQgcmVmIGdldHMgcmVhdHRhY2hlZFxuICAgICAgICAgICAgICAgIGlmIChvblJlZlRhcmdldERlc3Ryb3llZEhvb2tEaXNwb3Nlcikge1xuICAgICAgICAgICAgICAgICAgICBvblJlZlRhcmdldERlc3Ryb3llZEhvb2tEaXNwb3NlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHRhcmdldCBub2RlIGlzIGFjdHVhbGx5IHRoZXJlIGFuZCBpbml0aWFsaXplZFxuICAgICAgICAgICAgICAgIHZhciBzdG9yZWRSZWZQYXJlbnROb2RlID0gc3RvcmVkUmVmTm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlZFJlZlBhcmVudFZhbHVlID0gc3RvcmVkUmVmUGFyZW50Tm9kZSAmJiBzdG9yZWRSZWZQYXJlbnROb2RlLnN0b3JlZFZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZWRSZWZQYXJlbnROb2RlICYmIHN0b3JlZFJlZlBhcmVudE5vZGUuaXNBbGl2ZSAmJiBzdG9yZWRSZWZQYXJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmVGFyZ2V0Tm9kZUV4aXN0cyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1c3RvbUdldFNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmVGFyZ2V0Tm9kZUV4aXN0cyA9ICEhY3VzdG9tR2V0U2V0LmdldChpZGVudGlmaWVyLCBzdG9yZWRSZWZQYXJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZUYXJnZXROb2RlRXhpc3RzID0gc3RvcmVkUmVmTm9kZS5yb290LmlkZW50aWZpZXJDYWNoZS5oYXMoX3RoaXMudGFyZ2V0VHlwZSwgbm9ybWFsaXplSWRlbnRpZmllcihpZGVudGlmaWVyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZUYXJnZXROb2RlRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW5ub3QgY2hhbmdlIHRoZSByZWZlcmVuY2UgaW4gc3luYyBtb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBhIHJlY29uY2lsaWF0aW9uL2luc3RhbnRpYXRpb24gYW5kIHRoZSBjaGFuZ2Ugd291bGQgYmUgb3ZlcndyaXR0ZW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aG9zZSBjYXNlcyBqdXN0IGxldCB0aGUgd3JvbmcgcmVmZXJlbmNlIGJlIGFzc2lnbmVkIGFuZCBmYWlsIHVwb24gdXNhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChsaWtlIGN1cnJlbnQgcmVmZXJlbmNlcyBkbylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCBlZmZlY3RpdmVseSB0aGlzIGNvZGUgd2lsbCBvbmx5IHJ1biB3aGVuIGl0IGlzIGNyZWF0ZWQgZnJvbSBhIHNuYXBzaG90XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maXJlSW52YWxpZGF0ZWQoXCJpbnZhbGlkU25hcHNob3RSZWZlcmVuY2VcIiwgc3RvcmVkUmVmTm9kZSwgaWRlbnRpZmllciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblJlZlRhcmdldERlc3Ryb3llZEhvb2tEaXNwb3NlciA9IF90aGlzLmFkZFRhcmdldE5vZGVXYXRjaGVyKHN0b3JlZFJlZk5vZGUsIGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzdG9yZWRSZWZOb2RlLnN0YXRlID09PSBOb2RlTGlmZUN5Y2xlLkZJTkFMSVpFRCkge1xuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgYXR0YWNoZWQsIHNvIHRoZSB3aG9sZSB0cmVlIGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgc3RhcnRXYXRjaGluZyh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghc3RvcmVkUmVmTm9kZS5pc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgd2F0Y2hpbmcgb25jZSB0aGUgd2hvbGUgdHJlZSBpcyByZWFkeVxuICAgICAgICAgICAgICAgICAgICBzdG9yZWRSZWZOb2RlLnJvb3QucmVnaXN0ZXJIb29rKEhvb2suYWZ0ZXJDcmVhdGlvbkZpbmFsaXphdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGF0dGFjaCBpdCBzbyBpdCBjYW4gc3RhcnQgbGlzdGVuaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmVkUmVmTm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRSZWZOb2RlLnBhcmVudC5jcmVhdGVPYnNlcnZhYmxlSW5zdGFuY2VJZk5lZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgd2F0Y2hpbmcgb25jZSB0aGUgbm9kZSBpcyBhdHRhY2hlZCBzb21ld2hlcmUgLyBwYXJlbnQgY2hhbmdlc1xuICAgICAgICAgICAgICAgIHN0b3JlZFJlZk5vZGUucmVnaXN0ZXJIb29rKEhvb2suYWZ0ZXJBdHRhY2gsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRXYXRjaGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQmFzZVJlZmVyZW5jZVR5cGU7XG59KFNpbXBsZVR5cGUpKTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBJZGVudGlmaWVyUmVmZXJlbmNlVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSWRlbnRpZmllclJlZmVyZW5jZVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSWRlbnRpZmllclJlZmVyZW5jZVR5cGUodGFyZ2V0VHlwZSwgb25JbnZhbGlkYXRlZCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdGFyZ2V0VHlwZSwgb25JbnZhbGlkYXRlZCkgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJSZWZlcmVuY2VUeXBlLnByb3RvdHlwZSwgXCJnZXRWYWx1ZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHN0b3JlZFJlZk5vZGUpIHtcbiAgICAgICAgICAgIGlmICghc3RvcmVkUmVmTm9kZS5pc0FsaXZlKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgc3RvcmVkUmVmID0gc3RvcmVkUmVmTm9kZS5zdG9yZWRWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZWRSZWYucmVzb2x2ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJZGVudGlmaWVyUmVmZXJlbmNlVHlwZS5wcm90b3R5cGUsIFwiZ2V0U25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChzdG9yZWRSZWZOb2RlKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gc3RvcmVkUmVmTm9kZS5zdG9yZWRWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiByZWYuaWRlbnRpZmllcjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJZGVudGlmaWVyUmVmZXJlbmNlVHlwZS5wcm90b3R5cGUsIFwiaW5zdGFudGlhdGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gaXNTdGF0ZVRyZWVOb2RlKGluaXRpYWxWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IGdldElkZW50aWZpZXIoaW5pdGlhbFZhbHVlKVxuICAgICAgICAgICAgICAgIDogaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgdmFyIHN0b3JlZFJlZiA9IG5ldyBTdG9yZWRSZWZlcmVuY2UoaW5pdGlhbFZhbHVlLCB0aGlzLnRhcmdldFR5cGUpO1xuICAgICAgICAgICAgdmFyIHN0b3JlZFJlZk5vZGUgPSBjcmVhdGVTY2FsYXJOb2RlKHRoaXMsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIHN0b3JlZFJlZik7XG4gICAgICAgICAgICBzdG9yZWRSZWYubm9kZSA9IHN0b3JlZFJlZk5vZGU7XG4gICAgICAgICAgICB0aGlzLndhdGNoVGFyZ2V0Tm9kZUZvckludmFsaWRhdGlvbnMoc3RvcmVkUmVmTm9kZSwgaWRlbnRpZmllciwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZWRSZWZOb2RlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJSZWZlcmVuY2VUeXBlLnByb3RvdHlwZSwgXCJyZWNvbmNpbGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjdXJyZW50LCBuZXdWYWx1ZSwgcGFyZW50LCBzdWJwYXRoKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQuaXNEZXRhY2hpbmcgJiYgY3VycmVudC50eXBlID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBhcmVCeVZhbHVlID0gaXNTdGF0ZVRyZWVOb2RlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gY3VycmVudC5zdG9yZWRWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoKCFjb21wYXJlQnlWYWx1ZSAmJiByZWYuaWRlbnRpZmllciA9PT0gbmV3VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIChjb21wYXJlQnlWYWx1ZSAmJiByZWYucmVzb2x2ZWRWYWx1ZSA9PT0gbmV3VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuc2V0UGFyZW50KHBhcmVudCwgc3VicGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdOb2RlID0gdGhpcy5pbnN0YW50aWF0ZShwYXJlbnQsIHN1YnBhdGgsIHVuZGVmaW5lZCwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgY3VycmVudC5kaWUoKTsgLy8gbm9vcCBpZiBkZXRhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIElkZW50aWZpZXJSZWZlcmVuY2VUeXBlO1xufShCYXNlUmVmZXJlbmNlVHlwZSkpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIEN1c3RvbVJlZmVyZW5jZVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEN1c3RvbVJlZmVyZW5jZVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tUmVmZXJlbmNlVHlwZSh0YXJnZXRUeXBlLCBvcHRpb25zLCBvbkludmFsaWRhdGVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRhcmdldFR5cGUsIG9uSW52YWxpZGF0ZWQpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJvcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21SZWZlcmVuY2VUeXBlLnByb3RvdHlwZSwgXCJnZXRWYWx1ZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHN0b3JlZFJlZk5vZGUpIHtcbiAgICAgICAgICAgIGlmICghc3RvcmVkUmVmTm9kZS5pc0FsaXZlKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgcmVmZXJlbmNlZE5vZGUgPSB0aGlzLm9wdGlvbnMuZ2V0KHN0b3JlZFJlZk5vZGUuc3RvcmVkVmFsdWUsIHN0b3JlZFJlZk5vZGUucGFyZW50ID8gc3RvcmVkUmVmTm9kZS5wYXJlbnQuc3RvcmVkVmFsdWUgOiBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2VkTm9kZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21SZWZlcmVuY2VUeXBlLnByb3RvdHlwZSwgXCJnZXRTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHN0b3JlZFJlZk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZWRSZWZOb2RlLnN0b3JlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbVJlZmVyZW5jZVR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBpZGVudGlmaWVyID0gaXNTdGF0ZVRyZWVOb2RlKG5ld1ZhbHVlKVxuICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLnNldChuZXdWYWx1ZSwgcGFyZW50ID8gcGFyZW50LnN0b3JlZFZhbHVlIDogbnVsbClcbiAgICAgICAgICAgICAgICA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgdmFyIHN0b3JlZFJlZk5vZGUgPSBjcmVhdGVTY2FsYXJOb2RlKHRoaXMsIHBhcmVudCwgc3VicGF0aCwgZW52aXJvbm1lbnQsIGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgdGhpcy53YXRjaFRhcmdldE5vZGVGb3JJbnZhbGlkYXRpb25zKHN0b3JlZFJlZk5vZGUsIGlkZW50aWZpZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVkUmVmTm9kZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21SZWZlcmVuY2VUeXBlLnByb3RvdHlwZSwgXCJyZWNvbmNpbGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjdXJyZW50LCBuZXdWYWx1ZSwgcGFyZW50LCBzdWJwYXRoKSB7XG4gICAgICAgICAgICB2YXIgbmV3SWRlbnRpZmllciA9IGlzU3RhdGVUcmVlTm9kZShuZXdWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IHRoaXMub3B0aW9ucy5zZXQobmV3VmFsdWUsIGN1cnJlbnQgPyBjdXJyZW50LnN0b3JlZFZhbHVlIDogbnVsbClcbiAgICAgICAgICAgICAgICA6IG5ld1ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50LmlzRGV0YWNoaW5nICYmXG4gICAgICAgICAgICAgICAgY3VycmVudC50eXBlID09PSB0aGlzICYmXG4gICAgICAgICAgICAgICAgY3VycmVudC5zdG9yZWRWYWx1ZSA9PT0gbmV3SWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuc2V0UGFyZW50KHBhcmVudCwgc3VicGF0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IHRoaXMuaW5zdGFudGlhdGUocGFyZW50LCBzdWJwYXRoLCB1bmRlZmluZWQsIG5ld0lkZW50aWZpZXIpO1xuICAgICAgICAgICAgY3VycmVudC5kaWUoKTsgLy8gbm9vcCBpZiBkZXRhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEN1c3RvbVJlZmVyZW5jZVR5cGU7XG59KEJhc2VSZWZlcmVuY2VUeXBlKSk7XG4vKipcbiAqIGB0eXBlcy5yZWZlcmVuY2VgIC0gQ3JlYXRlcyBhIHJlZmVyZW5jZSB0byBhbm90aGVyIHR5cGUsIHdoaWNoIHNob3VsZCBoYXZlIGRlZmluZWQgYW4gaWRlbnRpZmllci5cbiAqIFNlZSBhbHNvIHRoZSBbcmVmZXJlbmNlIGFuZCBpZGVudGlmaWVyc10oaHR0cHM6Ly9naXRodWIuY29tL21vYnhqcy9tb2J4LXN0YXRlLXRyZWUjcmVmZXJlbmNlcy1hbmQtaWRlbnRpZmllcnMpIHNlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHJlZmVyZW5jZShzdWJUeXBlLCBvcHRpb25zKSB7XG4gICAgYXNzZXJ0SXNUeXBlKHN1YlR5cGUsIDEpO1xuICAgIGlmIChkZXZNb2RlKCkpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIHRocm93IGZhaWwkMShcIlJlZmVyZW5jZXMgd2l0aCBiYXNlIHBhdGggYXJlIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFBsZWFzZSByZW1vdmUgdGhlIGJhc2UgcGF0aC5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGdldFNldE9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICB2YXIgb25JbnZhbGlkYXRlZCA9IG9wdGlvbnNcbiAgICAgICAgPyBvcHRpb25zLm9uSW52YWxpZGF0ZWRcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGdldFNldE9wdGlvbnMgJiYgKGdldFNldE9wdGlvbnMuZ2V0IHx8IGdldFNldE9wdGlvbnMuc2V0KSkge1xuICAgICAgICBpZiAoZGV2TW9kZSgpKSB7XG4gICAgICAgICAgICBpZiAoIWdldFNldE9wdGlvbnMuZ2V0IHx8ICFnZXRTZXRPcHRpb25zLnNldCkge1xuICAgICAgICAgICAgICAgIHRocm93IGZhaWwkMShcInJlZmVyZW5jZSBvcHRpb25zIG11c3QgZWl0aGVyIGNvbnRhaW4gYm90aCBhICdnZXQnIGFuZCBhICdzZXQnIG1ldGhvZCBvciBub25lIG9mIHRoZW1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21SZWZlcmVuY2VUeXBlKHN1YlR5cGUsIHtcbiAgICAgICAgICAgIGdldDogZ2V0U2V0T3B0aW9ucy5nZXQsXG4gICAgICAgICAgICBzZXQ6IGdldFNldE9wdGlvbnMuc2V0XG4gICAgICAgIH0sIG9uSW52YWxpZGF0ZWQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJZGVudGlmaWVyUmVmZXJlbmNlVHlwZShzdWJUeXBlLCBvbkludmFsaWRhdGVkKTtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgaWYgYSBnaXZlbiB2YWx1ZSByZXByZXNlbnRzIGEgcmVmZXJlbmNlIHR5cGUuXG4gKlxuICogQHBhcmFtIHR5cGVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlzUmVmZXJlbmNlVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuICh0eXBlLmZsYWdzICYgVHlwZUZsYWdzLlJlZmVyZW5jZSkgPiAwO1xufVxuLyoqXG4gKiBgdHlwZXMuc2FmZVJlZmVyZW5jZWAgLSBBIHNhZmUgcmVmZXJlbmNlIGlzIGxpa2UgYSBzdGFuZGFyZCByZWZlcmVuY2UsIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdGhlIHVuZGVmaW5lZCB2YWx1ZSBieSBkZWZhdWx0XG4gKiBhbmQgYXV0b21hdGljYWxseSBzZXRzIGl0c2VsZiB0byB1bmRlZmluZWQgKHdoZW4gdGhlIHBhcmVudCBpcyBhIG1vZGVsKSAvIHJlbW92ZXMgaXRzZWxmIGZyb20gYXJyYXlzIGFuZCBtYXBzXG4gKiB3aGVuIHRoZSByZWZlcmVuY2UgaXQgaXMgcG9pbnRpbmcgdG8gZ2V0cyBkZXRhY2hlZC9kZXN0cm95ZWQuXG4gKlxuICogVGhlIG9wdGlvbmFsIG9wdGlvbnMgcGFyYW1ldGVyIG9iamVjdCBhY2NlcHRzIGEgcGFyYW1ldGVyIG5hbWVkIGBhY2NlcHRzVW5kZWZpbmVkYCwgd2hpY2ggaXMgc2V0IHRvIHRydWUgYnkgZGVmYXVsdCwgc28gaXQgaXMgc3VpdGFibGVcbiAqIGZvciBtb2RlbCBwcm9wZXJ0aWVzLlxuICogV2hlbiB1c2VkIGluc2lkZSBjb2xsZWN0aW9ucyAoYXJyYXlzL21hcHMpLCBpdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgdGhpcyBvcHRpb24gdG8gZmFsc2Ugc28gaXQgY2FuJ3QgdGFrZSB1bmRlZmluZWQgYXMgdmFsdWUsXG4gKiB3aGljaCBpcyB1c3VhbGx5IHRoZSBkZXNpcmVkIGluIHRob3NlIGNhc2VzLlxuICogQWRkaXRpb25hbGx5LCB0aGUgb3B0aW9uYWwgb3B0aW9ucyBwYXJhbWV0ZXIgb2JqZWN0IGFjY2VwdHMgYSBwYXJhbWV0ZXIgbmFtZWQgYG9uSW52YWxpZGF0ZWRgLCB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSByZWZlcmVuY2UgdGFyZ2V0IG5vZGUgdGhhdCB0aGUgcmVmZXJlbmNlIGlzIHBvaW50aW5nIHRvIGlzIGFib3V0IHRvIGJlIGRldGFjaGVkL2Rlc3Ryb3llZFxuICpcbiAqIFN0cmljdGx5IHNwZWFraW5nIGl0IGlzIGEgYHR5cGVzLm1heWJlKHR5cGVzLnJlZmVyZW5jZShYKSlgICh3aGVuIGBhY2NlcHRzVW5kZWZpbmVkYCBpcyBzZXQgdG8gdHJ1ZSwgdGhlIGRlZmF1bHQpIGFuZFxuICogYHR5cGVzLnJlZmVyZW5jZShYKWAgKHdoZW4gYGFjY2VwdHNVbmRlZmluZWRgIGlzIHNldCB0byBmYWxzZSksIGJvdGggb2YgdGhlbSB3aXRoIGEgY3VzdG9taXplZCBgb25JbnZhbGlkYXRlZGAgb3B0aW9uLlxuICpcbiAqIEBwYXJhbSBzdWJUeXBlXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gc2FmZVJlZmVyZW5jZShzdWJUeXBlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJlZlR5cGUgPSByZWZlcmVuY2Uoc3ViVHlwZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG9uSW52YWxpZGF0ZWQ6IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vbkludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vbkludmFsaWRhdGVkKGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2LnJlbW92ZVJlZigpO1xuICAgICAgICB9IH0pKTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFjY2VwdHNVbmRlZmluZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiByZWZUeXBlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1heWJlKHJlZlR5cGUpO1xuICAgIH1cbn1cblxudmFyIEJhc2VJZGVudGlmaWVyVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmFzZUlkZW50aWZpZXJUeXBlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhc2VJZGVudGlmaWVyVHlwZShuYW1lLCB2YWxpZFR5cGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcInZhbGlkVHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsaWRUeXBlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZmxhZ3NcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFR5cGVGbGFncy5JZGVudGlmaWVyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlSWRlbnRpZmllclR5cGUucHJvdG90eXBlLCBcImluc3RhbnRpYXRlXCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCAhKHBhcmVudC50eXBlIGluc3RhbmNlb2YgTW9kZWxUeXBlKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJJZGVudGlmaWVyIHR5cGVzIGNhbiBvbmx5IGJlIGluc3RhbnRpYXRlZCBhcyBkaXJlY3QgY2hpbGQgb2YgYSBtb2RlbCB0eXBlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNjYWxhck5vZGUodGhpcywgcGFyZW50LCBzdWJwYXRoLCBlbnZpcm9ubWVudCwgaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlSWRlbnRpZmllclR5cGUucHJvdG90eXBlLCBcInJlY29uY2lsZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGN1cnJlbnQsIG5ld1ZhbHVlLCBwYXJlbnQsIHN1YnBhdGgpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNvbnNpZGVyIGRldGFjaGluZyBoZXJlIHNpbmNlIGlkZW50aWZpZXIgYXJlIHNjYWxhciBub2RlcywgYW5kIHNjYWxhciBub2RlcyBjYW5ub3QgYmUgZGV0YWNoZWRcbiAgICAgICAgICAgIGlmIChjdXJyZW50LnN0b3JlZFZhbHVlICE9PSBuZXdWYWx1ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsJDEoXCJUcmllZCB0byBjaGFuZ2UgaWRlbnRpZmllciBmcm9tICdcIiArIGN1cnJlbnQuc3RvcmVkVmFsdWUgKyBcIicgdG8gJ1wiICsgbmV3VmFsdWUgKyBcIicuIENoYW5naW5nIGlkZW50aWZpZXJzIGlzIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgICAgIGN1cnJlbnQuc2V0UGFyZW50KHBhcmVudCwgc3VicGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlSWRlbnRpZmllclR5cGUucHJvdG90eXBlLCBcImlzVmFsaWRTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSB0aGlzLnZhbGlkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlQ2hlY2tGYWlsdXJlKGNvbnRleHQsIHZhbHVlLCBcIlZhbHVlIGlzIG5vdCBhIHZhbGlkIFwiICsgdGhpcy5kZXNjcmliZSgpICsgXCIsIGV4cGVjdGVkIGEgXCIgKyB0aGlzLnZhbGlkVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZUNoZWNrU3VjY2VzcygpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEJhc2VJZGVudGlmaWVyVHlwZTtcbn0oU2ltcGxlVHlwZSkpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIElkZW50aWZpZXJUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJZGVudGlmaWVyVHlwZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJZGVudGlmaWVyVHlwZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJpZGVudGlmaWVyXCIsIFwic3RyaW5nXCIpIHx8IHRoaXM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmbGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogVHlwZUZsYWdzLklkZW50aWZpZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJUeXBlLnByb3RvdHlwZSwgXCJkZXNjcmliZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaWRlbnRpZmllclwiO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIElkZW50aWZpZXJUeXBlO1xufShCYXNlSWRlbnRpZmllclR5cGUpKTtcbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbnZhciBJZGVudGlmaWVyTnVtYmVyVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSWRlbnRpZmllck51bWJlclR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSWRlbnRpZmllck51bWJlclR5cGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImlkZW50aWZpZXJOdW1iZXJcIiwgXCJudW1iZXJcIikgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJOdW1iZXJUeXBlLnByb3RvdHlwZSwgXCJnZXRTbmFwc2hvdFwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnN0b3JlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KElkZW50aWZpZXJOdW1iZXJUeXBlLnByb3RvdHlwZSwgXCJkZXNjcmliZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaWRlbnRpZmllck51bWJlclwiO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIElkZW50aWZpZXJOdW1iZXJUeXBlO1xufShCYXNlSWRlbnRpZmllclR5cGUpKTtcbi8qKlxuICogYHR5cGVzLmlkZW50aWZpZXJgIC0gSWRlbnRpZmllcnMgYXJlIHVzZWQgdG8gbWFrZSByZWZlcmVuY2VzLCBsaWZlY3ljbGUgZXZlbnRzIGFuZCByZWNvbmNpbGluZyB3b3Jrcy5cbiAqIEluc2lkZSBhIHN0YXRlIHRyZWUsIGZvciBlYWNoIHR5cGUgY2FuIGV4aXN0IG9ubHkgb25lIGluc3RhbmNlIGZvciBlYWNoIGdpdmVuIGlkZW50aWZpZXIuXG4gKiBGb3IgZXhhbXBsZSB0aGVyZSBjb3VsZG4ndCBiZSAyIGluc3RhbmNlcyBvZiB1c2VyIHdpdGggaWQgMS4gSWYgeW91IG5lZWQgbW9yZSwgY29uc2lkZXIgdXNpbmcgcmVmZXJlbmNlcy5cbiAqIElkZW50aWZpZXIgY2FuIGJlIHVzZWQgb25seSBhcyB0eXBlIHByb3BlcnR5IG9mIGEgbW9kZWwuXG4gKiBUaGlzIHR5cGUgYWNjZXB0cyBhcyBwYXJhbWV0ZXIgdGhlIHZhbHVlIHR5cGUgb2YgdGhlIGlkZW50aWZpZXIgZmllbGQgdGhhdCBjYW4gYmUgZWl0aGVyIHN0cmluZyBvciBudW1iZXIuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiAgY29uc3QgVG9kbyA9IHR5cGVzLm1vZGVsKFwiVG9kb1wiLCB7XG4gKiAgICAgIGlkOiB0eXBlcy5pZGVudGlmaWVyLFxuICogICAgICB0aXRsZTogdHlwZXMuc3RyaW5nXG4gKiAgfSlcbiAqIGBgYFxuICpcbiAqIEByZXR1cm5zXG4gKi9cbnZhciBpZGVudGlmaWVyID0gbmV3IElkZW50aWZpZXJUeXBlKCk7XG4vKipcbiAqIGB0eXBlcy5pZGVudGlmaWVyTnVtYmVyYCAtIFNpbWlsYXIgdG8gYHR5cGVzLmlkZW50aWZpZXJgLiBUaGlzIG9uZSB3aWxsIHNlcmlhbGl6ZSBmcm9tIC8gdG8gYSBudW1iZXIgd2hlbiBhcHBseWluZyBzbmFwc2hvdHNcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqICBjb25zdCBUb2RvID0gdHlwZXMubW9kZWwoXCJUb2RvXCIsIHtcbiAqICAgICAgaWQ6IHR5cGVzLmlkZW50aWZpZXJOdW1iZXIsXG4gKiAgICAgIHRpdGxlOiB0eXBlcy5zdHJpbmdcbiAqICB9KVxuICogYGBgXG4gKlxuICogQHJldHVybnNcbiAqL1xudmFyIGlkZW50aWZpZXJOdW1iZXIgPSBuZXcgSWRlbnRpZmllck51bWJlclR5cGUoKTtcbi8qKlxuICogUmV0dXJucyBpZiBhIGdpdmVuIHZhbHVlIHJlcHJlc2VudHMgYW4gaWRlbnRpZmllciB0eXBlLlxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0lkZW50aWZpZXJUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gaXNUeXBlKHR5cGUpICYmICh0eXBlLmZsYWdzICYgVHlwZUZsYWdzLklkZW50aWZpZXIpID4gMDtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkZW50aWZpZXIoaWQpIHtcbiAgICByZXR1cm4gXCJcIiArIGlkO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZElkZW50aWZpZXIoaWQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlkID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIjtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzVmFsaWRJZGVudGlmaWVyKGlkLCBhcmdOdW1iZXIpIHtcbiAgICBhc3NlcnRBcmcoaWQsIGlzVmFsaWRJZGVudGlmaWVyLCBcInN0cmluZyBvciBudW1iZXIgKGlkZW50aWZpZXIpXCIsIGFyZ051bWJlcik7XG59XG5cbi8qKlxuICogYHR5cGVzLmN1c3RvbWAgLSBDcmVhdGVzIGEgY3VzdG9tIHR5cGUuIEN1c3RvbSB0eXBlcyBjYW4gYmUgdXNlZCBmb3IgYXJiaXRyYXJ5IGltbXV0YWJsZSB2YWx1ZXMsIHRoYXQgaGF2ZSBhIHNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbi4gRm9yIGV4YW1wbGUsIHRvIGNyZWF0ZSB5b3VyIG93biBEYXRlIHJlcHJlc2VudGF0aW9uLCBEZWNpbWFsIHR5cGUgZXRjLlxuICpcbiAqIFRoZSBzaWduYXR1cmUgb2YgdGhlIG9wdGlvbnMgaXM6XG4gKiBgYGB0c1xuICogZXhwb3J0IGludGVyZmFjZSBDdXN0b21UeXBlT3B0aW9uczxTLCBUPiB7XG4gKiAgICAgLy8gRnJpZW5kbHkgbmFtZVxuICogICAgIG5hbWU6IHN0cmluZ1xuICogICAgIC8vIGdpdmVuIGEgc2VyaWFsaXplZCB2YWx1ZSBhbmQgZW52aXJvbm1lbnQsIGhvdyB0byB0dXJuIGl0IGludG8gdGhlIHRhcmdldCB0eXBlXG4gKiAgICAgZnJvbVNuYXBzaG90KHNuYXBzaG90OiBTLCBlbnY6IGFueSk6IFRcbiAqICAgICAvLyByZXR1cm4gdGhlIHNlcmlhbGl6YXRpb24gb2YgdGhlIGN1cnJlbnQgdmFsdWVcbiAqICAgICB0b1NuYXBzaG90KHZhbHVlOiBUKTogU1xuICogICAgIC8vIGlmIHRydWUsIHRoaXMgaXMgYSBjb252ZXJ0ZWQgdmFsdWUsIGlmIGZhbHNlLCBpdCdzIGEgc25hcHNob3RcbiAqICAgICBpc1RhcmdldFR5cGUodmFsdWU6IFQgfCBTKTogdmFsdWUgaXMgVFxuICogICAgIC8vIGEgbm9uIGVtcHR5IHN0cmluZyBpcyBhc3N1bWVkIHRvIGJlIGEgdmFsaWRhdGlvbiBlcnJvclxuICogICAgIGdldFZhbGlkYXRpb25NZXNzYWdlPyhzbmFwc2hvdDogUyk6IHN0cmluZ1xuICogfVxuICogYGBgXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYHRzXG4gKiBjb25zdCBEZWNpbWFsUHJpbWl0aXZlID0gdHlwZXMuY3VzdG9tPHN0cmluZywgRGVjaW1hbD4oe1xuICogICAgIG5hbWU6IFwiRGVjaW1hbFwiLFxuICogICAgIGZyb21TbmFwc2hvdCh2YWx1ZTogc3RyaW5nKSB7XG4gKiAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbCh2YWx1ZSlcbiAqICAgICB9LFxuICogICAgIHRvU25hcHNob3QodmFsdWU6IERlY2ltYWwpIHtcbiAqICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKClcbiAqICAgICB9LFxuICogICAgIGlzVGFyZ2V0VHlwZSh2YWx1ZTogc3RyaW5nIHwgRGVjaW1hbCk6IGJvb2xlYW4ge1xuICogICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEZWNpbWFsXG4gKiAgICAgfSxcbiAqICAgICBnZXRWYWxpZGF0aW9uTWVzc2FnZSh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAqICAgICAgICAgaWYgKC9eLT9cXGQrXFwuXFxkKyQvLnRlc3QodmFsdWUpKSByZXR1cm4gXCJcIiAvLyBPS1xuICogICAgICAgICByZXR1cm4gYCcke3ZhbHVlfScgZG9lc24ndCBsb29rIGxpa2UgYSB2YWxpZCBkZWNpbWFsIG51bWJlcmBcbiAqICAgICB9XG4gKiB9KVxuICpcbiAqIGNvbnN0IFdhbGxldCA9IHR5cGVzLm1vZGVsKHtcbiAqICAgICBiYWxhbmNlOiBEZWNpbWFsUHJpbWl0aXZlXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBDdXN0b21UeXBlKG9wdGlvbnMpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xudmFyIEN1c3RvbVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEN1c3RvbVR5cGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ3VzdG9tVHlwZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMubmFtZSkgfHwgdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIm9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmbGFnc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogVHlwZUZsYWdzLkN1c3RvbVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tVHlwZS5wcm90b3R5cGUsIFwiZGVzY3JpYmVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tVHlwZS5wcm90b3R5cGUsIFwiaXNWYWxpZFNuYXBzaG90XCIsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNUYXJnZXRUeXBlKHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZUNoZWNrU3VjY2VzcygpO1xuICAgICAgICAgICAgdmFyIHR5cGVFcnJvciA9IHRoaXMub3B0aW9ucy5nZXRWYWxpZGF0aW9uTWVzc2FnZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodHlwZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVDaGVja0ZhaWx1cmUoY29udGV4dCwgdmFsdWUsIFwiSW52YWxpZCB2YWx1ZSBmb3IgdHlwZSAnXCIgKyB0aGlzLm5hbWUgKyBcIic6IFwiICsgdHlwZUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlQ2hlY2tTdWNjZXNzKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tVHlwZS5wcm90b3R5cGUsIFwiZ2V0U25hcHNob3RcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRvU25hcHNob3Qobm9kZS5zdG9yZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tVHlwZS5wcm90b3R5cGUsIFwiaW5zdGFudGlhdGVcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZVRvU3RvcmUgPSB0aGlzLm9wdGlvbnMuaXNUYXJnZXRUeXBlKGluaXRpYWxWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IGluaXRpYWxWYWx1ZVxuICAgICAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLmZyb21TbmFwc2hvdChpbml0aWFsVmFsdWUsIHBhcmVudCAmJiBwYXJlbnQucm9vdC5lbnZpcm9ubWVudCk7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlU2NhbGFyTm9kZSh0aGlzLCBwYXJlbnQsIHN1YnBhdGgsIGVudmlyb25tZW50LCB2YWx1ZVRvU3RvcmUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbVR5cGUucHJvdG90eXBlLCBcInJlY29uY2lsZVwiLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGN1cnJlbnQsIHZhbHVlLCBwYXJlbnQsIHN1YnBhdGgpIHtcbiAgICAgICAgICAgIHZhciBpc1NuYXBzaG90ID0gIXRoaXMub3B0aW9ucy5pc1RhcmdldFR5cGUodmFsdWUpO1xuICAgICAgICAgICAgLy8gaW4gdGhlb3J5IGN1c3RvbXMgdXNlIHNjYWxhciBub2RlcyB3aGljaCBjYW5ub3QgYmUgZGV0YWNoZWQsIGJ1dCBzdGlsbC4uLlxuICAgICAgICAgICAgaWYgKCFjdXJyZW50LmlzRGV0YWNoaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVuY2hhbmdlZCA9IGN1cnJlbnQudHlwZSA9PT0gdGhpcyAmJlxuICAgICAgICAgICAgICAgICAgICAoaXNTbmFwc2hvdCA/IHZhbHVlID09PSBjdXJyZW50LnNuYXBzaG90IDogdmFsdWUgPT09IGN1cnJlbnQuc3RvcmVkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh1bmNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudC5zZXRQYXJlbnQocGFyZW50LCBzdWJwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlVG9TdG9yZSA9IGlzU25hcHNob3RcbiAgICAgICAgICAgICAgICA/IHRoaXMub3B0aW9ucy5mcm9tU25hcHNob3QodmFsdWUsIHBhcmVudC5yb290LmVudmlyb25tZW50KVxuICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IHRoaXMuaW5zdGFudGlhdGUocGFyZW50LCBzdWJwYXRoLCB1bmRlZmluZWQsIHZhbHVlVG9TdG9yZSk7XG4gICAgICAgICAgICBjdXJyZW50LmRpZSgpOyAvLyBub29wIGlmIGRldGFjaGluZ1xuICAgICAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQ3VzdG9tVHlwZTtcbn0oU2ltcGxlVHlwZSkpO1xuXG4vLyB3ZSBpbXBvcnQgdGhlIHR5cGVzIHRvIHJlLWV4cG9ydCB0aGVtIGluc2lkZSB0eXBlcy5cbnZhciB0eXBlcyA9IHtcbiAgICBlbnVtZXJhdGlvbjogZW51bWVyYXRpb24sXG4gICAgbW9kZWw6IG1vZGVsLFxuICAgIGNvbXBvc2U6IGNvbXBvc2UsXG4gICAgY3VzdG9tOiBjdXN0b20sXG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgc2FmZVJlZmVyZW5jZTogc2FmZVJlZmVyZW5jZSxcbiAgICB1bmlvbjogdW5pb24sXG4gICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgIGxpdGVyYWw6IGxpdGVyYWwsXG4gICAgbWF5YmU6IG1heWJlLFxuICAgIG1heWJlTnVsbDogbWF5YmVOdWxsLFxuICAgIHJlZmluZW1lbnQ6IHJlZmluZW1lbnQsXG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgYm9vbGVhbjogYm9vbGVhbixcbiAgICBudW1iZXI6IG51bWJlcixcbiAgICBpbnRlZ2VyOiBpbnRlZ2VyLFxuICAgIERhdGU6IERhdGVQcmltaXRpdmUsXG4gICAgbWFwOiBtYXAsXG4gICAgYXJyYXk6IGFycmF5LFxuICAgIGZyb3plbjogZnJvemVuLFxuICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgaWRlbnRpZmllck51bWJlcjogaWRlbnRpZmllck51bWJlcixcbiAgICBsYXRlOiBsYXRlLFxuICAgIHVuZGVmaW5lZDogdW5kZWZpbmVkVHlwZSxcbiAgICBudWxsOiBudWxsVHlwZSxcbiAgICBzbmFwc2hvdFByb2Nlc3Nvcjogc25hcHNob3RQcm9jZXNzb3Jcbn07XG5cbmV4cG9ydCB7IGFkZERpc3Bvc2VyLCBhZGRNaWRkbGV3YXJlLCBhcHBseUFjdGlvbiwgYXBwbHlQYXRjaCwgYXBwbHlTbmFwc2hvdCwgY2FzdCwgY2FzdEZsb3dSZXR1cm4sIGNhc3RUb1JlZmVyZW5jZVNuYXBzaG90LCBjYXN0VG9TbmFwc2hvdCwgY2xvbmUsIGNyZWF0ZUFjdGlvblRyYWNraW5nTWlkZGxld2FyZSwgY3JlYXRlQWN0aW9uVHJhY2tpbmdNaWRkbGV3YXJlMiwgZGVjb3JhdGUsIGRlc3Ryb3ksIGRldGFjaCwgZXNjYXBlSnNvblBhdGgsIGZsb3csIGdldENoaWxkVHlwZSwgZ2V0RW52LCBnZXRJZGVudGlmaWVyLCBnZXRMaXZlbGluZXNzQ2hlY2tpbmcsIGdldE1lbWJlcnMsIGdldE5vZGVJZCwgZ2V0UGFyZW50LCBnZXRQYXJlbnRPZlR5cGUsIGdldFBhdGgsIGdldFBhdGhQYXJ0cywgZ2V0UHJvcGVydHlNZW1iZXJzLCBnZXRSZWxhdGl2ZVBhdGgsIGdldFJvb3QsIGdldFJ1bm5pbmdBY3Rpb25Db250ZXh0LCBnZXRTbmFwc2hvdCwgZ2V0VHlwZSwgaGFzUGFyZW50LCBoYXNQYXJlbnRPZlR5cGUsIGlzQWN0aW9uQ29udGV4dENoaWxkT2YsIGlzQWN0aW9uQ29udGV4dFRoaXNPckNoaWxkT2YsIGlzQWxpdmUsIGlzQXJyYXlUeXBlLCBpc0Zyb3plblR5cGUsIGlzSWRlbnRpZmllclR5cGUsIGlzTGF0ZVR5cGUsIGlzTGl0ZXJhbFR5cGUsIGlzTWFwVHlwZSwgaXNNb2RlbFR5cGUsIGlzT3B0aW9uYWxUeXBlLCBpc1ByaW1pdGl2ZVR5cGUsIGlzUHJvdGVjdGVkLCBpc1JlZmVyZW5jZVR5cGUsIGlzUmVmaW5lbWVudFR5cGUsIGlzUm9vdCwgaXNTdGF0ZVRyZWVOb2RlLCBpc1R5cGUsIGlzVW5pb25UeXBlLCBpc1ZhbGlkUmVmZXJlbmNlLCBqb2luSnNvblBhdGgsIG9uQWN0aW9uLCBvblBhdGNoLCBvblNuYXBzaG90LCBwcm9jZXNzJDEgYXMgcHJvY2VzcywgcHJvdGVjdCwgcmVjb3JkQWN0aW9ucywgcmVjb3JkUGF0Y2hlcywgcmVzb2x2ZUlkZW50aWZpZXIsIHJlc29sdmVQYXRoLCBzZXRMaXZlbGluZXNzQ2hlY2tpbmcsIHNldExpdmVseW5lc3NDaGVja2luZywgc3BsaXRKc29uUGF0aCwgdG9HZW5lcmF0b3IsIHRvR2VuZXJhdG9yRnVuY3Rpb24sIHRyeVJlZmVyZW5jZSwgdHJ5UmVzb2x2ZSwgdHlwZWNoZWNrLCB0eXBlcywgdW5lc2NhcGVKc29uUGF0aCwgdW5wcm90ZWN0LCB3YWxrIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/Elite_Series.png":
/*!*********************************************!*\
  !*** ./src/images/leagues/Elite_Series.png ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/Elite_Series.336a1a30.png\",\"height\":2576,\"width\":2599,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FElite_Series.336a1a30.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9FbGl0ZV9TZXJpZXMucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDhNQUE4TSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvRWxpdGVfU2VyaWVzLnBuZz9hZjhlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9FbGl0ZV9TZXJpZXMuMzM2YTFhMzAucG5nXCIsXCJoZWlnaHRcIjoyNTc2LFwid2lkdGhcIjoyNTk5LFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRkVsaXRlX1Nlcmllcy4zMzZhMWEzMC5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6OH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/Elite_Series.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/Esports_Balkan_League.png":
/*!******************************************************!*\
  !*** ./src/images/leagues/Esports_Balkan_League.png ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/Esports_Balkan_League.8654524d.png\",\"height\":563,\"width\":600,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FEsports_Balkan_League.8654524d.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9Fc3BvcnRzX0JhbGthbl9MZWFndWUucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDhOQUE4TiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvRXNwb3J0c19CYWxrYW5fTGVhZ3VlLnBuZz85YzRhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9Fc3BvcnRzX0JhbGthbl9MZWFndWUuODY1NDUyNGQucG5nXCIsXCJoZWlnaHRcIjo1NjMsXCJ3aWR0aFwiOjYwMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZFc3BvcnRzX0JhbGthbl9MZWFndWUuODY1NDUyNGQucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/Esports_Balkan_League.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/Hitpoint_Masters.png":
/*!*************************************************!*\
  !*** ./src/images/leagues/Hitpoint_Masters.png ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/Hitpoint_Masters.a8d1c069.png\",\"height\":360,\"width\":360,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FHitpoint_Masters.a8d1c069.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9IaXRwb2ludF9NYXN0ZXJzLnBuZyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsQ0FBQyxvTkFBb04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2ltYWdlcy9sZWFndWVzL0hpdHBvaW50X01hc3RlcnMucG5nPzliZTgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL0hpdHBvaW50X01hc3RlcnMuYThkMWMwNjkucG5nXCIsXCJoZWlnaHRcIjozNjAsXCJ3aWR0aFwiOjM2MCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZIaXRwb2ludF9NYXN0ZXJzLmE4ZDFjMDY5LnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/Hitpoint_Masters.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/LCK_CL.png":
/*!***************************************!*\
  !*** ./src/images/leagues/LCK_CL.png ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/LCK_CL.58307dd5.png\",\"height\":1000,\"width\":1000,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FLCK_CL.58307dd5.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9MQ0tfQ0wucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLGtNQUFrTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvTENLX0NMLnBuZz9lNTIwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9MQ0tfQ0wuNTgzMDdkZDUucG5nXCIsXCJoZWlnaHRcIjoxMDAwLFwid2lkdGhcIjoxMDAwLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRkxDS19DTC41ODMwN2RkNS5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6OH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/LCK_CL.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/LPLOL.png":
/*!**************************************!*\
  !*** ./src/images/leagues/LPLOL.png ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/LPLOL.5beda8e6.png\",\"height\":1312,\"width\":1312,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FLPLOL.5beda8e6.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9MUExPTC5wbmciLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLENBQUMsZ01BQWdNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9MUExPTC5wbmc/NDJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XCJzcmNcIjpcIi9fbmV4dC9zdGF0aWMvbWVkaWEvTFBMT0wuNWJlZGE4ZTYucG5nXCIsXCJoZWlnaHRcIjoxMzEyLFwid2lkdGhcIjoxMzEyLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRkxQTE9MLjViZWRhOGU2LnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/LPLOL.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/NLC.png":
/*!************************************!*\
  !*** ./src/images/leagues/NLC.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/NLC.56f83d84.png\",\"height\":600,\"width\":600,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FNLC.56f83d84.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9OTEMucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDBMQUEwTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvTkxDLnBuZz81ZDQ2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9OTEMuNTZmODNkODQucG5nXCIsXCJoZWlnaHRcIjo2MDAsXCJ3aWR0aFwiOjYwMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZOTEMuNTZmODNkODQucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/NLC.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/Prime_League_1st_Division.png":
/*!**********************************************************!*\
  !*** ./src/images/leagues/Prime_League_1st_Division.png ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/Prime_League_1st_Division.b3d70c12.png\",\"height\":460,\"width\":460,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FPrime_League_1st_Division.b3d70c12.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9QcmltZV9MZWFndWVfMXN0X0RpdmlzaW9uLnBuZyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsQ0FBQyxzT0FBc08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2ltYWdlcy9sZWFndWVzL1ByaW1lX0xlYWd1ZV8xc3RfRGl2aXNpb24ucG5nPzE0NWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL1ByaW1lX0xlYWd1ZV8xc3RfRGl2aXNpb24uYjNkNzBjMTIucG5nXCIsXCJoZWlnaHRcIjo0NjAsXCJ3aWR0aFwiOjQ2MCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZQcmltZV9MZWFndWVfMXN0X0RpdmlzaW9uLmIzZDcwYzEyLnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/Prime_League_1st_Division.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/Turkey_Academy_League.png":
/*!******************************************************!*\
  !*** ./src/images/leagues/Turkey_Academy_League.png ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/Turkey_Academy_League.ae6961c0.png\",\"height\":444,\"width\":820,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FTurkey_Academy_League.ae6961c0.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":4});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9UdXJrZXlfQWNhZGVteV9MZWFndWUucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDhOQUE4TiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvVHVya2V5X0FjYWRlbXlfTGVhZ3VlLnBuZz85MTM0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9UdXJrZXlfQWNhZGVteV9MZWFndWUuYWU2OTYxYzAucG5nXCIsXCJoZWlnaHRcIjo0NDQsXCJ3aWR0aFwiOjgyMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZUdXJrZXlfQWNhZGVteV9MZWFndWUuYWU2OTYxYzAucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjR9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/Turkey_Academy_League.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/cblol.png":
/*!**************************************!*\
  !*** ./src/images/leagues/cblol.png ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/cblol.a43854e1.png\",\"height\":439,\"width\":600,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fcblol.a43854e1.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":6});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9jYmxvbC5wbmciLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLENBQUMsOExBQThMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9jYmxvbC5wbmc/MmRhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XCJzcmNcIjpcIi9fbmV4dC9zdGF0aWMvbWVkaWEvY2Jsb2wuYTQzODU0ZTEucG5nXCIsXCJoZWlnaHRcIjo0MzksXCJ3aWR0aFwiOjYwMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZjYmxvbC5hNDM4NTRlMS5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6Nn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/cblol.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/lck.png":
/*!************************************!*\
  !*** ./src/images/leagues/lck.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/lck.e9788f00.png\",\"height\":909,\"width\":909,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flck.e9788f00.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9sY2sucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDBMQUEwTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvbGNrLnBuZz9lODFjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9sY2suZTk3ODhmMDAucG5nXCIsXCJoZWlnaHRcIjo5MDksXCJ3aWR0aFwiOjkwOSxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZsY2suZTk3ODhmMDAucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/lck.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/lcknav.png":
/*!***************************************!*\
  !*** ./src/images/leagues/lcknav.png ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/lcknav.6237dbf2.png\",\"height\":550,\"width\":550,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flcknav.6237dbf2.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9sY2tuYXYucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLGdNQUFnTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvbGNrbmF2LnBuZz82ZDZkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9sY2tuYXYuNjIzN2RiZjIucG5nXCIsXCJoZWlnaHRcIjo1NTAsXCJ3aWR0aFwiOjU1MCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZsY2tuYXYuNjIzN2RiZjIucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/lcknav.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/lco.png":
/*!************************************!*\
  !*** ./src/images/leagues/lco.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/lco.19aa27b8.png\",\"height\":350,\"width\":350,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flco.19aa27b8.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9sY28ucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDBMQUEwTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvbGNvLnBuZz8yNGRmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9sY28uMTlhYTI3YjgucG5nXCIsXCJoZWlnaHRcIjozNTAsXCJ3aWR0aFwiOjM1MCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZsY28uMTlhYTI3YjgucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/lco.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/lcs.png":
/*!************************************!*\
  !*** ./src/images/leagues/lcs.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/lcs.4ad0170b.png\",\"height\":600,\"width\":600,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flcs.4ad0170b.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9sY3MucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDBMQUEwTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvbGNzLnBuZz83Mjc2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9sY3MuNGFkMDE3MGIucG5nXCIsXCJoZWlnaHRcIjo2MDAsXCJ3aWR0aFwiOjYwMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZsY3MuNGFkMDE3MGIucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/lcs.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/lec.png":
/*!************************************!*\
  !*** ./src/images/leagues/lec.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/lec.951405b9.png\",\"height\":1230,\"width\":1230,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flec.951405b9.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9sZWMucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDRMQUE0TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvbGVjLnBuZz8xMmVlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9sZWMuOTUxNDA1YjkucG5nXCIsXCJoZWlnaHRcIjoxMjMwLFwid2lkdGhcIjoxMjMwLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmxlYy45NTE0MDViOS5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6OH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/lec.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/lecnav.png":
/*!***************************************!*\
  !*** ./src/images/leagues/lecnav.png ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/lecnav.63d92a3f.png\",\"height\":1000,\"width\":1000,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flecnav.63d92a3f.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9sZWNuYXYucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLGtNQUFrTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvbGVjbmF2LnBuZz8zMzgxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9sZWNuYXYuNjNkOTJhM2YucG5nXCIsXCJoZWlnaHRcIjoxMDAwLFwid2lkdGhcIjoxMDAwLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmxlY25hdi42M2Q5MmEzZi5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6OH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/lecnav.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/lfl.png":
/*!************************************!*\
  !*** ./src/images/leagues/lfl.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/lfl.beb9dd34.png\",\"height\":942,\"width\":942,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flfl.beb9dd34.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9sZmwucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDBMQUEwTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvbGZsLnBuZz82YzA1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9sZmwuYmViOWRkMzQucG5nXCIsXCJoZWlnaHRcIjo5NDIsXCJ3aWR0aFwiOjk0MixcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZsZmwuYmViOWRkMzQucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/lfl.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/ljl.png":
/*!************************************!*\
  !*** ./src/images/leagues/ljl.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/ljl.5f23bf5d.png\",\"height\":220,\"width\":220,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fljl.5f23bf5d.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9samwucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDBMQUEwTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvbGpsLnBuZz81MDkyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9samwuNWYyM2JmNWQucG5nXCIsXCJoZWlnaHRcIjoyMjAsXCJ3aWR0aFwiOjIyMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZsamwuNWYyM2JmNWQucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/ljl.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/lla.png":
/*!************************************!*\
  !*** ./src/images/leagues/lla.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/lla.01fe25f0.png\",\"height\":429,\"width\":600,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flla.01fe25f0.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":6});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9sbGEucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDBMQUEwTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvbGxhLnBuZz81OWEzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9sbGEuMDFmZTI1ZjAucG5nXCIsXCJoZWlnaHRcIjo0MjksXCJ3aWR0aFwiOjYwMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZsbGEuMDFmZTI1ZjAucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjZ9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/lla.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/llanav.png":
/*!***************************************!*\
  !*** ./src/images/leagues/llanav.png ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/llanav.7f9dbf2f.png\",\"height\":1000,\"width\":1000,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fllanav.7f9dbf2f.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9sbGFuYXYucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLGtNQUFrTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvbGxhbmF2LnBuZz8zN2I4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9sbGFuYXYuN2Y5ZGJmMmYucG5nXCIsXCJoZWlnaHRcIjoxMDAwLFwid2lkdGhcIjoxMDAwLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRmxsYW5hdi43ZjlkYmYyZi5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6OH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/llanav.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/lpl.png":
/*!************************************!*\
  !*** ./src/images/leagues/lpl.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/lpl.bca75cb3.png\",\"height\":482,\"width\":800,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flpl.bca75cb3.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":5});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9scGwucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDBMQUEwTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvbHBsLnBuZz80MjYzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9scGwuYmNhNzVjYjMucG5nXCIsXCJoZWlnaHRcIjo0ODIsXCJ3aWR0aFwiOjgwMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZscGwuYmNhNzVjYjMucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjV9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/lpl.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/lvp_superliga.png":
/*!**********************************************!*\
  !*** ./src/images/leagues/lvp_superliga.png ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/lvp_superliga.27c183d8.png\",\"height\":564,\"width\":600,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Flvp_superliga.27c183d8.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9sdnBfc3VwZXJsaWdhLnBuZyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsQ0FBQyw4TUFBOE0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2ltYWdlcy9sZWFndWVzL2x2cF9zdXBlcmxpZ2EucG5nP2U5NWMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1wic3JjXCI6XCIvX25leHQvc3RhdGljL21lZGlhL2x2cF9zdXBlcmxpZ2EuMjdjMTgzZDgucG5nXCIsXCJoZWlnaHRcIjo1NjQsXCJ3aWR0aFwiOjYwMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZsdnBfc3VwZXJsaWdhLjI3YzE4M2Q4LnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/lvp_superliga.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/na_academy_league.png":
/*!**************************************************!*\
  !*** ./src/images/leagues/na_academy_league.png ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/na_academy_league.55779d1a.png\",\"height\":1600,\"width\":1600,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fna_academy_league.55779d1a.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9uYV9hY2FkZW15X2xlYWd1ZS5wbmciLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLENBQUMsd05BQXdOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9uYV9hY2FkZW15X2xlYWd1ZS5wbmc/YWMwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XCJzcmNcIjpcIi9fbmV4dC9zdGF0aWMvbWVkaWEvbmFfYWNhZGVteV9sZWFndWUuNTU3NzlkMWEucG5nXCIsXCJoZWlnaHRcIjoxNjAwLFwid2lkdGhcIjoxNjAwLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRm5hX2FjYWRlbXlfbGVhZ3VlLjU1Nzc5ZDFhLnBuZyZ3PTgmcT03MFwiLFwiYmx1cldpZHRoXCI6OCxcImJsdXJIZWlnaHRcIjo4fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/na_academy_league.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/pcs.png":
/*!************************************!*\
  !*** ./src/images/leagues/pcs.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/pcs.974a850d.png\",\"height\":202,\"width\":200,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fpcs.974a850d.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy9wY3MucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDBMQUEwTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvcGNzLnBuZz80MTI3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS9wY3MuOTc0YTg1MGQucG5nXCIsXCJoZWlnaHRcIjoyMDIsXCJ3aWR0aFwiOjIwMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZwY3MuOTc0YTg1MGQucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/pcs.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/tcl.png":
/*!************************************!*\
  !*** ./src/images/leagues/tcl.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/tcl.e3cd1638.png\",\"height\":1200,\"width\":1200,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Ftcl.e3cd1638.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy90Y2wucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDRMQUE0TCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvdGNsLnBuZz9mNzEwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS90Y2wuZTNjZDE2MzgucG5nXCIsXCJoZWlnaHRcIjoxMjAwLFwid2lkdGhcIjoxMjAwLFwiYmx1ckRhdGFVUkxcIjpcIi9fbmV4dC9pbWFnZT91cmw9JTJGX25leHQlMkZzdGF0aWMlMkZtZWRpYSUyRnRjbC5lM2NkMTYzOC5wbmcmdz04JnE9NzBcIixcImJsdXJXaWR0aFwiOjgsXCJibHVySGVpZ2h0XCI6OH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/tcl.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/ultraliga.png":
/*!******************************************!*\
  !*** ./src/images/leagues/ultraliga.png ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/ultraliga.f0c85705.png\",\"height\":220,\"width\":220,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fultraliga.f0c85705.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy91bHRyYWxpZ2EucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLHNNQUFzTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvdWx0cmFsaWdhLnBuZz8yYjIyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS91bHRyYWxpZ2EuZjBjODU3MDUucG5nXCIsXCJoZWlnaHRcIjoyMjAsXCJ3aWR0aFwiOjIyMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZ1bHRyYWxpZ2EuZjBjODU3MDUucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/ultraliga.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/images/leagues/vcs.png":
/*!************************************!*\
  !*** ./src/images/leagues/vcs.png ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\"src\":\"/_next/static/media/vcs.2e68de55.png\",\"height\":220,\"width\":220,\"blurDataURL\":\"/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fvcs.2e68de55.png&w=8&q=70\",\"blurWidth\":8,\"blurHeight\":8});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9pbWFnZXMvbGVhZ3Vlcy92Y3MucG5nIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxDQUFDLDBMQUEwTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaW1hZ2VzL2xlYWd1ZXMvdmNzLnBuZz8xZDcxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcInNyY1wiOlwiL19uZXh0L3N0YXRpYy9tZWRpYS92Y3MuMmU2OGRlNTUucG5nXCIsXCJoZWlnaHRcIjoyMjAsXCJ3aWR0aFwiOjIyMCxcImJsdXJEYXRhVVJMXCI6XCIvX25leHQvaW1hZ2U/dXJsPSUyRl9uZXh0JTJGc3RhdGljJTJGbWVkaWElMkZ2Y3MuMmU2OGRlNTUucG5nJnc9OCZxPTcwXCIsXCJibHVyV2lkdGhcIjo4LFwiYmx1ckhlaWdodFwiOjh9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/images/leagues/vcs.png\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/LeagueBar.tsx":
/*!**************************************!*\
  !*** ./src/components/LeagueBar.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! styled-components */ \"(app-pages-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../store */ \"(app-pages-browser)/./src/store/index.tsx\");\n/* harmony import */ var mobx_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! mobx-react */ \"(app-pages-browser)/./node_modules/mobx-react-lite/es/index.js\");\n\nfunction _templateObject() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  width: 100%;\\n  height: 60px;\\n  border-bottom: 1px solid black;\\n\\n  &:hover {\\n    background-color: #e8e8e8 !important;\\n  }\\n\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n\"\n    ]);\n    _templateObject1 = function() {\n        return data;\n    };\n    return data;\n}\n\n\n\n\nconst League = styled_components__WEBPACK_IMPORTED_MODULE_3__[\"default\"].div(_templateObject());\n_c = League;\nconst Logo = styled_components__WEBPACK_IMPORTED_MODULE_3__[\"default\"].div(_templateObject1());\n_c1 = Logo;\nconst LeagueBar = (props)=>{\n    const leagueLogo = (leagueName)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Logo, {\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"img\", {\n                style: {\n                    objectFit: \"contain\",\n                    width: \"90%\",\n                    height: \"90%\"\n                },\n                src: __webpack_require__(\"(app-pages-browser)/./src/images/leagues sync recursive ^\\\\.\\\\/.*\\\\.png$\")(\"./\".concat(leagueName.toLowerCase(), \".png\")).default,\n                alt: \"\".concat(leagueName)\n            }, void 0, false, {\n                fileName: \"/Users/carlisle/Desktop/Projects/lol-betting/src/components/LeagueBar.tsx\",\n                lineNumber: 33,\n                columnNumber: 7\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/carlisle/Desktop/Projects/lol-betting/src/components/LeagueBar.tsx\",\n            lineNumber: 32,\n            columnNumber: 5\n        }, undefined);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(mobx_react__WEBPACK_IMPORTED_MODULE_4__.Observer, {\n        children: ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                children: props.leagues && props.leagues.map((league, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(League, {\n                        style: {\n                            backgroundColor: league.id === _store__WEBPACK_IMPORTED_MODULE_2__[\"default\"].selectedLeague ? \"gold\" : \"unset\"\n                        },\n                        onClick: ()=>{\n                            if (league.id !== _store__WEBPACK_IMPORTED_MODULE_2__[\"default\"].selectedLeague && props.upcomingGames.filter((game)=>game.league_id === league.id).length > 0) {\n                                _store__WEBPACK_IMPORTED_MODULE_2__[\"default\"].updateSelectedTeamOne(props.upcomingGames.filter((game)=>game.league_id === league.id)[0].blue_team);\n                                _store__WEBPACK_IMPORTED_MODULE_2__[\"default\"].updateSelectedTeamTwo(props.upcomingGames.filter((game)=>game.league_id === league.id)[0].red_team);\n                            } else if (league.id !== _store__WEBPACK_IMPORTED_MODULE_2__[\"default\"].selectedLeague && props.upcomingGames.filter((game)=>game.league_id === league.id).length === 0) {\n                                _store__WEBPACK_IMPORTED_MODULE_2__[\"default\"].updateSelectedTeamOne(props.games.filter((game)=>game.league_id === league.id)[0].blue_team);\n                                _store__WEBPACK_IMPORTED_MODULE_2__[\"default\"].updateSelectedTeamTwo(props.games.filter((game)=>game.league_id === league.id)[0].red_team);\n                            }\n                            _store__WEBPACK_IMPORTED_MODULE_2__[\"default\"].updateSelectedLeague(league.id);\n                        },\n                        children: leagueLogo(league.name)\n                    }, index, false, {\n                        fileName: \"/Users/carlisle/Desktop/Projects/lol-betting/src/components/LeagueBar.tsx\",\n                        lineNumber: 53,\n                        columnNumber: 15\n                    }, undefined))\n            }, void 0, false)\n    }, void 0, false, {\n        fileName: \"/Users/carlisle/Desktop/Projects/lol-betting/src/components/LeagueBar.tsx\",\n        lineNumber: 48,\n        columnNumber: 5\n    }, undefined);\n};\n_c2 = LeagueBar;\n/* harmony default export */ __webpack_exports__[\"default\"] = (LeagueBar);\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"League\");\n$RefreshReg$(_c1, \"Logo\");\n$RefreshReg$(_c2, \"LeagueBar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xlYWd1ZUJhci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDTjtBQUNLO0FBRXRDLE1BQU1HLFNBQVNILHlEQUFNQSxDQUFDSSxHQUFHO0tBQW5CRDtBQWFOLE1BQU1FLE9BQU9MLHlEQUFNQSxDQUFDSSxHQUFHO01BQWpCQztBQVlOLE1BQU1DLFlBQVksQ0FBQ0M7SUFDakIsTUFBTUMsYUFBYSxDQUFDQywyQkFDbEIsOERBQUNKO3NCQUNDLDRFQUFDSztnQkFDQ0MsT0FBTztvQkFDTEMsV0FBVztvQkFDWEMsT0FBTztvQkFDUEMsUUFBUTtnQkFDVjtnQkFDQUMsS0FDRUMsZ0dBQVEsS0FBOEMsT0FBekJQLFdBQVdRLFdBQVcsSUFBRyxTQUFPQyxPQUFPO2dCQUV0RUMsS0FBSyxHQUFjLE9BQVhWOzs7Ozs7Ozs7OztJQUtkLHFCQUNFLDhEQUFDUCxnREFBUUE7a0JBQ04sa0JBQ0M7MEJBQ0dLLE1BQU1hLE9BQU8sSUFDWmIsTUFBTWEsT0FBTyxDQUFDQyxHQUFHLENBQUMsQ0FBQ0MsUUFBYUMsc0JBQzlCLDhEQUFDcEI7d0JBQ0NRLE9BQU87NEJBQ0xhLGlCQUNFRixPQUFPRyxFQUFFLEtBQUt4Qiw4Q0FBU0EsQ0FBQ3lCLGNBQWMsR0FBRyxTQUFTO3dCQUN0RDt3QkFFQUMsU0FBUzs0QkFDUCxJQUNFTCxPQUFPRyxFQUFFLEtBQUt4Qiw4Q0FBU0EsQ0FBQ3lCLGNBQWMsSUFDdENuQixNQUFNcUIsYUFBYSxDQUFDQyxNQUFNLENBQ3hCLENBQUNDLE9BQWNBLEtBQUtDLFNBQVMsS0FBS1QsT0FBT0csRUFBRSxFQUMzQ08sTUFBTSxHQUFHLEdBQ1g7Z0NBQ0EvQiw4Q0FBU0EsQ0FBQ2dDLHFCQUFxQixDQUM3QjFCLE1BQU1xQixhQUFhLENBQUNDLE1BQU0sQ0FDeEIsQ0FBQ0MsT0FBY0EsS0FBS0MsU0FBUyxLQUFLVCxPQUFPRyxFQUFFLENBQzVDLENBQUMsRUFBRSxDQUFDUyxTQUFTO2dDQUVoQmpDLDhDQUFTQSxDQUFDa0MscUJBQXFCLENBQzdCNUIsTUFBTXFCLGFBQWEsQ0FBQ0MsTUFBTSxDQUN4QixDQUFDQyxPQUFjQSxLQUFLQyxTQUFTLEtBQUtULE9BQU9HLEVBQUUsQ0FDNUMsQ0FBQyxFQUFFLENBQUNXLFFBQVE7NEJBRWpCLE9BQU8sSUFDTGQsT0FBT0csRUFBRSxLQUFLeEIsOENBQVNBLENBQUN5QixjQUFjLElBQ3RDbkIsTUFBTXFCLGFBQWEsQ0FBQ0MsTUFBTSxDQUN4QixDQUFDQyxPQUFjQSxLQUFLQyxTQUFTLEtBQUtULE9BQU9HLEVBQUUsRUFDM0NPLE1BQU0sS0FBSyxHQUNiO2dDQUNBL0IsOENBQVNBLENBQUNnQyxxQkFBcUIsQ0FDN0IxQixNQUFNOEIsS0FBSyxDQUFDUixNQUFNLENBQ2hCLENBQUNDLE9BQWNBLEtBQUtDLFNBQVMsS0FBS1QsT0FBT0csRUFBRSxDQUM1QyxDQUFDLEVBQUUsQ0FBQ1MsU0FBUztnQ0FFaEJqQyw4Q0FBU0EsQ0FBQ2tDLHFCQUFxQixDQUM3QjVCLE1BQU04QixLQUFLLENBQUNSLE1BQU0sQ0FDaEIsQ0FBQ0MsT0FBY0EsS0FBS0MsU0FBUyxLQUFLVCxPQUFPRyxFQUFFLENBQzVDLENBQUMsRUFBRSxDQUFDVyxRQUFROzRCQUVqQjs0QkFFQW5DLDhDQUFTQSxDQUFDcUMsb0JBQW9CLENBQUNoQixPQUFPRyxFQUFFO3dCQUMxQztrQ0FFQ2pCLFdBQVdjLE9BQU9pQixJQUFJO3VCQXZDbEJoQjs7Ozs7Ozs7Ozs7QUE4Q3JCO01BMUVNakI7QUE0RU4sK0RBQWVBLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTGVhZ3VlQmFyLnRzeD8yYmM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZWQgZnJvbSBcInN0eWxlZC1jb21wb25lbnRzXCI7XG5pbXBvcnQgUm9vdFN0b3JlIGZyb20gXCIuLi9zdG9yZVwiO1xuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tIFwibW9ieC1yZWFjdFwiO1xuXG5jb25zdCBMZWFndWUgPSBzdHlsZWQuZGl2YFxuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogNjBweDtcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIGJsYWNrO1xuXG4gICY6aG92ZXIge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNlOGU4ZTggIWltcG9ydGFudDtcbiAgfVxuYDtcblxuY29uc3QgTG9nbyA9IHN0eWxlZC5kaXZgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuYDtcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgbGVhZ3VlczogYW55O1xuICBnYW1lczogYW55O1xuICB1cGNvbWluZ0dhbWVzOiBhbnk7XG59XG5cbmNvbnN0IExlYWd1ZUJhciA9IChwcm9wczogUHJvcHMpID0+IHtcbiAgY29uc3QgbGVhZ3VlTG9nbyA9IChsZWFndWVOYW1lOiBhbnkpID0+IChcbiAgICA8TG9nbz5cbiAgICAgIDxpbWdcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBvYmplY3RGaXQ6IFwiY29udGFpblwiLFxuICAgICAgICAgIHdpZHRoOiBcIjkwJVwiLFxuICAgICAgICAgIGhlaWdodDogXCI5MCVcIixcbiAgICAgICAgfX1cbiAgICAgICAgc3JjPXtcbiAgICAgICAgICByZXF1aXJlKGAuLi9pbWFnZXMvbGVhZ3Vlcy8ke2xlYWd1ZU5hbWUudG9Mb3dlckNhc2UoKX0ucG5nYCkuZGVmYXVsdFxuICAgICAgICB9XG4gICAgICAgIGFsdD17YCR7bGVhZ3VlTmFtZX1gfVxuICAgICAgLz5cbiAgICA8L0xvZ28+XG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8T2JzZXJ2ZXI+XG4gICAgICB7KCkgPT4gKFxuICAgICAgICA8PlxuICAgICAgICAgIHtwcm9wcy5sZWFndWVzICYmXG4gICAgICAgICAgICBwcm9wcy5sZWFndWVzLm1hcCgobGVhZ3VlOiBhbnksIGluZGV4OiBudW1iZXIpID0+IChcbiAgICAgICAgICAgICAgPExlYWd1ZVxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6XG4gICAgICAgICAgICAgICAgICAgIGxlYWd1ZS5pZCA9PT0gUm9vdFN0b3JlLnNlbGVjdGVkTGVhZ3VlID8gXCJnb2xkXCIgOiBcInVuc2V0XCIsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbGVhZ3VlLmlkICE9PSBSb290U3RvcmUuc2VsZWN0ZWRMZWFndWUgJiZcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMudXBjb21pbmdHYW1lcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgKGdhbWU6IGFueSkgPT4gZ2FtZS5sZWFndWVfaWQgPT09IGxlYWd1ZS5pZFxuICAgICAgICAgICAgICAgICAgICApLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBSb290U3RvcmUudXBkYXRlU2VsZWN0ZWRUZWFtT25lKFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BzLnVwY29taW5nR2FtZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGdhbWU6IGFueSkgPT4gZ2FtZS5sZWFndWVfaWQgPT09IGxlYWd1ZS5pZFxuICAgICAgICAgICAgICAgICAgICAgIClbMF0uYmx1ZV90ZWFtXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIFJvb3RTdG9yZS51cGRhdGVTZWxlY3RlZFRlYW1Ud28oXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcHMudXBjb21pbmdHYW1lcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAoZ2FtZTogYW55KSA9PiBnYW1lLmxlYWd1ZV9pZCA9PT0gbGVhZ3VlLmlkXG4gICAgICAgICAgICAgICAgICAgICAgKVswXS5yZWRfdGVhbVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbGVhZ3VlLmlkICE9PSBSb290U3RvcmUuc2VsZWN0ZWRMZWFndWUgJiZcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMudXBjb21pbmdHYW1lcy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICAgKGdhbWU6IGFueSkgPT4gZ2FtZS5sZWFndWVfaWQgPT09IGxlYWd1ZS5pZFxuICAgICAgICAgICAgICAgICAgICApLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIFJvb3RTdG9yZS51cGRhdGVTZWxlY3RlZFRlYW1PbmUoXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcHMuZ2FtZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGdhbWU6IGFueSkgPT4gZ2FtZS5sZWFndWVfaWQgPT09IGxlYWd1ZS5pZFxuICAgICAgICAgICAgICAgICAgICAgIClbMF0uYmx1ZV90ZWFtXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIFJvb3RTdG9yZS51cGRhdGVTZWxlY3RlZFRlYW1Ud28oXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcHMuZ2FtZXMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGdhbWU6IGFueSkgPT4gZ2FtZS5sZWFndWVfaWQgPT09IGxlYWd1ZS5pZFxuICAgICAgICAgICAgICAgICAgICAgIClbMF0ucmVkX3RlYW1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgUm9vdFN0b3JlLnVwZGF0ZVNlbGVjdGVkTGVhZ3VlKGxlYWd1ZS5pZCk7XG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtsZWFndWVMb2dvKGxlYWd1ZS5uYW1lKX1cbiAgICAgICAgICAgICAgPC9MZWFndWU+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgPC8+XG4gICAgICApfVxuICAgIDwvT2JzZXJ2ZXI+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMZWFndWVCYXI7XG4iXSwibmFtZXMiOlsic3R5bGVkIiwiUm9vdFN0b3JlIiwiT2JzZXJ2ZXIiLCJMZWFndWUiLCJkaXYiLCJMb2dvIiwiTGVhZ3VlQmFyIiwicHJvcHMiLCJsZWFndWVMb2dvIiwibGVhZ3VlTmFtZSIsImltZyIsInN0eWxlIiwib2JqZWN0Rml0Iiwid2lkdGgiLCJoZWlnaHQiLCJzcmMiLCJyZXF1aXJlIiwidG9Mb3dlckNhc2UiLCJkZWZhdWx0IiwiYWx0IiwibGVhZ3VlcyIsIm1hcCIsImxlYWd1ZSIsImluZGV4IiwiYmFja2dyb3VuZENvbG9yIiwiaWQiLCJzZWxlY3RlZExlYWd1ZSIsIm9uQ2xpY2siLCJ1cGNvbWluZ0dhbWVzIiwiZmlsdGVyIiwiZ2FtZSIsImxlYWd1ZV9pZCIsImxlbmd0aCIsInVwZGF0ZVNlbGVjdGVkVGVhbU9uZSIsImJsdWVfdGVhbSIsInVwZGF0ZVNlbGVjdGVkVGVhbVR3byIsInJlZF90ZWFtIiwiZ2FtZXMiLCJ1cGRhdGVTZWxlY3RlZExlYWd1ZSIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/LeagueBar.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/pages/MatchStats/index.tsx":
/*!****************************************!*\
  !*** ./src/pages/MatchStats/index.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! styled-components */ \"(app-pages-browser)/./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var _components_LeagueBar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/LeagueBar */ \"(app-pages-browser)/./src/components/LeagueBar.tsx\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var mobx_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! mobx-react */ \"(app-pages-browser)/./node_modules/mobx-react/dist/mobxreact.esm.js\");\n/* harmony import */ var _utils_supabase__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/utils/supabase */ \"(app-pages-browser)/./src/utils/supabase.ts\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nfunction _templateObject() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n    display: flex;\\n    flex-direction: row;\\n\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n    width: 60px;\\n    height: 100vh;\\n    overflow: scroll;\\n    -ms-overflow-style: none;\\n    ::-webkit-scrollbar {\\n        display: none;\\n    }\\n\"\n    ]);\n    _templateObject1 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject2() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n    width: calc(100% - 18% - 60px);\\n    height: 100vh;\\n    border-left: 1px solid black;\\n    border-right: 1px solid black;\\n\"\n    ]);\n    _templateObject2 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject3() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n    display: flex;\\n    width: 100%;\\n    height: 85%;\\n\"\n    ]);\n    _templateObject3 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject4() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n    width: 100%;\\n    height: 100%;\\n\"\n    ]);\n    _templateObject4 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject5() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    height: 20%;\\n    width: 100%;\\n\"\n    ]);\n    _templateObject5 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject6() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    width: 100%;\\n    height: 80%;\\n\"\n    ]);\n    _templateObject6 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject7() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n    width: 100%;\\n    height: calc(15% - 1px);\\n    border-top: 1px solid black;\\n\"\n    ]);\n    _templateObject7 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject8() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"\\n    width: 18%;\\n    height: 100vh;\\n\"\n    ]);\n    _templateObject8 = function() {\n        return data;\n    };\n    return data;\n}\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nconst Container = styled_components__WEBPACK_IMPORTED_MODULE_5__[\"default\"].div(_templateObject());\n_c = Container;\nconst LeagueBarContainer = styled_components__WEBPACK_IMPORTED_MODULE_5__[\"default\"].div(_templateObject1());\n_c1 = LeagueBarContainer;\nconst CenterInformationContainer = styled_components__WEBPACK_IMPORTED_MODULE_5__[\"default\"].div(_templateObject2());\n_c2 = CenterInformationContainer;\nconst Teams = styled_components__WEBPACK_IMPORTED_MODULE_5__[\"default\"].div(_templateObject3());\nconst IndividualTeamContainer = styled_components__WEBPACK_IMPORTED_MODULE_5__[\"default\"].div(_templateObject4());\nconst TeamSelectContainer = styled_components__WEBPACK_IMPORTED_MODULE_5__[\"default\"].div(_templateObject5());\nconst TeamDataContainer = styled_components__WEBPACK_IMPORTED_MODULE_5__[\"default\"].div(_templateObject6());\nconst StatsAnalysis = styled_components__WEBPACK_IMPORTED_MODULE_5__[\"default\"].div(_templateObject7());\n_c3 = StatsAnalysis;\nconst MatchScheduleBarContainer = styled_components__WEBPACK_IMPORTED_MODULE_5__[\"default\"].div(_templateObject8());\nfunction MatchStats() {\n    _s();\n    const excludeLeagues = [\n        \"LPL\"\n    ];\n    const [leagues, setLeagues] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [teams, setTeams] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [upcomingGames, setUpcomingGames] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const [games, setGames] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(()=>{\n        const fetchLeagues = async ()=>{\n            const { data } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_4__.supabase.from(\"leagues\").select();\n            if (data) {\n                setTeams(data.filter((league)=>!excludeLeagues.includes(league.name)));\n                console.log(\"leagues: \", data);\n            }\n        };\n        const fetchTeams = async ()=>{\n            const { data } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_4__.supabase.from(\"teams\").select();\n            if (data) {\n                setTeams(data.filter((team)=>team.name !== \"Test\"));\n                console.log(\"teams: \", data);\n            }\n        };\n        const fetchUpcomingGames = async ()=>{\n            const { data } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_4__.supabase.from(\"upcoming\").select();\n            if (data) {\n                setUpcomingGames(data);\n                console.log(\"upcoming: \", data);\n            }\n        };\n        const fetchGames = async ()=>{\n            const { data } = await _utils_supabase__WEBPACK_IMPORTED_MODULE_4__.supabase.from(\"games\").select();\n            if (data) {\n                setGames(data);\n                console.log(\"games: \", data);\n            }\n        };\n        fetchLeagues();\n        fetchTeams();\n        fetchUpcomingGames();\n        fetchGames();\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(\"div\", {\n        className: \"App\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(Container, {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(LeagueBarContainer, {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(_components_LeagueBar__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                        leagues: leagues,\n                        upcomingGames: upcomingGames,\n                        games: games\n                    }, void 0, false, {\n                        fileName: \"/Users/carlisle/Desktop/Projects/lol-betting/src/pages/MatchStats/index.tsx\",\n                        lineNumber: 133,\n                        columnNumber: 21\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/carlisle/Desktop/Projects/lol-betting/src/pages/MatchStats/index.tsx\",\n                    lineNumber: 132,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(CenterInformationContainer, {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxDEV)(StatsAnalysis, {}, void 0, false, {\n                        fileName: \"/Users/carlisle/Desktop/Projects/lol-betting/src/pages/MatchStats/index.tsx\",\n                        lineNumber: 210,\n                        columnNumber: 21\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/carlisle/Desktop/Projects/lol-betting/src/pages/MatchStats/index.tsx\",\n                    lineNumber: 140,\n                    columnNumber: 17\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/carlisle/Desktop/Projects/lol-betting/src/pages/MatchStats/index.tsx\",\n            lineNumber: 130,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/carlisle/Desktop/Projects/lol-betting/src/pages/MatchStats/index.tsx\",\n        lineNumber: 129,\n        columnNumber: 9\n    }, this);\n}\n_s(MatchStats, \"BkQlgPFcA94ZgSBNTdDFV5FQPmU=\");\n_c4 = MatchStats;\n/* harmony default export */ __webpack_exports__[\"default\"] = (_c5 = (0,mobx_react__WEBPACK_IMPORTED_MODULE_6__.observer)(MatchStats));\nvar _c, _c1, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"Container\");\n$RefreshReg$(_c1, \"LeagueBarContainer\");\n$RefreshReg$(_c2, \"CenterInformationContainer\");\n$RefreshReg$(_c3, \"StatsAnalysis\");\n$RefreshReg$(_c4, \"MatchStats\");\n$RefreshReg$(_c5, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9wYWdlcy9NYXRjaFN0YXRzL2luZGV4LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFc0M7QUFFWTtBQUlQO0FBRUk7QUFDSjtBQUUzQyxNQUFNTSxZQUFZTix5REFBTUEsQ0FBQ08sR0FBRztLQUF0QkQ7QUFLTixNQUFNRSxxQkFBcUJSLHlEQUFNQSxDQUFDTyxHQUFHO01BQS9CQztBQVVOLE1BQU1DLDZCQUE2QlQseURBQU1BLENBQUNPLEdBQUc7TUFBdkNFO0FBT04sTUFBTUMsUUFBUVYseURBQU1BLENBQUNPLEdBQUc7QUFNeEIsTUFBTUksMEJBQTBCWCx5REFBTUEsQ0FBQ08sR0FBRztBQUsxQyxNQUFNSyxzQkFBc0JaLHlEQUFNQSxDQUFDTyxHQUFHO0FBUXRDLE1BQU1NLG9CQUFvQmIseURBQU1BLENBQUNPLEdBQUc7QUFRcEMsTUFBTU8sZ0JBQWdCZCx5REFBTUEsQ0FBQ08sR0FBRztNQUExQk87QUFNTixNQUFNQyw0QkFBNEJmLHlEQUFNQSxDQUFDTyxHQUFHO0FBSzVDLFNBQVNTOztJQUNMLE1BQU1DLGlCQUFpQjtRQUFDO0tBQU07SUFDOUIsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUdoQiwrQ0FBUUEsQ0FBTTtJQUM1QyxNQUFNLENBQUNpQixPQUFPQyxTQUFTLEdBQUdsQiwrQ0FBUUEsQ0FBTTtJQUN4QyxNQUFNLENBQUNtQixlQUFlQyxpQkFBaUIsR0FBR3BCLCtDQUFRQSxDQUFNO0lBQ3hELE1BQU0sQ0FBQ3FCLE9BQU9DLFNBQVMsR0FBR3RCLCtDQUFRQSxDQUFNO0lBRXhDRCxnREFBU0EsQ0FBQztRQUNOLE1BQU13QixlQUFlO1lBQ2pCLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUcsTUFBTXRCLHFEQUFRQSxDQUFDdUIsSUFBSSxDQUFDLFdBQVdDLE1BQU07WUFFdEQsSUFBSUYsTUFBTTtnQkFDTk4sU0FDSU0sS0FBS0csTUFBTSxDQUNQLENBQUNDLFNBQWdCLENBQUNkLGVBQWVlLFFBQVEsQ0FBQ0QsT0FBT0UsSUFBSTtnQkFHN0RDLFFBQVFDLEdBQUcsQ0FBQyxhQUFhUjtZQUM3QjtRQUNKO1FBRUEsTUFBTVMsYUFBYTtZQUNmLE1BQU0sRUFBRVQsSUFBSSxFQUFFLEdBQUcsTUFBTXRCLHFEQUFRQSxDQUFDdUIsSUFBSSxDQUFDLFNBQVNDLE1BQU07WUFFcEQsSUFBSUYsTUFBTTtnQkFDTk4sU0FBU00sS0FBS0csTUFBTSxDQUFDLENBQUNPLE9BQWNBLEtBQUtKLElBQUksS0FBSztnQkFDbERDLFFBQVFDLEdBQUcsQ0FBQyxXQUFXUjtZQUMzQjtRQUNKO1FBRUEsTUFBTVcscUJBQXFCO1lBQ3ZCLE1BQU0sRUFBRVgsSUFBSSxFQUFFLEdBQUcsTUFBTXRCLHFEQUFRQSxDQUFDdUIsSUFBSSxDQUFDLFlBQVlDLE1BQU07WUFFdkQsSUFBSUYsTUFBTTtnQkFDTkosaUJBQWlCSTtnQkFDakJPLFFBQVFDLEdBQUcsQ0FBQyxjQUFjUjtZQUM5QjtRQUNKO1FBRUEsTUFBTVksYUFBYTtZQUNmLE1BQU0sRUFBRVosSUFBSSxFQUFFLEdBQUcsTUFBTXRCLHFEQUFRQSxDQUFDdUIsSUFBSSxDQUFDLFNBQVNDLE1BQU07WUFFcEQsSUFBSUYsTUFBTTtnQkFDTkYsU0FBU0U7Z0JBQ1RPLFFBQVFDLEdBQUcsQ0FBQyxXQUFXUjtZQUMzQjtRQUNKO1FBRUFEO1FBQ0FVO1FBQ0FFO1FBQ0FDO0lBQ0osR0FBRyxFQUFFO0lBRUwscUJBQ0ksOERBQUNoQztRQUFJaUMsV0FBVTtrQkFDWCw0RUFBQ2xDOzs4QkFFRyw4REFBQ0U7OEJBQ0csNEVBQUNQLDZEQUFTQTt3QkFDTmlCLFNBQVNBO3dCQUNUSSxlQUFlQTt3QkFDZkUsT0FBT0E7Ozs7Ozs7Ozs7OzhCQUlmLDhEQUFDZjs4QkFzRUcsNEVBQUNLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQnJCO0dBM0pTRTtNQUFBQTtBQTZKVCwrREFBZSxNQUFBWixvREFBUUEsQ0FBQ1ksV0FBV0EsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvTWF0Y2hTdGF0cy9pbmRleC50c3g/ZWY5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgc3R5bGVkIGZyb20gXCJzdHlsZWQtY29tcG9uZW50c1wiXG5pbXBvcnQgTWF0Y2hTY2hlZHVsZUJhciBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy9NYXRjaFNjaGVkdWxlQmFyXCJcbmltcG9ydCBMZWFndWVCYXIgZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvTGVhZ3VlQmFyXCJcbmltcG9ydCBUZWFtU2VsZWN0IGZyb20gXCIuLi8uLi9jb21wb25lbnRzL1RlYW1TZWxlY3RcIlxuaW1wb3J0IFRlYW1NYXRjaERhdGEgZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvVGVhbU1hdGNoRGF0YVwiXG5pbXBvcnQgU3RhdGlzdGljYWxBbmFseXNpcyBmcm9tIFwiLi4vLi4vY29tcG9uZW50cy9TdGF0aXN0aWNhbEFuYWx5c2lzXCJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IFJvb3RTdG9yZSBmcm9tIFwiLi4vLi4vc3RvcmVcIlxuaW1wb3J0IHsgb2JzZXJ2ZXIsIE9ic2VydmVyIH0gZnJvbSBcIm1vYngtcmVhY3RcIlxuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tIFwiQC91dGlscy9zdXBhYmFzZVwiXG5cbmNvbnN0IENvbnRhaW5lciA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuYFxuXG5jb25zdCBMZWFndWVCYXJDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiA2MHB4O1xuICAgIGhlaWdodDogMTAwdmg7XG4gICAgb3ZlcmZsb3c6IHNjcm9sbDtcbiAgICAtbXMtb3ZlcmZsb3ctc3R5bGU6IG5vbmU7XG4gICAgOjotd2Via2l0LXNjcm9sbGJhciB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuYFxuXG5jb25zdCBDZW50ZXJJbmZvcm1hdGlvbkNvbnRhaW5lciA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IGNhbGMoMTAwJSAtIDE4JSAtIDYwcHgpO1xuICAgIGhlaWdodDogMTAwdmg7XG4gICAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCBibGFjaztcbiAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCBibGFjaztcbmBcblxuY29uc3QgVGVhbXMgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiA4NSU7XG5gXG5cbmNvbnN0IEluZGl2aWR1YWxUZWFtQ29udGFpbmVyID0gc3R5bGVkLmRpdmBcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDEwMCU7XG5gXG5cbmNvbnN0IFRlYW1TZWxlY3RDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBoZWlnaHQ6IDIwJTtcbiAgICB3aWR0aDogMTAwJTtcbmBcblxuY29uc3QgVGVhbURhdGFDb250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IDgwJTtcbmBcblxuY29uc3QgU3RhdHNBbmFseXNpcyA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiBjYWxjKDE1JSAtIDFweCk7XG4gICAgYm9yZGVyLXRvcDogMXB4IHNvbGlkIGJsYWNrO1xuYFxuXG5jb25zdCBNYXRjaFNjaGVkdWxlQmFyQ29udGFpbmVyID0gc3R5bGVkLmRpdmBcbiAgICB3aWR0aDogMTglO1xuICAgIGhlaWdodDogMTAwdmg7XG5gXG5cbmZ1bmN0aW9uIE1hdGNoU3RhdHMoKSB7XG4gICAgY29uc3QgZXhjbHVkZUxlYWd1ZXMgPSBbXCJMUExcIl1cbiAgICBjb25zdCBbbGVhZ3Vlcywgc2V0TGVhZ3Vlc10gPSB1c2VTdGF0ZTxhbnk+KG51bGwpXG4gICAgY29uc3QgW3RlYW1zLCBzZXRUZWFtc10gPSB1c2VTdGF0ZTxhbnk+KG51bGwpXG4gICAgY29uc3QgW3VwY29taW5nR2FtZXMsIHNldFVwY29taW5nR2FtZXNdID0gdXNlU3RhdGU8YW55PihudWxsKVxuICAgIGNvbnN0IFtnYW1lcywgc2V0R2FtZXNdID0gdXNlU3RhdGU8YW55PihudWxsKVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZmV0Y2hMZWFndWVzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwibGVhZ3Vlc1wiKS5zZWxlY3QoKVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHNldFRlYW1zKFxuICAgICAgICAgICAgICAgICAgICBkYXRhLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIChsZWFndWU6IGFueSkgPT4gIWV4Y2x1ZGVMZWFndWVzLmluY2x1ZGVzKGxlYWd1ZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibGVhZ3VlczogXCIsIGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmZXRjaFRlYW1zID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKFwidGVhbXNcIikuc2VsZWN0KClcblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBzZXRUZWFtcyhkYXRhLmZpbHRlcigodGVhbTogYW55KSA9PiB0ZWFtLm5hbWUgIT09IFwiVGVzdFwiKSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlYW1zOiBcIiwgZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZldGNoVXBjb21pbmdHYW1lcyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcInVwY29taW5nXCIpLnNlbGVjdCgpXG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgc2V0VXBjb21pbmdHYW1lcyhkYXRhKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidXBjb21pbmc6IFwiLCBkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmV0Y2hHYW1lcyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbShcImdhbWVzXCIpLnNlbGVjdCgpXG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgc2V0R2FtZXMoZGF0YSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImdhbWVzOiBcIiwgZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZldGNoTGVhZ3VlcygpXG4gICAgICAgIGZldGNoVGVhbXMoKVxuICAgICAgICBmZXRjaFVwY29taW5nR2FtZXMoKVxuICAgICAgICBmZXRjaEdhbWVzKClcbiAgICB9LCBbXSlcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiQXBwXCI+XG4gICAgICAgICAgICA8Q29udGFpbmVyPlxuICAgICAgICAgICAgICAgIHsvKiBMZWZ0IFNpZGUgQmFyICovfVxuICAgICAgICAgICAgICAgIDxMZWFndWVCYXJDb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgIDxMZWFndWVCYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWd1ZXM9e2xlYWd1ZXN9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGNvbWluZ0dhbWVzPXt1cGNvbWluZ0dhbWVzfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FtZXM9e2dhbWVzfVxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvTGVhZ3VlQmFyQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgIHsvKiBDZW50ZXIgSW5mb3JtYXRpb24gKi99XG4gICAgICAgICAgICAgICAgPENlbnRlckluZm9ybWF0aW9uQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICB7LyogPFRlYW1zPlxuICAgICAgICAgICAgICAgICAgICAgICAgPEluZGl2aWR1YWxUZWFtQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxUZWFtU2VsZWN0Q29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8T2JzZXJ2ZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7KCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxUZWFtU2VsZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlYW1OdW1iZXI9ezF9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlYW1zPXt0ZWFtc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRUZWFtPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJvb3RTdG9yZS5zZWxlY3RlZFRlYW1PbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlclNlbGVjdGVkVGVhbT17XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSb290U3RvcmUuc2VsZWN0ZWRUZWFtVHdvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9PYnNlcnZlcj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L1RlYW1TZWxlY3RDb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFRlYW1EYXRhQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8T2JzZXJ2ZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7KCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxUZWFtTWF0Y2hEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlYWd1ZUlkPXtSb290U3RvcmUuc2VsZWN0ZWRMZWFndWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlYW1OdW1iZXI9ezF9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVGVhbT17XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSb290U3RvcmUuc2VsZWN0ZWRUZWFtT25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FtZXM9e2dhbWVzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWFtcz17dGVhbXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvT2JzZXJ2ZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9UZWFtRGF0YUNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvSW5kaXZpZHVhbFRlYW1Db250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8SW5kaXZpZHVhbFRlYW1Db250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFRlYW1TZWxlY3RDb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxPYnNlcnZlcj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsoKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFRlYW1TZWxlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVhbU51bWJlcj17Mn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVhbXM9e3RlYW1zfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFRlYW09e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUm9vdFN0b3JlLnNlbGVjdGVkVGVhbVR3b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyU2VsZWN0ZWRUZWFtPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJvb3RTdG9yZS5zZWxlY3RlZFRlYW1PbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L09ic2VydmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvVGVhbVNlbGVjdENvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8VGVhbURhdGFDb250YWluZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxPYnNlcnZlcj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsoKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFRlYW1NYXRjaERhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVhZ3VlSWQ9e1Jvb3RTdG9yZS5zZWxlY3RlZExlYWd1ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVhbU51bWJlcj17Mn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRUZWFtPXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJvb3RTdG9yZS5zZWxlY3RlZFRlYW1Ud29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYW1lcz17Z2FtZXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlYW1zPXt0ZWFtc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9PYnNlcnZlcj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L1RlYW1EYXRhQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9JbmRpdmlkdWFsVGVhbUNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICAgICAgPC9UZWFtcz4gKi99XG4gICAgICAgICAgICAgICAgICAgIHsvKiBCb3R0b20gQmFyICovfVxuICAgICAgICAgICAgICAgICAgICA8U3RhdHNBbmFseXNpcz5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvKiA8U3RhdGlzdGljYWxBbmFseXNpcyB0ZWFtcz17dGVhbXN9IC8+ICovfVxuICAgICAgICAgICAgICAgICAgICA8L1N0YXRzQW5hbHlzaXM+XG4gICAgICAgICAgICAgICAgPC9DZW50ZXJJbmZvcm1hdGlvbkNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICB7LyogUmlnaHQgU2lkZSBCYXIgKi99XG4gICAgICAgICAgICAgICAgey8qIDxPYnNlcnZlcj5cbiAgICAgICAgICAgICAgICAgICAgeygpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxNYXRjaFNjaGVkdWxlQmFyQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxNYXRjaFNjaGVkdWxlQmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkTGVhZ3VlPXtSb290U3RvcmUuc2VsZWN0ZWRMZWFndWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwY29taW5nR2FtZXM9e3VwY29taW5nR2FtZXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlYW1zPXt0ZWFtc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9NYXRjaFNjaGVkdWxlQmFyQ29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvT2JzZXJ2ZXI+ICovfVxuICAgICAgICAgICAgPC9Db250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JzZXJ2ZXIoTWF0Y2hTdGF0cylcbiJdLCJuYW1lcyI6WyJzdHlsZWQiLCJMZWFndWVCYXIiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIm9ic2VydmVyIiwic3VwYWJhc2UiLCJDb250YWluZXIiLCJkaXYiLCJMZWFndWVCYXJDb250YWluZXIiLCJDZW50ZXJJbmZvcm1hdGlvbkNvbnRhaW5lciIsIlRlYW1zIiwiSW5kaXZpZHVhbFRlYW1Db250YWluZXIiLCJUZWFtU2VsZWN0Q29udGFpbmVyIiwiVGVhbURhdGFDb250YWluZXIiLCJTdGF0c0FuYWx5c2lzIiwiTWF0Y2hTY2hlZHVsZUJhckNvbnRhaW5lciIsIk1hdGNoU3RhdHMiLCJleGNsdWRlTGVhZ3VlcyIsImxlYWd1ZXMiLCJzZXRMZWFndWVzIiwidGVhbXMiLCJzZXRUZWFtcyIsInVwY29taW5nR2FtZXMiLCJzZXRVcGNvbWluZ0dhbWVzIiwiZ2FtZXMiLCJzZXRHYW1lcyIsImZldGNoTGVhZ3VlcyIsImRhdGEiLCJmcm9tIiwic2VsZWN0IiwiZmlsdGVyIiwibGVhZ3VlIiwiaW5jbHVkZXMiLCJuYW1lIiwiY29uc29sZSIsImxvZyIsImZldGNoVGVhbXMiLCJ0ZWFtIiwiZmV0Y2hVcGNvbWluZ0dhbWVzIiwiZmV0Y2hHYW1lcyIsImNsYXNzTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/pages/MatchStats/index.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/store/index.tsx":
/*!*****************************!*\
  !*** ./src/store/index.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mobx-state-tree */ \"(app-pages-browser)/./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js\");\n/* harmony import */ var _models_matchBet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models/matchBet */ \"(app-pages-browser)/./src/store/models/matchBet.tsx\");\n\n\nconst Store = mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__.types.model({\n    selectedLeague: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__.types.maybeNull(mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__.types.number),\n    selectedTeamOne: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__.types.maybeNull(mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__.types.string),\n    selectedTeamTwo: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__.types.maybeNull(mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__.types.string),\n    matchBets: mobx_state_tree__WEBPACK_IMPORTED_MODULE_1__.types.array(_models_matchBet__WEBPACK_IMPORTED_MODULE_0__.MatchBet)\n}).actions(_c = (self)=>({\n        updateSelectedLeague: (leagueId)=>{\n            self.selectedLeague = leagueId;\n        },\n        updateSelectedTeamOne: (team)=>{\n            self.selectedTeamOne = team;\n        },\n        updateSelectedTeamTwo: (team)=>{\n            self.selectedTeamTwo = team;\n        },\n        createMatchBet: (matchBet)=>{\n            self.matchBets.push(matchBet);\n        },\n        deleteMatchBet: (index)=>{\n            self.matchBets.splice(index, 1);\n        }\n    }));\n_c1 = Store;\nconst RootStore = Store.create();\n/* harmony default export */ __webpack_exports__[\"default\"] = (RootStore);\nvar _c, _c1;\n$RefreshReg$(_c, \"Store$types\\n\t.model({\\n\t\tselectedLeague: types.maybeNull(types.number),\\n\t\tselectedTeamOne: types.maybeNull(types.string),\\n\t\tselectedTeamTwo: types.maybeNull(types.string),\\n\t\tmatchBets: types.array(MatchBet),\\n\t})\\n\\n\t.actions\");\n$RefreshReg$(_c1, \"Store\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9pbmRleC50c3giLCJtYXBwaW5ncyI6Ijs7O0FBQWlEO0FBQ0w7QUFFNUMsTUFBTUUsUUFBUUYsa0RBQUtBLENBQ2pCRyxLQUFLLENBQUM7SUFDTkMsZ0JBQWdCSixrREFBS0EsQ0FBQ0ssU0FBUyxDQUFDTCxrREFBS0EsQ0FBQ00sTUFBTTtJQUM1Q0MsaUJBQWlCUCxrREFBS0EsQ0FBQ0ssU0FBUyxDQUFDTCxrREFBS0EsQ0FBQ1EsTUFBTTtJQUM3Q0MsaUJBQWlCVCxrREFBS0EsQ0FBQ0ssU0FBUyxDQUFDTCxrREFBS0EsQ0FBQ1EsTUFBTTtJQUM3Q0UsV0FBV1Ysa0RBQUtBLENBQUNXLEtBQUssQ0FBQ1Ysc0RBQVFBO0FBQ2hDLEdBRUNXLE9BQU8sTUFBQyxDQUFDQyxPQUFVO1FBQ25CQyxzQkFBc0IsQ0FBQ0M7WUFDdEJGLEtBQUtULGNBQWMsR0FBR1c7UUFDdkI7UUFDQUMsdUJBQXVCLENBQUNDO1lBQ3ZCSixLQUFLTixlQUFlLEdBQUdVO1FBQ3hCO1FBQ0FDLHVCQUF1QixDQUFDRDtZQUN2QkosS0FBS0osZUFBZSxHQUFHUTtRQUN4QjtRQUNBRSxnQkFBZ0IsQ0FBQ0M7WUFDaEJQLEtBQUtILFNBQVMsQ0FBQ1csSUFBSSxDQUFDRDtRQUNyQjtRQUNBRSxnQkFBZ0IsQ0FBQ0M7WUFDaEJWLEtBQUtILFNBQVMsQ0FBQ2MsTUFBTSxDQUFDRCxPQUFPO1FBQzlCO0lBQ0Q7O0FBRUQsTUFBTUUsWUFBWXZCLE1BQU13QixNQUFNO0FBRTlCLCtEQUFlRCxTQUFTQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdG9yZS9pbmRleC50c3g/M2U4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnN0YW5jZSwgdHlwZXMgfSBmcm9tICdtb2J4LXN0YXRlLXRyZWUnXG5pbXBvcnQgeyBNYXRjaEJldCB9IGZyb20gJy4vbW9kZWxzL21hdGNoQmV0J1xuXG5jb25zdCBTdG9yZSA9IHR5cGVzXG5cdC5tb2RlbCh7XG5cdFx0c2VsZWN0ZWRMZWFndWU6IHR5cGVzLm1heWJlTnVsbCh0eXBlcy5udW1iZXIpLFxuXHRcdHNlbGVjdGVkVGVhbU9uZTogdHlwZXMubWF5YmVOdWxsKHR5cGVzLnN0cmluZyksXG5cdFx0c2VsZWN0ZWRUZWFtVHdvOiB0eXBlcy5tYXliZU51bGwodHlwZXMuc3RyaW5nKSxcblx0XHRtYXRjaEJldHM6IHR5cGVzLmFycmF5KE1hdGNoQmV0KSxcblx0fSlcblxuXHQuYWN0aW9ucygoc2VsZikgPT4gKHtcblx0XHR1cGRhdGVTZWxlY3RlZExlYWd1ZTogKGxlYWd1ZUlkOiBudW1iZXIpID0+IHtcblx0XHRcdHNlbGYuc2VsZWN0ZWRMZWFndWUgPSBsZWFndWVJZFxuXHRcdH0sXG5cdFx0dXBkYXRlU2VsZWN0ZWRUZWFtT25lOiAodGVhbTogc3RyaW5nIHwgbnVsbCkgPT4ge1xuXHRcdFx0c2VsZi5zZWxlY3RlZFRlYW1PbmUgPSB0ZWFtXG5cdFx0fSxcblx0XHR1cGRhdGVTZWxlY3RlZFRlYW1Ud286ICh0ZWFtOiBzdHJpbmcgfCBudWxsKSA9PiB7XG5cdFx0XHRzZWxmLnNlbGVjdGVkVGVhbVR3byA9IHRlYW1cblx0XHR9LFxuXHRcdGNyZWF0ZU1hdGNoQmV0OiAobWF0Y2hCZXQ6IGFueSkgPT4ge1xuXHRcdFx0c2VsZi5tYXRjaEJldHMucHVzaChtYXRjaEJldClcblx0XHR9LFxuXHRcdGRlbGV0ZU1hdGNoQmV0OiAoaW5kZXg6IG51bWJlcikgPT4ge1xuXHRcdFx0c2VsZi5tYXRjaEJldHMuc3BsaWNlKGluZGV4LCAxKVxuXHRcdH0sXG5cdH0pKVxuXG5jb25zdCBSb290U3RvcmUgPSBTdG9yZS5jcmVhdGUoKVxuXG5leHBvcnQgZGVmYXVsdCBSb290U3RvcmVcblxuZXhwb3J0IGludGVyZmFjZSBJU3RvcmUgZXh0ZW5kcyBJbnN0YW5jZTx0eXBlb2YgU3RvcmU+IHt9XG4iXSwibmFtZXMiOlsidHlwZXMiLCJNYXRjaEJldCIsIlN0b3JlIiwibW9kZWwiLCJzZWxlY3RlZExlYWd1ZSIsIm1heWJlTnVsbCIsIm51bWJlciIsInNlbGVjdGVkVGVhbU9uZSIsInN0cmluZyIsInNlbGVjdGVkVGVhbVR3byIsIm1hdGNoQmV0cyIsImFycmF5IiwiYWN0aW9ucyIsInNlbGYiLCJ1cGRhdGVTZWxlY3RlZExlYWd1ZSIsImxlYWd1ZUlkIiwidXBkYXRlU2VsZWN0ZWRUZWFtT25lIiwidGVhbSIsInVwZGF0ZVNlbGVjdGVkVGVhbVR3byIsImNyZWF0ZU1hdGNoQmV0IiwibWF0Y2hCZXQiLCJwdXNoIiwiZGVsZXRlTWF0Y2hCZXQiLCJpbmRleCIsInNwbGljZSIsIlJvb3RTdG9yZSIsImNyZWF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/index.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/store/models/matchBet.tsx":
/*!***************************************!*\
  !*** ./src/store/models/matchBet.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MatchBet: function() { return /* binding */ MatchBet; }\n/* harmony export */ });\n/* harmony import */ var mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mobx-state-tree */ \"(app-pages-browser)/./node_modules/mobx-state-tree/dist/mobx-state-tree.module.js\");\n\nconst MatchBet = mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__.types.model(\"MatchBet\", {\n    id: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__.types.identifier,\n    league: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__.types.string,\n    match: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__.types.string,\n    map: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__.types.string,\n    betOnTeam: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__.types.string,\n    matchObjective: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__.types.string,\n    matchOdds: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__.types.number,\n    matchDate: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__.types.string,\n    betAmount: mobx_state_tree__WEBPACK_IMPORTED_MODULE_0__.types.number\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zdG9yZS9tb2RlbHMvbWF0Y2hCZXQudHN4IiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZEO0FBRXRELE1BQU1DLFdBQVdELGtEQUFLQSxDQUFDRSxLQUFLLENBQUMsWUFBWTtJQUMvQ0MsSUFBSUgsa0RBQUtBLENBQUNJLFVBQVU7SUFDcEJDLFFBQVFMLGtEQUFLQSxDQUFDTSxNQUFNO0lBQ3BCQyxPQUFPUCxrREFBS0EsQ0FBQ00sTUFBTTtJQUNuQkUsS0FBS1Isa0RBQUtBLENBQUNNLE1BQU07SUFDakJHLFdBQVdULGtEQUFLQSxDQUFDTSxNQUFNO0lBQ3ZCSSxnQkFBZ0JWLGtEQUFLQSxDQUFDTSxNQUFNO0lBQzVCSyxXQUFXWCxrREFBS0EsQ0FBQ1ksTUFBTTtJQUN2QkMsV0FBV2Isa0RBQUtBLENBQUNNLE1BQU07SUFDdkJRLFdBQVdkLGtEQUFLQSxDQUFDWSxNQUFNO0FBQ3hCLEdBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0b3JlL21vZGVscy9tYXRjaEJldC50c3g/ZDE0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0eXBlcywgSW5zdGFuY2UsIFNuYXBzaG90SW4gfSBmcm9tICdtb2J4LXN0YXRlLXRyZWUnXG5cbmV4cG9ydCBjb25zdCBNYXRjaEJldCA9IHR5cGVzLm1vZGVsKCdNYXRjaEJldCcsIHtcblx0aWQ6IHR5cGVzLmlkZW50aWZpZXIsXG5cdGxlYWd1ZTogdHlwZXMuc3RyaW5nLFxuXHRtYXRjaDogdHlwZXMuc3RyaW5nLFxuXHRtYXA6IHR5cGVzLnN0cmluZyxcblx0YmV0T25UZWFtOiB0eXBlcy5zdHJpbmcsXG5cdG1hdGNoT2JqZWN0aXZlOiB0eXBlcy5zdHJpbmcsXG5cdG1hdGNoT2RkczogdHlwZXMubnVtYmVyLFxuXHRtYXRjaERhdGU6IHR5cGVzLnN0cmluZyxcblx0YmV0QW1vdW50OiB0eXBlcy5udW1iZXIsXG59KVxuXG5leHBvcnQgaW50ZXJmYWNlIElNYXRjaEJldCBleHRlbmRzIEluc3RhbmNlPHR5cGVvZiBNYXRjaEJldD4ge31cbmV4cG9ydCBpbnRlcmZhY2UgSU1hdGNoQmV0U25hcHNob3QgZXh0ZW5kcyBTbmFwc2hvdEluPHR5cGVvZiBNYXRjaEJldD4ge31cbiJdLCJuYW1lcyI6WyJ0eXBlcyIsIk1hdGNoQmV0IiwibW9kZWwiLCJpZCIsImlkZW50aWZpZXIiLCJsZWFndWUiLCJzdHJpbmciLCJtYXRjaCIsIm1hcCIsImJldE9uVGVhbSIsIm1hdGNoT2JqZWN0aXZlIiwibWF0Y2hPZGRzIiwibnVtYmVyIiwibWF0Y2hEYXRlIiwiYmV0QW1vdW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/store/models/matchBet.tsx\n"));

/***/ })

});